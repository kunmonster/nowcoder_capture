[
  {
    "title": 2019,
    "testDetail": [
      {
        "id": 1,
        "select": true,
        "detail": "  设 n 是描述问题规模的非负整数，下列程序段的时间复杂度是 。  x=0;\nwhile (n>=(x+1)*(x+1))\nx=x+1; \n ",
        "answers": {
          "RightAnswer": "B",
          "A": "O(logn)",
          "B": "O(n",
          "C": "O(n)",
          "D": "O(n"
        },
        "review": [
          {
            "detail": "\n@https://www.nowcoder.com/equation?tex=n%20%5Cge%20(x%20%2B%201)%5E2&preview=true@ 等价于@https://www.nowcoder.com/equation?tex=x%20%5Cle%20%5Csqrt%7Bn%7D%20-%201&preview=true@ ,所以Big O时间复杂度为@https://www.nowcoder.com/equation?tex=O(n%5E%7B1%2F2%7D)&preview=true@\n"
          }
        ]
      },
      {
        "id": 2,
        "select": true,
        "detail": "若将一棵树 T 转化为对应的二叉树 BT，则下列对 BT 的遍历中，其遍历序列与 T 的后根遍历序列相同的是",
        "answers": {
          "RightAnswer": "B",
          "A": "先序遍历",
          "B": "中序遍历",
          "C": "后序遍历",
          "D": "按层遍历"
        },
        "review": []
      },
      {
        "id": 3,
        "select": true,
        "detail": "对 n 个互不相同的符号进行哈夫曼编码。若生成的哈夫曼树共有 115 个结点，则 n 的值是",
        "answers": {
          "RightAnswer": "C",
          "A": "56",
          "B": "57",
          "C": "58",
          "D": "60"
        },
        "review": [
          {
            "detail": "\nn个叶子结点的哈夫曼树，共2n-1个结点 2n-1=115 解得n=58 \n"
          }
        ]
      },
      {
        "id": 4,
        "select": true,
        "detail": "  在任意一棵非空平衡二叉树（AVL 树）T1 中，删除某结点 v 之后形成平衡二叉树 T2， 再将 v 插入 T2形成平衡二叉树 T3。下列关于 T1与 T3 的叙述中，正确的是   I．若 v 是 T1的叶结点，则 T1与 T3 可能不相同   II．若 v 不是 T1 的叶结点，则 T1 与 T3一定不相同    III．若 v 不是 T1的叶结点，则 T1与 T3 一定相同 ",
        "answers": {
          "RightAnswer": "A",
          "A": "仅 I",
          "B": "仅 II",
          "C": "仅 I、II",
          "D": "仅 I、III "
        },
        "review": [
          {
            "detail": "\n@https://uploadfiles.nowcoder.com/images/20210724/944184618_1627135274541/3868E54D88F20D317E015FD3F5BD5087@\n"
          },
          {
            "detail": "\n                                                                    我也好懵\n                                                            "
          },
          {
            "detail": "\n                                                                    有朋友知道为什么三是错误的么\n                                                            "
          }
        ]
      },
      {
        "id": 5,
        "select": true,
        "detail": "  下图所示的 AOE 网表示一项包含 8 个活动的工程。活动 d 的最早开始时间和最迟开始时间分别是___ 。   @https://uploadfiles.nowcoder.com/images/20200926/330906_1601121834418_FD2E7175E9BA5CB211664A452AE6566E@ ",
        "answers": {
          "RightAnswer": "C",
          "A": "3 和 7",
          "B": "12 和 12",
          "C": "12 和 14",
          "D": "15 和 15"
        },
        "review": [
          {
            "detail": "\n  这题选C 因为活动d的最早开始时间等于该活动弧的起点所表示的时间的最早发生时间=max(a,b+c)=max(3,12)=12    活动d的最迟开始时间等于该活动弧的最迟发生时间与该活动所需时间之差，图中的关键路径长度为27，所以事件发生的最迟时间为min(27-g)=21,所以d的最迟开始时间为21-d=14    \n"
          },
          {
            "detail": "\n                                                                    C \n                                                            "
          }
        ]
      },
      {
        "id": 6,
        "select": true,
        "detail": "用有向无环图描述表达式 (x + y)((x + y) / x) ，需要的顶点个数至少是____",
        "answers": {
          "RightAnswer": "A",
          "A": "5",
          "B": "6",
          "C": "8",
          "D": "9"
        },
        "review": [
          {
            "detail": "\n                                                                    xy+/*\n                                                            "
          }
        ]
      },
      {
        "id": 7,
        "select": true,
        "detail": "  选择一个排序算法时，除算法的时空效率，下列因素中，还需要考虑的是 。     I．数据的规模     II．数据的存储方式     III．算法的稳定性     IV．数据的初始状态 ",
        "answers": {
          "RightAnswer": "D",
          "A": "仅 III",
          "B": "仅 I、II",
          "C": "仅 II、III、IV",
          "D": "I、II、III、IV"
        },
        "review": [
          {
            "detail": "\n                                                                    D\n                                                            "
          },
          {
            "detail": "\n                                                                    D\n                                                            "
          }
        ]
      },
      {
        "id": 8,
        "select": true,
        "detail": "现有长度为 11 且初始为空的散列表 HT，散列函数是 H(key) = key % 7，采用线性探查 （线性探测再散列）法解决冲突。将关键字序列 87, 40, 30, 6, 11, 22, 98, 20 依次插入 HT 后，HT 查找失败的平均查找长度是",
        "answers": {
          "RightAnswer": "C",
          "A": "4",
          "B": "5.25",
          "C": "6",
          "D": "6.29"
        },
        "review": [
          {
            "detail": "\n  1. 构造散列表 根据散列函数 H(key) = key %7 以及线性再探测，我们可以构造出散列表，如下图@https://uploadfiles.nowcoder.com/files/20201202/9870523_1606893873723/20191125161051412.png@   2. 计算失败的平均查找长度  计算失败，可以转换理解，就是在已经构造好的散列表上，我们再去插入一个新的值需要比较多少次。    比如，现在我再插入一个数 21，那么理论上应该存放在地址 0 的位置，但是地址 0 有 98 了，则我们线性再探测（就是依次增加一个地址，看是否为空，空则可以插入），同理地址 1 也存在元素。以此类推，我们一共要比较地址 0~7，发现都有值，直到比较地址 8 才为空。所以一共比较了 9 次。    对其他地址（0~6）用同样的方式去理解，则一共比较的次数是 9+8+7+6+5+4+3 = 42    这里要注意，因为我们的模是 7，所以计算的地址只可能在（0~6）这个范围，所以最后的结果是 42/7 =6    3.计算成功的平均查找长度 计算成功的长度，就是记录下每个数值比较了几次找到可存储的空间。 比如，本题每个数值比较（并存入）对应地址的次数如下图。 @https://uploadfiles.nowcoder.com/files/20201202/9870523_1606893931124/20191125162509330.png@     所以其 ASL = 1+1+1+1+1+1+1+1/8=1    note 1.注意失败与成功的查找长度的分母意义是不同的，失败时，分母是模的值；成功时，分母是元素个数。   \n"
          },
          {
            "detail": "\n                                                                    老哥，看完你第一句就懂了！棒棒哒！！！\n                                                            "
          }
        ]
      },
      {
        "id": 9,
        "select": true,
        "detail": "设主串 T = \"abaabaabcabaabc\"，模式串 S = \"abaabc\"，采用 KMP 算法进行模式匹配，到 匹配成功时为止，在匹配过程中进行的单个字符间的比较次数是",
        "answers": {
          "RightAnswer": "B",
          "A": "9",
          "B": "10",
          "C": "12",
          "D": "15"
        },
        "review": [
          {
            "detail": "\n                                                                    B。@https://uploadfiles.nowcoder.com/compress/mw1000/images/20210327/484424729_1616857444318/CFF79187A306213A7F7E78A150212422@\n"
          },
          {
            "detail": "\n                                                                    参考KMP算法 http://www.ruanyifeng.com/blog/2013/05/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm.html\n"
          }
        ]
      },
      {
        "id": 10,
        "select": true,
        "detail": "排序过程中，对尚未确定最终位置的所有元素进行一遍处理称为一“趟”。下列序列 中，不可能是快速排序第二趟结果的是",
        "answers": {
          "RightAnswer": "D",
          "A": "5, 2, 16, 12, 28, 60, 32, 72",
          "B": "2, 16, 5, 28, 12, 60, 32, 72",
          "C": "2, 12, 16, 5, 28, 32, 72, 60",
          "D": "5, 2, 12, 28, 16, 32, 72, 60"
        },
        "review": [
          {
            "detail": "\n                                                                    快速排序如第一趟确定的值是首尾元素，则第二趟只能确定一个数；如第一趟确定的是中间元素，则第二趟会确定两个元素，在递归实现中表示为，左右分别要递归一次，得出两个值\n                                                            "
          },
          {
            "detail": "\n@https://uploadfiles.nowcoder.com/images/20210606/526271640_1622984849776/C7849C1976B3930E80939BCDDE511FBB@\n"
          },
          {
            "detail": "\n  A中，第一次快排选的基准值是72，第二次的基准值是28    B中，第一次的基准值是72，第二次的是2    C中，第一次的基准值是28，第二次的基准值是2 和32. \n"
          }
        ]
      },
      {
        "id": 11,
        "select": true,
        "detail": "设外存上有 120 个初始归并段，进行 12 路归并时，为实现最佳归并，需要补充的虚段个数是 ____。",
        "answers": {
          "RightAnswer": "B",
          "A": "1",
          "B": "2",
          "C": "3",
          "D": "4"
        },
        "review": [
          {
            "detail": "\n  设n0,n12,n补,分别为度为零，十二和要补充的结点，则有：    n0=120+n补(根据哈夫曼树构成，度为零的结点全是初始提供的结点）；    n0=12*(n12)-(n12)+1;（根据完全十二叉树构成）；    即n12=（119+n补）/11，且n12为整数，则n补最小为2。 \n"
          },
          {
            "detail": "\n在一般情况下，对于 k–路平衡归并来说，若 (m-1)MOD(k-1)=0，则不需要增加虚段；否则需附加 k-(m-1)MOD(k-1)-1 个虚段。\n"
          },
          {
            "detail": "\n                                                                    12路哈夫曼树\n                                                            "
          }
        ]
      },
      {
        "id": 12,
        "select": true,
        "detail": "  考虑以下 C 语言代码：    unsigned short usi = 65535;     short si = usi;     执行上述程序段后，si 的值是    ",
        "answers": {
          "RightAnswer": "A",
          "A": "-1",
          "B": "-32767",
          "C": "-32768",
          "D": "-65535"
        },
        "review": [
          {
            "detail": "\n  unsigned short 65535的源码为:1111 1111 1111 1111 ，在C语言中正数的源码即是补码；    short  65535表示上述补码中第一个1为符号位（负数），剩下的15个1按位取反+1得源码：    1000 0000 0000 0001 即表示为：-1    故综上所述，答案为A \n"
          },
          {
            "detail": "\n unsigned short usi的65535二级制码: 1111 1111 1111 1111 即short si的补码: 1111 1111 1111 1111 short si的反码: 1000 0000 0000 0000 反码+1得short si的原码: 1000 0000 0000 0001 \n"
          },
          {
            "detail": "\n                                                                    无符号与有符号的short产生了错误 输出1\n                                                            "
          }
        ]
      },
      {
        "id": 13,
        "select": true,
        "detail": "下列关于缺页处理的叙述中，错误的是",
        "answers": {
          "RightAnswer": "D",
          "A": "缺页是在地址转换时 CPU 检测到的一种异常",
          "B": "缺页处理由操作系统提供的缺页处理程序来完成",
          "C": "缺页处理程序根据页故障地址从外存读入所缺失的页",
          "D": "缺页处理完成后回到发生缺页的指令的下一条指令执行"
        },
        "review": [
          {
            "detail": "\n                                                                    D 错 ABC描述的就是缺页处理的正常流程，处理完成后会回到发生缺页的指令\n"
          }
        ]
      },
      {
        "id": 14,
        "select": true,
        "detail": "某计算机采用大端方式，按字节编址。某指令中操作数的机器数为 1234 FF00H，该操 作数采用基址寻址方式，形式地址（用补码表示）为 FF12H，基址寄存器的内容为 F000 0000H， 则该操作数的 LSB（最低有效字节）所在的地址是____",
        "answers": {
          "RightAnswer": "D",
          "A": "F000 FF12H",
          "B": "F000 FF15H",
          "C": "EFFF FF12H",
          "D": "EFFF FF15H"
        },
        "review": [
          {
            "detail": "\n@https://uploadfiles.nowcoder.com/images/20210722/526271640_1626940419118/C5E5D163D82E6AD5D05C6884B16AB8D0@\n"
          }
        ]
      },
      {
        "id": 15,
        "select": true,
        "detail": "下列有关处理器时钟脉冲信号的叙述中，错误的是",
        "answers": {
          "RightAnswer": "D",
          "A": "时钟脉冲信号由机器脉冲源发出的脉冲信号经整形和分频后形成",
          "B": "时钟脉冲信号的宽度称为时钟周期，时钟周期的倒数为机器主频",
          "C": "时钟周期以相邻状态单元间组合逻辑电路的最大延迟为基准确定",
          "D": "处理器总是在每来一个时钟脉冲信号时就开始执行一条新的指令"
        },
        "review": [
          {
            "detail": "\n                                                                    指令流水线中，理想情况下每个机器周期完成一条指令并启动一条新指令，而非一个节拍启动一条指令\n                                                            "
          }
        ]
      },
      {
        "id": 16,
        "select": true,
        "detail": "  某指令功能为 R[r2]←R[r1] + M[R[r0]]，其两个源操作数分别采用寄存器、寄存器间接寻址方式。对于下列给定部件，该指令在取数及执行过程中需要用到的是____    I．通用寄存器组（GPRs）    II．算术逻辑单元（ALU）    III．存储器（Memory）    IV．指令译码器（ID） ",
        "answers": {
          "RightAnswer": "B",
          "A": "仅 I、II",
          "B": "仅 I、II、III",
          "C": "仅 II、III、IV",
          "D": "仅 I、III、IV"
        },
        "review": [
          {
            "detail": "\n一条指令的执行过程为取指令、分析指令、执行指令，指令译码器是属于分析指令阶段\n"
          },
          {
            "detail": "\n                                                                    执行 用到算术逻辑单元ALU、寄存器寻址用到通用寄存器、寄存器间接寻址用到存储器\n                                                            "
          }
        ]
      },
      {
        "id": 17,
        "select": true,
        "detail": "  在采用“取指、译码/取数、执行、访存、写回”5 段流水线的处理器中，执行如下指 令序列，其中 s0、s1、s2、s3 和 t2 表示寄存器编号    I1：add s2,s1,s0     // R[s2]<-R[s1]+R[s0]     I2：load s3,0(t2)     // R[s3]<-M[R[t2]+0]     I3：add s2,s2,s3     // R[s2]<-R[s2]+R[s3]     I4：store s2,0(t2)    // M[R[t2]+0]-<R[s2]    下列指令对中，不存在数据冒险的是___ ",
        "answers": {
          "RightAnswer": "C",
          "A": "I1 和 I3",
          "B": "I2 和 I3",
          "C": "I2 和 I4",
          "D": "I3 和 I4"
        },
        "review": [
          {
            "detail": "\n 数据冒险           流水线使原先有先后顺序的指令同时处理，当出现某些指令的组合时，可能会导致指令使用了错误的数据。 \n"
          }
        ]
      },
      {
        "id": 18,
        "select": true,
        "detail": "假定一台计算机采用 3 通道存储器总线，配套的内存条型号为 DDR3-1333，即内存条所接插的存储器总线的工作频率为 1333MHz，总线宽度为 64 位，则存储器总线的总带宽大约是",
        "answers": {
          "RightAnswer": "B",
          "A": "10.66GB/s",
          "B": "32GB/s",
          "C": "64GB/s",
          "D": "96GB/s"
        },
        "review": [
          {
            "detail": "\n  首先总线的宽度为64bit，即8字节(Byte)，则采用三通道的存储器总线的总带宽为    8×1333×3=31.992≈32GB/s \n"
          }
        ]
      },
      {
        "id": 19,
        "select": true,
        "detail": "下列关于磁盘存储器的叙述中，错误的是",
        "answers": {
          "RightAnswer": "C",
          "A": "磁盘的格式化容量比非格式化容量小",
          "B": "扇区中包含数据、地址和校验等信息",
          "C": "磁盘存储器的最小读写单位为一字节",
          "D": "磁盘存储器由磁盘控制器、磁盘驱动器和盘片组成"
        },
        "review": [
          {
            "detail": "\n磁盘存储器的最小单位不是字节，而是一个扇区！\n"
          },
          {
            "detail": "\n磁盘存储器的最小单位不是字节，而是一个比特(bit)\n"
          }
        ]
      },
      {
        "id": 20,
        "select": true,
        "detail": "某设备以中断方式与 CPU 进行数据交换，CPU 主频为 1GHz，设备接口中的数据缓冲 寄存器为 32 位，设备的数据传输率为 50kB/s。若每次中断开销（包括中断响应和中断处理）为 1000 个时钟周期，则 CPU 用于该设备输入/输出的时间占整个 CPU 时间的百分比最多是",
        "answers": {
          "RightAnswer": "A",
          "A": "1.25%",
          "B": "2.5%",
          "C": "5%",
          "D": "12.5%"
        },
        "review": [
          {
            "detail": "\n  假设该设备一直处于与CPU进行数据交换的状态，而数据缓冲寄存器为32位，设备的传输率为50KB/s，即400000bit/s，则缓存器存满需要32/400000=8×10-5秒，而每次中断开销为1000个时钟周期，主频为1GHz，则1000个时钟周期为1×10-6秒，所以CPU用于设备输入输出时间即中断处理时间为[1×10-6/(8×10-5)]×100%=1.25% \n"
          },
          {
            "detail": "\n  首先设备以中断方式与cpu进行数据交互的时候是并行运行的，那么我们可以用一秒钟的时间来比较两者的数据交换的次数，设备充满寄存器一秒内就需50kB/s / 4B=12.5k次，而1000时钟周期，cpu运行1G / 1000 次，所以12.5k / 1M =1.25% \n"
          }
        ]
      },
      {
        "id": 21,
        "select": true,
        "detail": "  下列关于 DMA 方式的叙述中，正确的是    I．DMA 传送前由设备驱动程序设置传送参数    II．数据传送前由 DMA 控制器请求总线使用权    III．数据传送由 DMA 控制器直接控制总线完成    IV．DMA 传送结束后的处理由中断服务程序完成 ",
        "answers": {
          "RightAnswer": "D",
          "A": "仅 I、II",
          "B": "仅 I、III、IV",
          "C": "仅 II、III、IV",
          "D": "I、II、III、IV"
        },
        "review": []
      },
      {
        "id": 22,
        "select": true,
        "detail": "下列关于冯·诺依曼结构计算机基本思想的叙述中，错误的是",
        "answers": {
          "RightAnswer": "C",
          "A": "程序的功能都通过中央处理器执行指令实现",
          "B": "指令和数据都用二进制数表示，形式上无差别",
          "C": "指令按地址访问，数据都在指令中直接给出",
          "D": "程序执行前，指令和数据需预先存放在存储器中"
        },
        "review": [
          {
            "detail": "\n                                                                    C 指令和数据都存放在存储器中，都按地址访问。CPU区分从存储器中取出的是指令还是数据的依据是指令和数据的访问阶段不同。\n                                                            "
          },
          {
            "detail": "\n                                                                    C，因为A说“程序的功能都通过中央处理器执行指令实现”，但有些功能暂时是无法实现的；B说“指令和数据都用二进制数表示，形式上无差别”，数据可以用2进制表示，但指令的2进制表示方法明显和数据不一样。D说“程序执行前，指令和数据需预先存放在存储器中”，但可以运行时再输入。所以是C\n"
          }
        ]
      },
      {
        "id": 23,
        "select": true,
        "detail": "下列关于线程的描述中，错误的是 。",
        "answers": {
          "RightAnswer": "B",
          "A": "内核级线程的调度由操作系统完成",
          "B": "操作系统为每个用户级线程建立一个线程控制块",
          "C": "用户级线程间的切换比内核级线程间的切换效率高",
          "D": "用户级线程可以在不支持内核级线程的操作系统上实现"
        },
        "review": [
          {
            "detail": "\n在多线程模型中，用户级线程和内核级线程的连接方式分为多对一、一对一和多对多，操作系统为每个用户级线程建立一个线程控制块是属于一对一模型，其他两个模型没有为用户级线程建立一个线程控制块，即B选项错误\n"
          }
        ]
      },
      {
        "id": 24,
        "select": true,
        "detail": "  下列选项中，可能会将进程唤醒的事件是    I．I/O 结束    II．某进程退出临界区    III．当前进程的时间片用完 ",
        "answers": {
          "RightAnswer": "C",
          "A": "仅 I",
          "B": "仅 III",
          "C": "仅 I、II",
          "D": "I、II、III"
        },
        "review": [
          {
            "detail": "\n 答案：C   当被阻塞进程等待的某资源（不包括处理机）可用时，进程将会被唤醒。I/O结束后，等待该I/O结束而被阻塞的有关进程会被唤醒，即 I 正确；  某进程退出临界区后，之前会因需要进入该临界区而被阻塞的有关进程会被唤醒，即 II 正确； 当前时间片用完后进入就绪队列等待重新调度，即由运行态变为就绪态，即 III 错误。\n"
          },
          {
            "detail": "\n  C    当前进程的时间片完后进入就绪队列等待重新调度，优先级最高的进程获得处理机资源从就绪态变为执行态，只有，不会涉及到进程的唤醒 \n"
          }
        ]
      },
      {
        "id": 25,
        "select": true,
        "detail": "  下列关于系统调用的叙述中，正确的是   I．在执行系统调用服务程序的过程中，CPU 处于内核态    II．操作系统通过提供系统调用避免用户程序直接访问外设    III．不同的操作系统为应用程序提供了统一的系统调用接口    IV．系统调用是操作系统内核为应用程序提供服务的接口 ",
        "answers": {
          "RightAnswer": "C",
          "A": "仅 I、IV",
          "B": "仅 II、III",
          "C": "仅 I、II、IV",
          "D": "仅 I、III、IV"
        },
        "review": [
          {
            "detail": "\n C [解析]用户可以在用户态调用操作系统的服务，但执行具体的系统调用服务程序是处于内核态的，I正确;    设备管理属于操作系统的职能之一，包括对输入/输出设备的分配、初始化、维护等，用户程序需要通过系统调用使用操作系统的设备管理服务，II正确;    操作系统不同，底层逻辑、实现方式均不相同，为应用程序提供的系统调用接口也不同，III错误;    系统调用是用户在程序中调用操作系统提供的子功能，IV正确。      \n"
          },
          {
            "detail": "\n操作系统不同，底层逻辑、实现方式均不同，为应用程序提供的系统调用接口也不同\n"
          }
        ]
      },
      {
        "id": 26,
        "select": true,
        "detail": "  下列选项中，可用于文件系统管理空闲磁盘块的数据结构是    I．位图     II．索引结点     III．空闲磁盘块链     IV．文件分配表（FAT） ",
        "answers": {
          "RightAnswer": "B",
          "A": "仅 I、II",
          "B": "仅 I、III、IV",
          "C": "仅 I、III",
          "D": "仅 II、III、IV"
        },
        "review": [
          {
            "detail": "\n                                                                    好容易错选C。。。。如果只看王道\n                                                            "
          },
          {
            "detail": "\n文件系统管理空闲磁盘块的数据结构包括位图、链表、文件分配表。索引结点是指在许多类Unix文件系统中的一种数据结构。每个索引节点保存了文件系统中的一个文件系统对象的元信息数据，但不包括数据内容或者文件名。\n"
          }
        ]
      },
      {
        "id": 27,
        "select": true,
        "detail": "系统采用二级反馈队列调度算法进行进程调度。就绪队列 Q1 采用时间片轮转调度算法， 时间片为 10ms；就绪队列 Q2 采用短进程优先调度算法；系统优先调度 Q1 队列中的进程，当 Q1 为空时系统才会调度 Q2 中的进程；新创建的进程首先进入 Q1；Q1中的进程执行一个时间片后，若未结束，则转入 Q2。若当前 Q1、Q2 为空，系统依次创建进程 P1、P2后即开始进程调度， P1、P2需要的 CPU 时间分别为 30ms 和 20ms，则进程 P1、P2在系统中的平均等待时间为____",
        "answers": {
          "RightAnswer": "C",
          "A": "25ms",
          "B": "20ms",
          "C": "15ms",
          "D": "10ms"
        },
        "review": [
          {
            "detail": "\n                                                                    (（30-0-20）+（50-0-30））/2=15\n                                                            "
          },
          {
            "detail": "\n您好，我想问一下，题目中不是说 “Q1中的进程执行一个时间片后，若未结束，则转入 Q2” 嘛， 轮到p2在Q1中执行的那10ms里，P1不是应该先进去Q2了吗？这时Q2只有p1在，先执行10ms, p2到了Q2再抢走执行。不是这样吗，这里不太懂，如果答主看到记得回一下我呀\n"
          },
          {
            "detail": "\n                                                                    执行顺序： I.P1在Q1中执行10ms(剩余20ms)； II.P2在Q1中执行10ms(剩余10ms)； III.P2在Q2中执行10ms(剩余0ms)； IV.P1在Q2中执行20ms(剩余0ms)。  可得，P1的等待时间为第10-30ms之间，共20ms。P2的等待时间为0-1ms直接，共10ms。平均等待时间为(20+10)/2=15ms\n                                                            "
          }
        ]
      },
      {
        "id": 28,
        "select": true,
        "detail": "在分段存储管理系统中，用共享段表描述所有被共享的段。若进程 P1和 P2共享段S， 下列叙述中，错误的是",
        "answers": {
          "RightAnswer": "C",
          "A": "在物理内存中仅保存一份段 S 的内容",
          "B": "段 S 在 P1和 P2中应该具有相同的段号",
          "C": "P1 和 P2 共享段 S 在共享段表中的段表项",
          "D": "P1和 P2都不再使用段 S 时才回收段 S 所占的内存空间"
        },
        "review": []
      },
      {
        "id": 29,
        "select": true,
        "detail": "某系统釆用 LRU 页置换算法和局部置换策略，若系统为进程 P 预分配了 4 个页框， 进程 P 访问页号的序列为 0, 1, 2, 7, 0, 5, 3, 5, 0, 2, 7, 6，则进程访问上述页的过程中，产生页置换的总次数是",
        "answers": {
          "RightAnswer": "C",
          "A": "3",
          "B": "4",
          "C": "5",
          "D": "6"
        },
        "review": []
      },
      {
        "id": 30,
        "select": true,
        "detail": "  下列关于死锁的叙述中，正确的是    I ．可以通过剥夺进程资源解除死锁     II．死锁的预防方法能确保系统不发生死锁     III．银行家算法可以判断系统是否处于死锁状态     IV．当系统出现死锁时，必然有两个或两个以上的进程处于阻塞态 ",
        "answers": {
          "RightAnswer": "B",
          "A": "仅 II、III",
          "B": "仅 I、II、IV",
          "C": "仅 I、II、III",
          "D": "仅 I、III、IV"
        },
        "review": [
          {
            "detail": "\n                                                                    <p>死锁避免是指每次申请资源时判断这些操作是否安全，银行家算法可以用来处理死锁避免问题。</p><p>死锁检测是判断系统是否处于死锁的状态。</p>\n                                                            "
          }
        ]
      },
      {
        "id": 31,
        "select": true,
        "detail": "  某计算机主存按字节编址，采用二级分页存储管理，地址结构如下所示：   @https://uploadfiles.nowcoder.com/images/20200926/330906_1601123290296_3847E3FEBAA8043BE87922C1BE21E181@    虚拟地址 2050 1225H 对应的页目录号、页号分别是 ",
        "answers": {
          "RightAnswer": "A",
          "A": "081H、101H",
          "B": "081H、401H",
          "C": "201H、101H",
          "D": "201H、401H"
        },
        "review": [
          {
            "detail": "\n@https://uploadfiles.nowcoder.com/images/20210830/526271640_1630314580590/643D39FD951C4261B09F733F92F9100F@\n"
          }
        ]
      },
      {
        "id": 32,
        "select": true,
        "detail": "在下列动态分区分配算法中，最容易产生内存碎片的是",
        "answers": {
          "RightAnswer": "C",
          "A": "首次适应算法",
          "B": "最坏适应算法",
          "C": "最佳适应算法",
          "D": "循环首次适应算法"
        },
        "review": [
          {
            "detail": "\n答案：C 解析：最佳适应算法总是匹配与当前大小要求最接近的空闲分区，但是大多数情况下空闲分区的大小不可能完全和当前要求的大小相等，几乎每次分配内存都会产生很小的难以利用的内存块，即最佳适应算法最容易产生最多的内部碎片。【2019考研408操作系统客观题】\n"
          },
          {
            "detail": "\n  注意内存碎片和内部碎片。。。    如果说是内部碎片应该选什么？最坏适应算法吗？ \n"
          }
        ]
      },
      {
        "id": 33,
        "select": true,
        "detail": "OSI 参考模型的第 5 层（自下而上）完成的主要功能是",
        "answers": {
          "RightAnswer": "C",
          "A": "差错控制",
          "B": "路由选择",
          "C": "会话管理",
          "D": "数据表示转换"
        },
        "review": [
          {
            "detail": "\n                                                                    物数网传会表应\n                                                            "
          }
        ]
      },
      {
        "id": 34,
        "select": true,
        "detail": "100BaseT快速以太网使用的导向传输介质是 。",
        "answers": {
          "RightAnswer": "A",
          "A": "双绞线",
          "B": "单模光纤",
          "C": "多模光纤",
          "D": "同轴电缆"
        },
        "review": [
          {
            "detail": "\n                                                                    T代表双绞线-twisted\n                                                            "
          }
        ]
      },
      {
        "id": 35,
        "select": true,
        "detail": "对于滑动窗口协议，若分组序号采用 3 比特编号，发送窗口大小为 5，则接收窗口最大是 。",
        "answers": {
          "RightAnswer": "B",
          "A": "2",
          "B": "3",
          "C": "4",
          "D": "5"
        },
        "review": [
          {
            "detail": "\n  公式：发送窗口+接收窗口 <= 2^n    这里n=3    所以接收窗口最大为3 \n"
          },
          {
            "detail": "\n                                                                    这里最大则是指选择重传协议\n                                                            "
          }
        ]
      },
      {
        "id": 36,
        "select": true,
        "detail": "假设一个采用 CSMA/CD 协议的 10Mb/s 局域网，最小帧长是 128B，则在一个冲突域 内两个站点之间的单向传播延时最多是",
        "answers": {
          "RightAnswer": "B",
          "A": "2.56µs",
          "B": "5.12µs",
          "C": "10.24µs",
          "D": "20.48µs"
        },
        "review": [
          {
            "detail": "\n  发送时延：(128*8*10^6)/10^8=10.24us    CSMA/CD协议中，发送的时间要大于一个来回时间用来保证在能够发送时监听到最远距离发生的碰撞。即发送时延≥来回传播时延    所以单向传播延时最多5.12us   选B \n"
          },
          {
            "detail": "\n2019年408的题，题干应为 100 Mb/s @https://www.nowcoder.com/equation?tex=%0A2%5Ctau%5Cle%5Cfrac%7B%E6%9C%80%E5%B0%8F%E5%B8%A7%E9%95%BF%7D%7B%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93%E7%8E%87%7D%0A&preview=true@\n"
          },
          {
            "detail": "\n@https://uploadfiles.nowcoder.com/images/20201123/207575826_1606099072781_0D5EBDDBA35A5C755DB85C94971F0EF9@\n"
          }
        ]
      },
      {
        "id": 37,
        "select": true,
        "detail": "若将 101.200.16.0/20 划分为 5 个子网，则可能的最小子网的可分配 IP 地址数是",
        "answers": {
          "RightAnswer": "B",
          "A": "126",
          "B": "254",
          "C": "510",
          "D": "1022"
        },
        "review": [
          {
            "detail": "\n  101.200.16.0/20划分5个子网    101.200.0001 0000 .0    101.200.0001 1000 .0    101.200.0001 1100 .0    101.200.0001 1110 .0    101.200.0001 1111 .0   最小子网的可分配IP地址数 2的8次方-2 =254  选B \n"
          },
          {
            "detail": "\n \"最小\"子网，如果是普通的定长子网划分，不存在所谓的最小子网    因此本题中采用变长子网的划分方法   101.200.0001 1111 .0 为最小子网   可分配IP(去除全1全0)地址数：2^8-2=254 \n"
          }
        ]
      },
      {
        "id": 38,
        "select": true,
        "detail": "  某客户通过一个 TCP 连接向服务器发送数据的部分过程如题 38 图所示。客户在 t0 时 刻第一次收到确认序列号 ack_seq = 100 的段，并发送序列号 seq = 100 的段，但发生丢失。若 TCP 支持快速重传，则客户重新发送 seq = 100 段的时刻是   @https://uploadfiles.nowcoder.com/images/20200926/330906_1601123638122_9862C500885BD21BE09C2D0A3C05740F@ ",
        "answers": {
          "RightAnswer": "C",
          "A": "t1",
          "B": "t2",
          "C": "t3",
          "D": "t4"
        },
        "review": [
          {
            "detail": "\n TCP有超时重传机制，但超时重传往往会带来许多微妙的问题，比如说：   当一个报文段丢失时，会等待一定的超时周期然后才重传分组，增加了端到端的时延。    当一个报文段丢失时，在其等待超时的过程中，可能会出现这种情况：其后的报文段已经被接收端接收但却迟迟得不到确认，发送端会认为也丢失了，从而引起不必要的重传，既浪费资源也浪费时间。           TCP采用的是累计确认机制，即当接收端收到比期望序号大的报文段时，便会重复发送最近一次确认的报文段的确认信号，我们称之为冗余ACK（duplicate ACK）     在超时重传定时器溢出之前，接收到连续的三个重复冗余ACK（其实是收到4个同样的ACK，第一个是正常的，后三个才是冗余的），发送端便知晓哪个报文段在传输过程中丢失了，    于是重发该报文段，不需要等待超时重传定时器溢出，大大提高了效率。这便是快速重传机制    在本题中，如图所示，应当在t3时刻收到第三个重复冗余ACK时重传 \n"
          }
        ]
      },
      {
        "id": 39,
        "select": true,
        "detail": "若主机甲主动发起一个与主机乙的 TCP 连接，甲、乙选择的初始序列号分别为 2018 和 2046，则第三次握手 TCP 段的确认序列号是",
        "answers": {
          "RightAnswer": "D",
          "A": "2018",
          "B": "2019",
          "C": "2046",
          "D": "2047"
        },
        "review": [
          {
            "detail": "\n第三次握手的TCP段由甲发出，在接收到乙发来的序号2046后，甲应该发出确认号2047。\n"
          }
        ]
      },
      {
        "id": 40,
        "select": true,
        "detail": "下列关于网络应用模型的叙述中，错误的是",
        "answers": {
          "RightAnswer": "B",
          "A": "在 P2P 模型中，结点之间具有对等关系",
          "B": "在客户/服务器（C/S）模型中，客户与客户之间可以直接通信",
          "C": "在 C/S 模型中，主动发起通信的是客户，被动通信的是服务器",
          "D": "在向多用户分发一个文件时，P2P 模型通常比 C/S 模型所需的时间短"
        },
        "review": []
      },
      {
        "id": 41,
        "select": false,
        "detail": "  设线性表L1=(a1,a2,a3....an-2,an-1,an)采用带头结点的单链表保存，链表中的结点定义如下:  typedef struct node\n{ \n    int data;\n    struct node*next;\n} NODE；\n   请设计一个空间复杂度为 O(1)且时间上尽可能高效的算法，重新排列 L1中的各结点，得到线性表 L2=(a1,an,a2,an-1,a3,an-2,....)，要求:    （1）给出算法的基本设计思想。     （2）根据设计思想，采用 C 或 C++语言描述算法，关键之处给出注释。     （3）说明你所设计的算法的时间复杂度。 ",
        "answers": {
          "detail": "\n  1）算法的基本设计思想：    先观察L1=(a1,a2,a3....an-2,an-1,an)和L2=(a1,an,a2,an-1,a3,an-2,....)    发现 L2是由 L1摘 取第一个元素，再摘取倒数第一个元素……依次合并而成的。为了方便链表后半段取元素，需要先将 L1后半段原地逆置［题目要求空间复杂度为 O(1)，不能借助栈］，否则每取最后一个结 点都需要遍历一次链表。①先找出链表 L1的中间结点，为此设置两个指针 p 和 q，指针 p 每次 走一步，指针 q 每次走两步，当指针 q 到达链尾时，指针 p 正好在链表的中间结点；②然后将 L1的后半段结点原地逆置。③从单链表前后两段中依次各取一个结点，按要求重排    2）算法实现：  void change_list(NODE *h)\n{\n    NODE *p, *q, *r, *s;\n    p = q = h;\n    while (q->next != NULL) //寻找中间结点\n    {\n        p = p->next; //p 走一步\n        q = q->next;\n        if (q->next != NULL)\n            q = q->next; //q 走两步\n    }\n    q = p->next; //p 所指结点为中间结点，q 为后半段链表的首结点\n    p->next = NULL;\n    while (q != NULL) //将链表后半段逆置\n    {\n        r = q->next;\n        q->next = p->next;\n        p->next = q;\n        q = r;\n    }\n    s = h->next; //s 指向前半段的第一个数据结点，即插入点\n    q = p->next; //q 指向后半段的第一个数据结点\n    p->next = NULL;\n    while (q != NULL) //将链表后半段的结点插入到指定位置\n    {\n        r = q->next;       //r 指向后半段的下一个结点\n        q->next = s->next; //将 q 所指结点插入到 s 所指结点之后\n        s->next = q;\n        s = q->next; //s 指向前半段的下一个插入点\n        q = r;\n    }\n}\n \n"
        },
        "review": [
          {
            "detail": "\nvoid change(NODE *head)\n{\n    if(head==null||head->next==null||head->next->next==null)return head;\n    NODE *slow=head,*fast=head;\n    while(fast->next!=null)\n    {\n        slow=slow->next;\n       fast=fast->next;\n        if(fast->next!=null)fast=fast->next;\n    }\n    NODE *pre=slow->next,*curr=pre->next;\n    pre->next=null;\n    while(curr->next!=null)\n    {\n         NODE *nex=curr->next;\n         curr->next=slow->next;\n          slow->next=curr;\n          curr=nex;\n    }\n    curr->next=slow->next;\n    slow->next=curr;\n    NODE *B=slow->next,*A=head->next,*b=B->next,*a=A->next;\n    slow->next=null;\n    NODE *new_head=head,*p=head;\n    while(A!=null||B!=null)\n    {\n        p->next=A;\n        A=a;\n        a=a->next;\n        p=p->next;\n        p->next=B;\n        B=b;\n        b=b->next;\n        p=p->next;\n    }\n    return new_head;\n} \n"
          },
          {
            "detail": "\nvoid change_List(NODE *h)\n{\n    NODE *q,*p,*r,*s;\n    p=q=h;\n    while(q->next != NULL)\n    {\n        p = p->next;\n        q = q->next;\n        if(q->next!=NULL)\n        {\n            q = q->next;\n        }\n        q = p->next;\n        p->next  = NULL;\n        while(q!=NULL)\n        {\n            r = q->next;\n            q->next = p->next;\n            p->next = q;\n            q = r;\n        }\n        s = h->next;\n        q = p->next;\n        p->next = NULL;\n        while(q!=NULL)\n        {\n            r = q->next;\n            q->next = s->next;\n            s->next  = q;\n            s = q->next;\n            q = r;\n        }\n    }\n} \n"
          }
        ]
      },
      {
        "id": 42,
        "select": false,
        "detail": "  请设计一个队列，要求满足：①初始时队列为空；②入队时，允许增加队列 占用空间；③出队后，出队元素所占用的空间可重复使用，即整个队列所占用的空间只增不减； ④入队操作和出队操作的时间复杂度始终保持为 O(1)。请回答下列问题：    （1）该队列是应选择链式存储结构，还是应选择顺序存储结构？     （2）画出队列的初始状态，并给出判断队空和队满的条件。     （3）画出第一个元素入队后的队列状态。     （4）给出入队操作和出队操作的基本过程 ",
        "answers": {
          "detail": "\n  1）顺序存储无法满足要求②的队列占用空间随着入队操作而增加。根据要求来分析：要 求①容易满足；链式存储方便开辟新空间，要求②容易满足；对于要求③，出队后的结点并不 真正释放，用队头指针指向新的队头结点，新元素入队时，有空余结点则无须开辟新空间，赋 值到队尾后的第一个空结点即可，然后用队尾指针指向新的队尾结点，这就需要设计成一个首 尾相接的循环单链表，类似于循环队列的思想。设置队头、队尾指针后，链式队列的入队操作 和出队操作的时间复杂度均为 O(1)，要求④可以满足。    因此，采用链式存储结构（两段式单向循环链表），队头指针为 front，队尾指针为 rear。       2）该循环链式队列的实现，可以参考循环队列，不同之处在于循环链式队列可以方便增 加空间，出队的结点可以循环利用，入队时空间不够也可以动态增加。同样，循环链式队列也 要区分队满和队空的情况，这里参考循环队列牺牲一个单元来判断。初始时，创建只有一个空 闲结点的循环单链表，头指针 front 和尾指针 rear 均指向空闲结点，如下图所示。   @https://uploadfiles.nowcoder.com/images/20200926/330906_1601124389687_17C5E633904FD473BCEEDB523B7A7A59@       队空的判定条件：front == rear。 队满的判定条件：front == rear->next。       3）插入第一个元素后的状态如下图所示。      @https://uploadfiles.nowcoder.com/images/20200926/330906_1601124413705_FC274AA3D1CDCE9B11F1AA6ED55DF72B@          4）操作的基本过程如下：      @https://uploadfiles.nowcoder.com/images/20200926/330906_1601124433251_A7B5A75A7E6180E11C9A1286D01AC574@    \n"
        },
        "review": []
      },
      {
        "id": 43,
        "select": false,
        "detail": "  有 n（n≥3）位哲学家围坐在一张圆桌边，每位哲学家交替地就餐和思考。在 圆桌中心有 m（m≥1）个碗，每两位哲学家之间有一根筷子。每位哲学家必须取到一个碗和两 侧的筷子后，才能就餐，进餐完毕，将碗和筷子放回原位，并继续思考。为使尽可能多的哲学 家同时就餐，且防止出现死锁现象，请使用信号量的 P、V 操作［wait()、signal()操作］描述上 述过程中的互斥与同步，并说明所用信号量及初值的含义。    ",
        "answers": {
          "detail": "\n  解答： 回顾传统的哲学家问题，假设餐桌上有 n 个哲学家、n 根筷子，那么可以用这种方法避免死锁：限制至多允许 n -1个哲学家同时“抢”筷子，那么至 少会有 1 个哲学家可以获得两根筷子并顺利进餐，于是不可能发生死锁的情况。 本题可以用碗这个限制资源来避免死锁：当碗的数量 m 小于哲学家的数量 n 时，可以直接 让碗的资源量等于 m，确保不会出现所有哲学家都拿一侧筷子而无限等待另一侧筷子进而造成 死锁的情况；当碗的数量 m 大于等于哲学家的数量 n 时，为了让碗起到同样的限制效果，我们让碗的资源量等于 n -1，这样就能保证最多只有 n -1个哲学家同时进餐，所以得到碗的资源量 为 min{ n -1, m}。在进行 PV 操作时，碗的资源量起限制哲学家取筷子的作用，所以需要先对 碗的资源量进行 P 操作。具体过程如下：   @https://uploadfiles.nowcoder.com/images/20200926/330906_1601124575712_3B3E3676D13C1200B97E90B9BB62DB97@ \n"
        },
        "review": []
      },
      {
        "id": 44,
        "select": false,
        "detail": "  某计算机系统中的磁盘有 300 个柱面，每个柱面有 10 个磁道，每个磁道有 200 个扇区，扇区大小为 512B。文件系统的每个簇包含 2 个扇区。请回答下列问题：     （1）磁盘的容量是多少？     （2）假设磁头在 85 号柱面上，此时有 4 个磁盘访问请求，簇号分别为 100 260、60 005、 101 660 和 110 560。若采用最短寻道时间优先（SSTF）调度算法，则系统访问簇的先后次序是什么？     （3）第 100 530 簇在磁盘上的物理地址是什么？将簇号转换成磁盘物理地址的过程是由 I/O 系统的什么程序完成的？ ",
        "answers": {
          "detail": "\n  1）磁盘容量 = 磁盘的柱面数*每个柱面的磁道数*每个磁道的扇区数*每个扇区的大小 = (300×10×200×512/1024) KB = 3×105KB。       2）磁头在 85 号柱面上，对 SSTF 算法而言，总是访问当前柱面距离最近的地址。注意每 个簇包含 2 个扇区，通过计算得到，85 号柱面对应的簇号为 85000～85999。通过比较得出，系 统最先访问离 85000～85999 最近的 100260，随后访问离 100260 最近的 101660，然后访问 110560，最后访问 60005。顺序为 100260、101660、110560、60005。       3）第 100530 簇在磁盘上的物理地址由其所在的柱面号、磁道号、扇区号构成。     柱面号 = [簇号/每个柱面的簇数] = [100530/(10×200/2)] = 100。 (向下取整)    磁道号 = [(簇号%每个柱面的簇数)/每个磁道的簇数] = [530/(200/2)] = 5。 (向下取整)    扇区号 = 扇区地址%每个磁道的扇区数 = (530×2)%200 = 60。     将簇号转换成磁盘物理地址的过程由磁盘驱动程序完成。 \n"
        },
        "review": []
      },
      {
        "id": 45,
        "select": false,
        "detail": "  已知 f (n) = n! * n *(n -1)*(n - 2)*....*2*1 ，计算 f(n)的 C 语言函数 f1 的源程序（阴影部分）及其在 32 位计算机 M 上的部分机器级代码如下：   @https://uploadfiles.nowcoder.com/images/20200926/330906_1601124847826_6308D227095BCCBAC39421448C7CFB33@   @https://uploadfiles.nowcoder.com/images/20200926/330906_1601124861394_87EB1ECB958D0D082AE196AD8B28B11B@       其中，机器级代码行包括行号、虚拟地址、机器指令和汇编指令，计算机 M 按字节编址，int 型数据占 32 位。请回答下列问题：     （1）计算 f(10)需要调用函数 f1 多少次？执行哪条指令会递归调用 f1？     （2）上述代码中，哪条指令是条件转移指令？哪几条指令一定会使程序跳转执行？     （3）根据第 16 行的 call 指令，第 17 行指令的虚拟地址应是多少？已知第 16 行的 call 指令 采用相对寻址方式，该指令中的偏移量应是多少（给出计算过程）？已知第 16 行的 call 指令的 后 4 字节为偏移量，M 是采用大端方式还是采用小端方式？     （4）f(13) = 6227020800，但 f1(13)的返回值为 1932053504，为什么两者不相等？要使 f1(13)能返回正确的结果，应如何修改 f1 的源程序？     （5）第 19 行的 imul 指令（带符号整数乘）的功能是 R[eax]←R[eax]×R[ecx]，当乘法器输 出的高、低 32 位乘积之间满足什么条件时，溢出标志 OF = 1？要使 CPU 在发生溢出时转异常 处理，编译器应在 imul 指令后应加一条什么指令？ ",
        "answers": {
          "detail": "\n  1）计算 f(10)需要调用函数 f1 共 10 次，执行第 16 行的 call 指令会递归调用 f1。        2）第 12 行的 jle 指令是条件转移指令，其含义为小于等于时转移，本行代码的意义为：当 n≤1 时，跳转至地址 0040 1035H。第 16 行的 call 指令为函数调用指令，第 20 行的 jmp 指令为 无条件转移指令，第 30 行的 ret 指令为子程序的返回指令，这三条指令一定会使程序跳转执行。        3）其长度计算机 M 上按字节编址，第 16 行的 call 指令的虚拟地址为 0040 1025H，长度 为 5 字节，故第 17 行的指令的虚拟地址为 0040 1025H + 5 = 0040 102AH。第 16 行的 call 指令 采用相对寻址方式，即目标地址 = (PC) + 偏移量，call 指令的目标地址为 0040 1000H，所以偏 移量=目标地址 - (PC) = 0040 1000H - 0040 102AH = FFFF FFD6H。根据第 16 行的 call 指令的 偏移量字段为 D6 FF FF FF，可以确定 M 采用小端方式。        4）因为 f(13) = 6227020800，其结果超出了 32 位 int 型数据可表示的最大范围，因此 f(13) 的返回值是一个发生了溢出的错误结果。为使 f1(13)能返回正确结果，可将函数 f1 的返回值类 型改为 double（或 long long，或 long double，或 float）类型。        5）若乘积的高 33 位为非全 0 或非全 1，则 OF = 1。编译器应在 imul 指令后加一条“溢出 自陷指令”，使得 CPU 自动查询溢出标志 OF，当 OF = 1 时调出“溢出异常处理程序” \n"
        },
        "review": [
          {
            "detail": "\n其中，机器级代码行包括行号、虚拟地址、机器指令和汇编指令，计算机 M 按字节编址，int 型数据占 32 位。请回答下列问题： \n（1）计算 f(10)需要调用函数 f1 多少次？执行哪条指令会递归调用 f1？\n （2）上述代码中，哪条指令是条件转移指令？哪几条指令一定会使程序跳转执行？ \n（3）根据第 16 行的 call 指令，第 17 行指令的虚拟地址应是多少？\n已知第 16 行的 call 指令 采用相对寻址方式，该指令中的偏移量应是多少（给出计算过程）？\n已知第 16 行的 call 指令的 后 4 字节为偏移量，M 是采用大端方式还是采用小端方式？ \n（4）f(13) = 6227020800，但 f1(13)的返回值为 1932053504，为什么两者不相等？\n\n要使 f1(13)能返回正确的结果，应如何修改 f1 的源程序？ \n（5）第 19 行的 imul 指令（带符号整数乘）的功能是 R[eax]←R[eax]×R[ecx]，当乘法器输 出的高、低 32 位乘积之间满足什么条件时，溢出标志 OF = 1？要使 CPU 在发生溢出时转异常 处理，编译器应在 imul 指令后应加一条什么指令？ \n"
          }
        ]
      },
      {
        "id": 46,
        "select": false,
        "detail": "对于上一题，若计算机 M 的主存地址为 32 位，釆用分页存储管理方式，页大小 为 4KB，则第 1 行的 push 指令和第 30 行的 ret 指令是否在同一页中（说明理由）？若指令 Cache 有 64 行，采用 4 路组相联映射方式，主存块大小为 64B，则 32 位主存地址中，哪几位表示块 内地址？哪几位表示 Cache 组号？哪几位表示标记（tag）信息？读取第 16 行的 call 指令时， 只可能在指令 Cache 的哪一组中命中（说明理由）？",
        "answers": {
          "detail": "\n        ．解答： 因为页大小为 4KB，所以虚拟地址的高 20 位为虚拟页号。第 1 行的 push 指令和第 30 行 的 ret 指令的虚拟地址的高 20 位都是 00401H，因此两条指令在同一页中。 指令 Cache 有 64 块，采用 4 路组相联映射方式，故指令 Cache 共有 64/4 =16 组，Cache 组号共 4 位。主存块大小为 64B，故块内地址为低 6 位。综上所述，在 32 位主存地址中，低 6 位为块内地址，中间 4 位为组号，高 22 位为标记。 因为页大小为 4KB，所以虚拟地址和物理地址的最低 12 位完全相同，因而 call 指令虚拟 地址 0040 1025H 中的 025H = 0000 0010 0101B 为物理地址的低 12 位，对应的 7～10 位为组号， 故对应的 Cache 组号为 0。\n    "
        },
        "review": [
          {
            "detail": "\n对于上一题，若计算机 M 的主存地址为 32 位，\n釆用分页存储管理方式，页大小 为 4KB，\n则第 1 行的 push 指令和第 30 行的 ret 指令是否在同一页中（说明理由）？\n若指令 Cache 有 64 行，\n采用 4 路组相联映射方式，主存块大小为 64B，则 32 位主存地址中，\n哪几位表示块 内地址？\n哪几位表示 Cache 组号？\n哪几位表示标记（tag）信息？\n读取第 16 行的 call 指令时， \n只可能在指令 Cache 的哪一组中命中（说明理由）？ \n"
          }
        ]
      },
      {
        "id": 47,
        "select": false,
        "detail": "  某网络拓扑如图所示，其中 R 为路由器，主机 H1～H4 的 IP 地址配置以及 R 的各接口IP 地址配置如图中所示。现有若干以太网交换机（无 VLAN 功能）和路由器两类网络互连设备可供选择   @https://uploadfiles.nowcoder.com/images/20200926/330906_1601125065023_9EDA953978227987DEB2DC5CEDABF7C6@       请回答下列问题：      （1）设备 1、设备 2 和设备 3 分别应选择什么类型的网络设备？     （2）设备 1、设备 2 和设备 3 中，哪几个设备的接口需要配置 IP 地址？为对应的接口配置 正确的 IP 地址。     （3）为确保主机 H1～H4 能够访问 Internet，R 需要提供什么服务？      （4）若主机 H3 发送一个目的地址为 192.168.1.127 的 IP 数据报，网络中哪几个主机会接收该数据报 ",
        "answers": {
          "detail": "\n  解答：     1）以太网交换机（无 VLAN 功能）连接的若干 LAN 仍然是一个网络（同一个广播域）， 路由器可以连接不同的 LAN、不同的 WAN 或把 WAN 和 LAN 互联起来，隔离了广播域。IP 地址 192.168.1.2/26 与 192.168.1.3/26 的网 络前缀 均为 192.168.1.0，视 为 LAN1。IP 地 址 192.168.1.66/26 与 192.168.1.67/26 的网络前缀均为 192.168.1.64，视为 LAN2。所以设备 1 为路 由器，设备 2、3 为以太网交换机。        2）设备 1 为路由器，其接口应配置 IP 地址。IF1 接口与路由器 R 相连，其相连接口的 IP 地址为 192.168.1.253/30，253 的二进制表示形式为 11111101，故 IF1 接口的网络前缀也应为 192.168.1.111111，已分配 192.168.1.253，去除全 0 全 1，IF1 接口的 IP 地址应为 192.168.1.254。 LAN1 的默认网关为 192.168.1.1，LAN2 的默认网关为 192.168.1.65，网关的 IP 地址是具有路由 功能的设备的 IP 地址，通常默认网关地址就是路由器中的 LAN 端口地址，设备 1 的 IF2、IF3 接口的 IP 地址分别设置为 192.168.1.1 和 192.168.1.65。       3）私有地址段：C 类 192.168.0.0~192.168.255.255，即 H1～H4 均为私有 IP 地址，若要能 够访问 Internet，R 需要提供 NAT 服务，即网络地址转换服务。        4）主机 H3 发送一个目的地址为 192.168.1.127 的 IP 数据报，主机号全为 1，为本网络的 广播地址，由于路由器可以隔离广播域，只有主机 H4 会接收到数据报。 \n"
        },
        "review": [
          {
            "detail": "\n某网络拓扑如图所示，\n其中 R 为路由器，主机 H1～H4 的 IP 地址配置以及 R 的各接口IP 地址配置如图中所示。\n现有若干以太网交换机（无 VLAN 功能）和路由器两类网络互连设备可供选择\n\n\n请回答下列问题： \n\n （1）设备 1、设备 2 和设备 3 分别应选择什么类型的网络设备？\n （2）设备 1、设备 2 和设备 3 中，\n 哪几个设备的接口需要配置 IP 地址？\n 为对应的接口配置 正确的 IP 地址。\n （3）为确保主机 H1～H4 能够访问 Internet，R 需要提供什么服务？ \n （4）若主机 H3 发送一个目的地址为 192.168.1.127 的 IP 数据报，\n 网络中哪几个主机会接收该数据报 \n"
          }
        ]
      }
    ]
  },
  {
    "title": 2018,
    "testDetail": [
      {
        "id": 1,
        "select": true,
        "detail": "若栈S1中保存整数，栈S2中保存运算符，函数F()依次执行下述各步操作： （1）从S1中依次弹出两个操作数a和b； （2）从S2中弹出一个运算符op； （3）执行相应的运算b op a； （4）将运算结果压入S1中。   假定S1中的操作数依次是5,8,3,2（2在栈顶），S2中的运算符依次是*,-,+（+在栈顶）    调用3次F()后，S1栈顶保存的值是    ",
        "answers": {
          "RightAnswer": "B",
          "A": "-15",
          "B": "15",
          "C": "-20",
          "D": "20"
        },
        "review": [
          {
            "detail": "\n  S1第一次 弹出 a,b  即 2,3  S2 弹出 “ +”   操作为 b + a   即 （3 + 2） 压入 S1  现在 S1 为 5 8 5    S1第二次弹出a,b    即 5 ，8   S2弹出\"-\"  操作为 b - a      即（8-5） 压入S1 现在 S1 为  5 3    S1第三次弹出a,b 即 3,5   S2弹出 “*” 操作为 b*a   即  5*3   压入S 现在S1 为 15    所以三次后S1 栈顶为15 \n"
          }
        ]
      },
      {
        "id": 2,
        "select": true,
        "detail": "现有队列Q与栈S，初始时Q中的元素依次是1,2,3,4,5,6（在队头），S为空。若仅允许下列3种操作：①出队并输出出队元素；②出队并将出队元素入栈；③出栈并输出出栈元素，则不能得到的输出序列是",
        "answers": {
          "RightAnswer": "C",
          "A": "1,2,5,6,4,3 ",
          "B": "2,3,4,5,6,1",
          "C": "3,4,5,6,1,2",
          "D": "6,5,4,3,2,1"
        },
        "review": [
          {
            "detail": "\n                                                                    c为何是错的，先将6-3压栈，然后出栈，再将2压栈，1出队，2出栈，这不是可以345612吗\n                                                            "
          }
        ]
      },
      {
        "id": 3,
        "select": true,
        "detail": "设有一个12×12的对称矩阵M，将其上三角部分的元素mi,j（1≤i≤j≤12）按行优先存入C语言的一维数组N中，元素m6,6在N中的下标是",
        "answers": {
          "RightAnswer": "A",
          "A": "50",
          "B": "51",
          "C": "55",
          "D": "56"
        },
        "review": [
          {
            "detail": "\n                                                                    解析“上三角矩阵从第一行开始元素数量依次是：12，11，10，9，8，7，6，5，4，3，2，1，m6,6表示上三角区域的第6行第1个，所以m6,6为第51个元素，占数组位置为a[50]。\n                                                            "
          }
        ]
      },
      {
        "id": 4,
        "select": true,
        "detail": "设一棵非空完全二叉树T的所有叶结点均位于同一层，且每个非叶结点都有 2个子结点。 若 T 有 k 个叶结点，则 T 的结点总数是 ",
        "answers": {
          "RightAnswer": "A",
          "A": "2k - 1",
          "B": "2k",
          "C": "k",
          "D": "2"
        },
        "review": [
          {
            "detail": "\n                                                                    k为n0的结点数,k-1就为n2的结点数,又因为非叶子结点都有两个子节点所以不存在n1的结点数所以n=2k-1\n                                                            "
          }
        ]
      },
      {
        "id": 5,
        "select": true,
        "detail": "已知字符集{a, b, c, d, e, f}，若各字符出现的次数分别为 6, 3, 8, 2, 10, 4，则对应字符集 中各字符的哈夫曼编码可能是",
        "answers": {
          "RightAnswer": "A",
          "A": "00, 1011, 01, 1010, 11, 100",
          "B": "00, 100, 110, 000, 0010, 01",
          "C": "10, 1011, 11, 0011, 00, 010",
          "D": "0011, 10, 11, 0010, 01, 000"
        },
        "review": [
          {
            "detail": "\n                                                                    随便构建一棵哈夫曼树，显然只有b，d位于第四层，所以需要四位(xxxx)表示，并且bd的前三位(XXXx)应相同，而BCD选项中，bd的哈夫曼编码前三不同，所以排除BCD。固选A\n                                                            "
          }
        ]
      },
      {
        "id": 6,
        "select": true,
        "detail": "  已知二叉排序树如下图所示，元素之间应满足的大小关系是   @https://uploadfiles.nowcoder.com/images/20200927/330907_1601191407175_D57E0CD122CAB2794B6E5D48B096FE01@    ",
        "answers": {
          "RightAnswer": "C",
          "A": "x1 < x2 < x5",
          "B": "x1 < x4 < x5",
          "C": "x3 < x5 < x4",
          "D": "x4 < x3 < x5"
        },
        "review": []
      },
      {
        "id": 7,
        "select": true,
        "detail": "  下列选项中，不是如下有向图的拓扑序列的是   @https://uploadfiles.nowcoder.com/images/20200927/330907_1601191452114_9A2CCEA2006E21CA55BEDA0FEA137BFE@ ",
        "answers": {
          "RightAnswer": "D",
          "A": "1, 5, 2, 3, 6, 4",
          "B": "5, 1, 2, 6, 3, 4",
          "C": "5, 1, 2, 3, 6, 4",
          "D": "5, 2, 1, 6, 3, 4"
        },
        "review": []
      },
      {
        "id": 8,
        "select": true,
        "detail": "高度为 5 的 3 阶 B 树含有的关键字个数至少是",
        "answers": {
          "RightAnswer": "B",
          "A": "15",
          "B": "31",
          "C": "62",
          "D": "242"
        },
        "review": [
          {
            "detail": "\n  1）B树通过向上“分裂”结点增加树的高度；    2）B树的所有叶子结点都在同一层上；       因此树深达到5时，最后一次一层是满的，即5层的满二叉树（算叶子结点一层共25-1） \n"
          },
          {
            "detail": "\n                                                                    <p>m=3,除以二后向上取整，得2为分枝数，则每个结点关键字数最少为1，和五层满二叉树一样，2的5次方减1</p><p><br></p>\n                                                            "
          }
        ]
      },
      {
        "id": 9,
        "select": true,
        "detail": "现有长度为 7、初始为空的散列表 HT，散列函数 H(k) = k % 7，用线性探测再散列法解 决冲突。将关键字 22, 43, 15 依次插入到 HT 后，查找成功的平均查找长度是",
        "answers": {
          "RightAnswer": "C",
          "A": "1.5",
          "B": "1.6",
          "C": "2",
          "D": "3"
        },
        "review": [
          {
            "detail": "\n0~6,   @https://www.nowcoder.com/equation?tex=%5Cfrac%7B1%2B2%2B3%7D%7B3%7D%3D2&preview=true@\n"
          }
        ]
      },
      {
        "id": 10,
        "select": true,
        "detail": "对初始数据序列(8, 3, 9, 11, 2, 1, 4, 7, 5, 10, 6)进行希尔排序。若第一趟排序结果为(1, 3, 7, 5, 2, 6, 4, 9, 11, 10, 8)，第二趟排序结果为(1, 2, 6, 4, 3, 7, 5, 8, 11, 10, 9)，则两趟排序采用的增 量（间隔）依次是",
        "answers": {
          "RightAnswer": "D",
          "A": "3, 1",
          "B": "3, 2",
          "C": "5, 2",
          "D": "5, 3"
        },
        "review": [
          {
            "detail": "\n  D 先看第一趟，1从最开始的5号位移动到0号位，说明第一趟步长是5，直接排除A,B    再看第二趟，2从第一趟排序结果的第4位移动到1号位，说明第二趟步长是3 \n"
          },
          {
            "detail": "\nprivate void shellsort(int[] arr) {\n    int index = 0;\n    int value = 0;\n    for(int flag = arr.lenght/2; flag>0; flag /= 2;) {\n        for(int i=flag; i<arr.lenght; i++) {\n            index = i;\n            value = arr[index];\n            if(value < arr[index-flag]) {\n                while(index-flag > 0 && value < arr[index-flag]) {\n                    arr[index] = arr[index-flag];\n                    index = index - flag;\n                }\n                arr[index] = value;\n            }\n        }\n    }\n} \n"
          }
        ]
      },
      {
        "id": 11,
        "select": true,
        "detail": "在将数据序列(6, 1, 5, 9, 8, 4, 7)建成大根堆时，正确的序列变化过程是",
        "answers": {
          "RightAnswer": "A",
          "A": "6, 1, 7, 9, 8, 4, 5 → 6, 9, 7, 1, 8, 4, 5 → 9, 6, 7, 1, 8, 4, 5 → 9, 8, 7, 1, 6, 4, 5",
          "B": "6, 9, 5, 1, 8, 4, 7 → 6, 9, 7, 1, 8, 4, 5 → 9, 6, 7, 1, 8, 4, 5 → 9, 8, 7, 1, 6, 4, 5",
          "C": "6, 9, 5, 1, 8, 4, 7 → 9, 6, 5, 1, 8, 4, 7 → 9, 6, 7, 1, 8, 4, 5 → 9, 8, 7, 1, 6, 4, 5",
          "D": "6, 1, 7, 9, 8, 4, 5 → 7, 1, 6, 9, 8, 4, 5 → 7, 9, 6, 1, 8, 4, 5 → 9, 7, 6, 1, 8, 4, 5 → 9, 8, 6, 1, 7, 4, 5"
        },
        "review": []
      },
      {
        "id": 12,
        "select": true,
        "detail": "  冯·诺依曼结构计算机中数据采用二进制编码表示，其主要原因是    I. 二进制的运算规则简单     II. 制造两个稳态的物理器件较容易     III. 便于用逻辑门电路实现算术运算 ",
        "answers": {
          "RightAnswer": "D",
          "A": "仅 I、II",
          "B": "仅 I、III",
          "C": "仅 II、III",
          "D": "I、II 和 III"
        },
        "review": [
          {
            "detail": "\n                                                                    我觉得是D🤔\n"
          },
          {
            "detail": "\n                                                                    b \n                                                            "
          }
        ]
      },
      {
        "id": 13,
        "select": true,
        "detail": "假定带符号整数采用补码表示，若 int 型变量 x 和 y 的机器数分别是 FFFF FFDFH 和 0000 0041H，则 x、y 的值以及 x - y 的机器数分别是",
        "answers": {
          "RightAnswer": "C",
          "A": "x = -65, y = 41，x - y 的机器数溢出",
          "B": "x = -33, y = 65，x - y 的机器数为 FFFF FF9DH",
          "C": "x = -33, y = 65，x - y 的机器数为 FFFF FF9EH",
          "D": "x = -65, y = 41，x - y 的机器数为 FFFF FF96H"
        },
        "review": [
          {
            "detail": "\n  C    x 补码：1101 1111   原码：1010 0001=-33    y 补码：0100 0001   原码：0100 0001=65    x-y=-98  原码：1110 0010  补码：1001 1110  机器码：FFFF FF9EH \n"
          },
          {
            "detail": "\n                                                                    因为98的十六进制为62,显然只有补码尾数为XXXXX9E的才满足与它的绝对值之和为mod。\n                                                            "
          }
        ]
      },
      {
        "id": 14,
        "select": true,
        "detail": "IEEE 754 单精度浮点格式表示的数中，最小的规格化正数是",
        "answers": {
          "RightAnswer": "A",
          "A": "1.0×2 ",
          "B": "1.0×2 ",
          "C": "1.0×2 ",
          "D": "1.0×2 "
        },
        "review": [
          {
            "detail": "\n在32位浮点数中，符号位占1位，尾数占23位，阶数占8位。在正常情况下，阶数不包括全零和全一的情况，偏置常数是127，因此它的取值范围是-126-127。尾数值等于1+尾数23位表示的小数。https://blog.csdn.net/qq_45737068/article/details/109032826?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_title~default-1.no_search_link&spm=1001.2101.3001.4242.2\n"
          },
          {
            "detail": "\n        类别          正负号          实际指数          有偏移指数          指数域          尾数域          数值            零          0          -127          0          0000 0000          000 0000 0000 0000 0000 0000          0.0            负零          1          -127          0          0000 0000          000 0000 0000 0000 0000 0000          −0.0            1          0          0          127          0111 1111          000 0000 0000 0000 0000 0000          1.0            -1          1          0          127          0111 1111          000 0000 0000 0000 0000 0000          −1.0            最小的非规约数          *          -126          0          0000 0000          000 0000 0000 0000 0000 0001          ±2−23 × 2−126 = ±2−149 ≈ ±1.4×10-45         中间大小的非规约数          *          -126          0          0000 0000          100 0000 0000 0000 0000 0000          ±2−1 × 2−126 = ±2−127 ≈ ±5.88×10-39         最大的非规约数          *          -126          0          0000 0000          111 1111 1111 1111 1111 1111          ±(1−2−23) × 2−126 ≈ ±1.18×10-38         最小的规约数          *          -126          1          0000 0001          000 0000 0000 0000 0000 0000          ±2−126 ≈ ±1.18×10-38         最大的规约数          *          127          254          1111 1110          111 1111 1111 1111 1111 1111          ±(2−2−23) × 2127 ≈ ±3.4×1038         正无穷          0          128          255          1111 1111          000 0000 0000 0000 0000 0000          +∞            负无穷          1          128          255          1111 1111          000 0000 0000 0000 0000 0000          −∞        NaN       *          128          255          1111 1111          非全0          NaN            * 符号位可以为0或1 .       \n"
          }
        ]
      },
      {
        "id": 15,
        "select": true,
        "detail": "某 32 位计算机按字节编址，采用小端（Little Endian）方式。若语句“int i = 0;”对应 指令的机器代码为“C7 45 FC 00 00 00 00”，则语句“int i = −64;”对应指令的机器代码是",
        "answers": {
          "RightAnswer": "A",
          "A": "C7 45 FC C0 FF FF FF",
          "B": "C7 45 FC 0C FF FF FF",
          "C": "C7 45 FC FF FF FF C0",
          "D": "C7 45 FC FF FF FF 0C"
        },
        "review": [
          {
            "detail": "\n小端方式是指数据的高字节保存在内存的高地址中，而数据的低字节保存在内存的低地址中。– 64的补码为FF FF FF CO，按照小端方式,存储顺序依次为CO FF FF FF，因此,int x=-64对应的机器指令代码为:C7 45 FC CO FF FF FF\n"
          }
        ]
      },
      {
        "id": 16,
        "select": true,
        "detail": "整数 x 的机器数为 1101 1000，分别对 x 进行逻辑右移 1 位和算术右移 1 位操作，得到的机器数分别是",
        "answers": {
          "RightAnswer": "B",
          "A": "1110 1100，1110 1100",
          "B": "0110 1100，1110 1100",
          "C": "1110 1100，0110 1100",
          "D": "0110 1100，0110 1100"
        },
        "review": [
          {
            "detail": "\n  B    算数右移：指的是将原来的数向右移X位，前面补符号位    逻辑右移：指的是不考虑符号位，左边直接补0      逻辑右移：0110 1100      算术右移：1110 1100    \n"
          },
          {
            "detail": "\n  算数右移：指的是将原来的数向右移X位，前面补符号位    逻辑右移：指的是不考虑符号位，左边直接补0 \n"
          }
        ]
      },
      {
        "id": 17,
        "select": true,
        "detail": "假定 DRAM 芯片中存储阵列的行数为 r、列数为 c，对于一个 2K×1 位的 DRAM 芯片， 为保证其地址引脚数最少，并尽量减小刷新开销，则 r、c 的取值分别是",
        "answers": {
          "RightAnswer": "C",
          "A": "2048、1",
          "B": "64、32",
          "C": "32、64",
          "D": "1、2048"
        },
        "review": [
          {
            "detail": "\n                                                                    【解析】根据 DRAM的结构和原理可知，在分时复用的情况下，芯片引脚个数取决于行地址线和列地址线中的较大值，对于一个2K×1位的DRAM芯片，总共需要11条地址线，只有当一个取5，一个取6时可使管脚数最小，而DRAM的刷新开销取决于行数，因此行地址线应该为5、列地址线为6，即行数2^5=32，列数为2^6=64。\n"
          }
        ]
      },
      {
        "id": 18,
        "select": true,
        "detail": "按字节编址的计算机中，某 double 型数组 A 的首地址为 2000H，使用变址寻址和循环 结构访问数组 A，保存数组下标的变址寄存器初值为 0，每次循环取一个数组元素，其偏移地 址为变址值乘以 sizeof(double)，取完后变址寄存器内容自动加 1。若某次循环所取元素的地址 为 2100H，则进入该次循环时变址寄存器的内容是",
        "answers": {
          "RightAnswer": "B",
          "A": "25",
          "B": "32",
          "C": "64",
          "D": "100"
        },
        "review": [
          {
            "detail": "\n  2100H - 2000H =  2^8    double 为64为 8B = 2^3    2^8/2^3 = 2^5 = 32 \n"
          }
        ]
      },
      {
        "id": 19,
        "select": true,
        "detail": "减法指令“sub R1, R2, R3”的功能为“(R1) - (R2)→R3”，该指令执行后将生成进位/ 借位标志 CF 和溢出标志 OF。若(R1) = FFFF FFFFH，(R2) = FFFF FFF0H，则该减法指令执行 后，CF 与 OF 分别为",
        "answers": {
          "RightAnswer": "A",
          "A": "CF = 0, OF = 0",
          "B": "CF = 1, OF = 0",
          "C": "CF = 0, OF = 1",
          "D": "CF = 1, OF = 1"
        },
        "review": [
          {
            "detail": "\n  选 A      OF（Overflow Flag)溢出标志。溢出时为1,否则置0。       SF（Sign Flag）符号标志。结果为负时置1,否则置0.       ZF（Zero Flag)零标志，运算结果为0时ZF位置1,否则置0.       CF（Carry Flag)进位/借位标志，进位/借位时置1,否则置0.         其中：               OF 为最高位产生的进位与次高位产生的进位的异或结果；              CF 为最高位产生的进位与运算符号的异或结果（运算符号+为0,-为1）   (R1) （补）：FFFF FFFFH     +   (-R2) （补）： 0000 0010H    =    (R3)  = 10000 000FH,最高位产生的进位为1，次高位的进位为1,所以OF 为 0；符号运算符为1，CF为0；    选 A    另外： R1 = -1 ，R2 = -16 显然：R1 - R2 = 15 显然对32位补码不会产生溢出OF为0。对于减法判断有没有借位（加法判断有无进位）R1 - R2 是属于 大 - 小 因此不会产生借位，CF为0。             \n"
          }
        ]
      },
      {
        "id": 20,
        "select": true,
        "detail": "若某计算机最复杂指令的执行需要完成 5 个子功能，分别由功能部件 A～E 实现，各 功能部件所需时间分别为 80ps、50ps、50ps、70ps 和 50ps，采用流水线方式执行指令，流水段 寄存器延时为 20ps，则 CPU 时钟周期至少为",
        "answers": {
          "RightAnswer": "D",
          "A": "60ps",
          "B": "70ps",
          "C": "80ps",
          "D": "100ps"
        },
        "review": [
          {
            "detail": "\n                                                                    D,取最长的一段80ps+寄存器延时20\n                                                            "
          }
        ]
      },
      {
        "id": 21,
        "select": true,
        "detail": "  下列选项中，可提高同步总线数据传输率的是    I. 增加总线宽度     II. 提高总线工作频率     III. 支持突发传输     IV. 采用地址/数据线复用 ",
        "answers": {
          "RightAnswer": "B",
          "A": "仅 I、II",
          "B": "仅 I、II、III",
          "C": "仅 III、IV",
          "D": "I、II、III 和 IV"
        },
        "review": [
          {
            "detail": "\n  I II 都很明显，肯定增加的    III 突发传输一般表示的是两个设备之间进行数据传送的一种模式，也可将其称为突发模式下的数据传输。而突发（Burst）是指在同一行中相邻的存储单元连续进行数据传输的方式，连续传输的周期数就是突发长度（Burst Lengths，简称BL）。在突发传输模式下，多个数据单元当做一个单元（相当一个数据块）来传送，从而提高了传输效率。   IV 地址数据线复用并非提高而是降低，毕竟同一时间你还得传地址过去，等价的数据传输效率就低了。 \n"
          }
        ]
      },
      {
        "id": 22,
        "select": true,
        "detail": "下列关于外部 I/O 中断的叙述中，正确的是",
        "answers": {
          "RightAnswer": "C",
          "A": "中断控制器按所接收中断请求的先后次序进行中断优先级排队",
          "B": "CPU 响应中断时，通过执行中断隐指令完成通用寄存器的保护",
          "C": "CPU 只有在处于中断允许状态时，才能响应外部设备的中断请求",
          "D": "有中断请求时，CPU 立即暂停当前指令执行，转去执行中断服务程序"
        },
        "review": [
          {
            "detail": "\n   I. 中断源向CPU表达中断请求，一般是设置中断请求触发器，在需要CPU服务时，将中断请求触发器置位，其1端或0端输出的跳变作为中断请求信号。显然中断源可以随时提出中断请求。     II. 一个中断请求在同时具备下列两个条件时，才有可能得到CPU响应： ①该中断源未被屏蔽；   ②该中断请求在当前所有中断请求中级别最高。    显然A中关于先后次序是错误的。   III. CPU在同时满足下列两个条件时，响应中断： ①IF=1(对非屏蔽中断，没有此项要求)； ②现行指令执行完。      IV. 中断隐指令      ①保存断点        为了保证在中断服务程序执行完毕能正确返回原来的程序，必须将原来程序的断点（即程序计数器(PC)的内容）保存起来。断点可以压入堆栈，也可以存入主存的特定单元中。     ②暂不允许中断        暂不允许中断即关中断。在中断服务程序中，为了保护中断现场（即CPU主要寄存器的内容）期间不被新的中断所打断，必须要关中断，从而保证被中断的程序在中断服务程序执行完毕之后能接着正确地执行下去。        并不是所有的计算机都在中断隐指令中由硬件自动地关中断，也有些计算机的这一操作是由软件（中断服务程序）来实现的。        ③引出中断服务程序           B中终端隐指令能做的关中断、保存断点和中断服务程序寻址，后面的保存现场和屏蔽字、开中断、执行中断服务程序、关中断、恢复现场和屏蔽字、开中断、中断返回应该是由中断服务程序执行的。       D中再中断也得把当前指令执行结束才行。    \n"
          }
        ]
      },
      {
        "id": 23,
        "select": true,
        "detail": "  下列关于多任务操作系统的叙述，正确的是    I. 具有并发和并行的特点     II. 需要实现对共享资源的保护     III. 需要运行在多 CPU 的硬件平台上 ",
        "answers": {
          "RightAnswer": "C",
          "A": "仅 I",
          "B": "仅 II",
          "C": "仅 I、II",
          "D": "I、II、II"
        },
        "review": [
          {
            "detail": "\n                                                                    为什么不用多CPU也可以实现并行？？\n                                                            "
          },
          {
            "detail": "\n                                                                    我也认为答案1的并行有疑问\n                                                            "
          },
          {
            "detail": "\n                                                                    多任务也没说同时运行多个进程啊，并行为什么要选？\n                                                            "
          }
        ]
      },
      {
        "id": 24,
        "select": true,
        "detail": "  某系统采用基于优先权的非抢占式进程调度策略，完成一次进程调度和进程切换的系 统时间开销为 1µs。在 T 时刻就绪队列中有 3 个进程 P1、P2和 P3，其在就绪队列中的等待时间、 需要的 CPU 时间和优先权如下表所示   @https://uploadfiles.nowcoder.com/images/20200927/330907_1601193089259_4DD38979681455A854436D1817FAD96C@       若优先权值大的进程优先获得 CPU，从 T 时刻起系统开始进程调度，系统的平均周转时间为  ",
        "answers": {
          "RightAnswer": "D",
          "A": "54µs",
          "B": "73µs",
          "C": "74µs",
          "D": "75µs"
        },
        "review": [
          {
            "detail": "\n  由优先权可知，p2-p3-p1，其中p2周转为1+15+24=40，p3为18+1+24+1+36=80，p1为30+1+24+1+36+1+12=105，所以（40+80+105）/3=75，选D    详解：    由题目我们可以知道，调度到进程需要1，而一开始三个进程已经全部在队列中    于是p2的周转时间就是队列等待15，然后调度1，cpu运行的24    接下来是p3，其已经在队列中18，此时正在运行p2进程的调度1和cpu运行的24，所以等p2的调度和cpu运行后才到自己，此时自己的调度需要1，cpu运行需要36    最后是p1，和p3的运行一样，需要等待p2和p3的运行，则需要把p2、p3的调度和cpu时间累加再加上自己的调度和cpu时间 \n"
          }
        ]
      },
      {
        "id": 25,
        "select": true,
        "detail": "  属于同一进程的两个线程 thread1 和 thread2 并发执行，共享初值为 0 的全局变量 x。 thread1 和 thread2 实现对全局变量 x 加 1 的机器级代码描述如下   @https://uploadfiles.nowcoder.com/images/20200927/330907_1601193507371_ED8CA589F03C3BF5C9AA8B2638EDA1DC@    在所有可能的指令执行序列中，使 x 的值为 2 的序列个数是 ",
        "answers": {
          "RightAnswer": "B",
          "A": "1",
          "B": "2",
          "C": "3",
          "D": "4"
        },
        "review": [
          {
            "detail": "\n                                                                    就2种，一种线程1做完再做2，一种做完2再做1，反正得等到写回后再取才行。\n                                                            "
          }
        ]
      },
      {
        "id": 26,
        "select": true,
        "detail": "假设系统中有 4 个同类资源，进程 P1, P2 和 P3需要的资源数分别为 4, 3 和 1，P1, P2 和 P3已申请到的资源数分别为 2, 1 和 0，则执行安全性检测算法的结果是",
        "answers": {
          "RightAnswer": "A",
          "A": "不存在安全序列，系统处于不安全状态",
          "B": "存在多个安全序列，系统处于安全状态",
          "C": "存在唯一安全序列 P3, P1, P2，系统处于安全状态",
          "D": "存在唯一安全序列 P3, P2, P1，系统处于安全状态"
        },
        "review": [
          {
            "detail": "\n                                                                    剩余1个资源，分配给P3。P3运行结束后释放1个资源，此时P2 P1仍然无法获得需要的资源数，发生死锁\n                                                            "
          }
        ]
      },
      {
        "id": 27,
        "select": true,
        "detail": "  下列选项中，可能导致当前进程 P 阻塞的事件是    I. 进程 P 申请临界资源     II. 进程 P 从磁盘读数据     III. 系统将 CPU 分配给高优先权的进程 ",
        "answers": {
          "RightAnswer": "C",
          "A": "仅 I",
          "B": "仅 II",
          "C": "仅 I、II",
          "D": "I、II、III"
        },
        "review": [
          {
            "detail": "\n正确答案：C  读取资源：运行态变成阻塞态 系统将 CPU 分配给高优先权的进程：运行态变成就绪态 \n"
          },
          {
            "detail": "\n                                                                    抢占后是回到就绪队列。\n                                                            "
          }
        ]
      },
      {
        "id": 28,
        "select": true,
        "detail": "若 x 是管程内的条件变量，则当进程执行 x.wait()时所做的工作是",
        "answers": {
          "RightAnswer": "D",
          "A": "实现对变量 x 的互斥访问",
          "B": "唤醒一个在 x 上阻塞的进程",
          "C": "根据 x 的值判断该进程是否进入阻塞状态",
          "D": "阻塞该进程，并将之插入 x 的阻塞队列中"
        },
        "review": [
          {
            "detail": "\n 管程是操作系统的资源管理模块，由代表共享资源的数据结构以及对该共享数据结构实施操作的一组过程所组成。       我们看到管程的组成：       ① 名称      ② 共享数据结构说明      ③ 对该数据结构进行操作的一组过程      ④ 数据初始化代码         而要实现进程互斥      ①同一管程内的过程仅能访问同一管程内的数据结构，同样，同一管程内的数据结构也只能被同一管程内的过程访问。（也就是完全封闭的） ②每次只允许一个进程进入管程，执行管程内的过程（操作管程内的临界资源），从而实现了进程互斥。 ③管程类型提供了一组由程序员定义的、在管程内互斥的操作，确保一次只有一个进程在管程内活动。 ④进程通过管程请求临界资源未满足时，管程将其加入等待队列。         这时，我们的条件x就出来了，一个wait，一个singal。      ①该进程需要被挂起或阻塞时，则调用 x.wait; 将自己插入 x 条件变量的等待队列中，并释放管程，直到 x 条件变化。     ②调用 x.signal，重新启动一个因 x 条件而被阻塞或挂起的进程；如果 x 的等待队列是空的，则继续执行原进程，    \n"
          }
        ]
      },
      {
        "id": 29,
        "select": true,
        "detail": "  当定时器产生时钟中断后，由时钟中断服务程序更新的部分内容是    I. 内核中时钟变量的值     II. 当前进程占用 CPU 的时间     III. 当前进程在时间片内的剩余执行时间 ",
        "answers": {
          "RightAnswer": "D",
          "A": "仅 I、II",
          "B": "仅 II、III",
          "C": "仅 I、III",
          "D": "I、II、III"
        },
        "review": [
          {
            "detail": "\n                                                                    I.内核中时钟变量初值为0，每发生一次时钟中断，时钟中断服务程序都会增加时钟变量的值。 II.和III.发生时钟中断时，时钟中断服务器会维持当前进程占用CPU时间和剩余时间不变。\n                                                            "
          }
        ]
      },
      {
        "id": 30,
        "select": true,
        "detail": "系统总是访问磁盘的某个磁道而不响应对其他磁道的访问请求，这种现象称为磁臂黏着。下列磁盘调度算法中，不会导致磁臂黏着的是",
        "answers": {
          "RightAnswer": "A",
          "A": "先来先服务（FCFS）",
          "B": "最短寻道时间优先（SSTF）",
          "C": "扫描算法（SCAN）",
          "D": "循环扫描算法（CSCAN）"
        },
        "review": [
          {
            "detail": "\n  如果短时间内有如下请求：100 5 100 100 100 20 100，采用BCD都会短时间内在100磁道长时间停留访问，而先来先服务则不存在这个问题，严格按照先后顺序执行，和哪一个磁道无关。    故不选B、C、D。 \n"
          }
        ]
      },
      {
        "id": 31,
        "select": true,
        "detail": "  下列优化方法中，可以提高文件访问速度的是    I. 提前读     II. 为文件分配连续的簇     III. 延迟写     IV. 采用磁盘高速缓存 ",
        "answers": {
          "RightAnswer": "D",
          "A": "仅 I、II",
          "B": "仅 II、III",
          "C": "仅 I、III、IV",
          "D": "I、II、III、IV"
        },
        "review": []
      },
      {
        "id": 32,
        "select": true,
        "detail": "下列同步机制中，可以实现让权等待的是",
        "answers": {
          "RightAnswer": "C",
          "A": "Peterson 方法",
          "B": "swap 指令",
          "C": "信号量方法",
          "D": "TestAndSet指令"
        },
        "review": [
          {
            "detail": "\n    死等状态：操作系统中的处理进程同步时遇到的一种问题。 进程在有限时间内根本不能进入临界区，而一直在尝试进入，陷入一种无结果的等待状态。 （没有进入临界区的正在等待的某进程根本无法获得临界资源而进入进程，这种等待是无结果的，是死等状态。）-》这个时候应该放弃这个无结果的事情，保证自己等待的时间是有限的      忙等状态：操作系统中的处理进程同步时遇到的一种问题。 当一个进程正处在某临界区内，任何试图进入其临界区的进程都必须进入代码连续循环，陷入忙等状态。连续测试一个变量直到某个值出现为止，称为忙等。 （没有进入临界区的正在等待的某进程不断的在测试循环代码段中的变量的值，占着处理机而不释放，这是一种忙等状态。）-》这个时候应该释放处理机让给其他进程      有限等待：对要求访问临界资源的进程，应保证有限时间内能进入自己的临界区。以免陷入“死等”状态。（受惠的是进程自己）。      让权等待：当进程不能进入自己的临界区时，应立即释放处理机，以免进程陷入“忙等”状态。（受惠的是其他进程）。         很明显，信号量能让自己进入阻塞状态，从而释放处理机。     \n"
          }
        ]
      },
      {
        "id": 33,
        "select": true,
        "detail": "下列 TCP/IP 应用层协议中，可以使用传输层无连接服务的是",
        "answers": {
          "RightAnswer": "B",
          "A": "FTP",
          "B": "DNS",
          "C": "SMTP",
          "D": "HTTP"
        },
        "review": [
          {
            "detail": "\n                                                                    FTP HTTP SMTP 使用TCP DNS 使用UDP\n                                                            "
          }
        ]
      },
      {
        "id": 34,
        "select": true,
        "detail": "下列选项中，不属于物理层接口规范定义范畴的是",
        "answers": {
          "RightAnswer": "C",
          "A": "接口形状",
          "B": "引脚功能",
          "C": "物理地址",
          "D": "信号电平"
        },
        "review": [
          {
            "detail": "\n  （1）机械特性：指明接口所用接线器的形状和尺寸、引脚数目和排列、固定和锁定装置等。平时常见的各种规格的接插件都有严格的标准化的规定。    （2）电气特性：指明在接口电缆的各条线上出现的电压的范围。    （3）功能特性：指明某条线上出现的某一电平的电压的意义。    （4）过程特性（规程特性）：指明对于不同功能的各种可能事件的出现顺序。 \n"
          }
        ]
      },
      {
        "id": 35,
        "select": true,
        "detail": "IEEE 802.11 无线局域网的 MAC 协议 CSMA/CA 进行信道预约的方法是",
        "answers": {
          "RightAnswer": "D",
          "A": "发送确认帧",
          "B": "采用二进制指数退避",
          "C": "使用多个 MAC 地址",
          "D": "交换 RTS 与 CTS 帧"
        },
        "review": [
          {
            "detail": "\n  二进制指数退避 是 CSMA/CD   交换 RTS 与 CTS 帧 是 CSMA/CA      为了更好地解决隐蔽站带来的碰撞问题，802.11允许要发送数据的站对信道进行预约。具体的做法是这样的。A在向B发送数据帧之前，先发送一个短的控制帧，叫做请求发送****RTS(Request To Send)，它包括源地址、目的地址和这次通信（包括相应的确认帧）所需的持续时间。当然，A在发送RTS帧之前，必须先监听信道。若信道空闲，则等待一段时间DIFS后，才能够发送RTS帧。若B正确收到A发来的RTS帧，且媒体空闲，则等待一段时间SIFS后，就向A发送一个叫做允许发送****CTS(Clear To Send)的控制帧，它也包括这次通信所需的持续时间。A收到CTS帧后，再等待一段时间SIFS后，就可发送数据帧。若B正确收到了A发来的数据帧，在等待时间SIFS后，就向A发送确认帧ACK。      因此，选项D正确。       \n"
          }
        ]
      },
      {
        "id": 36,
        "select": true,
        "detail": "主机甲采用停-等协议向主机乙发送数据，数据传输速率是 3kbps，单向传播延时是 200ms，忽略确认帧的传输延时。当信道利用率等于 40%时，数据帧的长度为",
        "answers": {
          "RightAnswer": "D",
          "A": "240 比特",
          "B": "400 比特",
          "C": "480 比特",
          "D": "800 比特"
        },
        "review": [
          {
            "detail": "\nhttps://www.bilibili.com/read/cv2357668\n"
          },
          {
            "detail": "\n  发送延时占总的时间为40%，即占传播延时的2倍的4/6，能算200*2*2/3=800/3 ms。    传输的数据帧长为：800/3ms*3kbps=800bit. \n"
          }
        ]
      },
      {
        "id": 37,
        "select": true,
        "detail": "  路由器 R 通过以太网交换机 S1 和 S2 连接两个网络，R 的接口、主机 H1 和 H2 的 IP 地址与 MAC 地址如下图所示。若 H1 向 H2 发送 1 个 IP 分组 P，则 H1 发出的封装 P 的以太网 帧的目的 MAC 地址、H2 收到的封装 P 的以太网帧的源 MAC 地址分别是   @https://uploadfiles.nowcoder.com/images/20200927/330907_1601194688467_EA2423F463BB241120BCB36B71D993A8@       ",
        "answers": {
          "RightAnswer": "D",
          "A": "00-a1-b2-c3-d4-62, 00-1a-2b-3c-4d-52",
          "B": "00-a1-b2-c3-d4-62, 00-a1-b2-c3-d4-61",
          "C": "00-1a-2b-3c-4d-51, 00-1a-2b-3c-4d-52",
          "D": "00-1a-2b-3c-4d-51, 00-a1-b2-c3-d4-61"
        },
        "review": [
          {
            "detail": "\n 以太网帧在传输过程中有关其内部MAC地址和IP地址的变化情况：   - 源IP地址和目的IP地址不会产生变化；   - 源MAC地址和目的MAC地址逐网络（或逐链路）都发生变化。 \n"
          }
        ]
      },
      {
        "id": 38,
        "select": true,
        "detail": "某路由表中有转发接口相同的 4 条路由表项，其目的网络地址分别为 35.230.32.0/21, 35.230.40.0/21, 35.230.48.0/21 和 35.230.56.0/21，将该 4 条路由聚合后的目的网络地址为",
        "answers": {
          "RightAnswer": "C",
          "A": "35.230.0.0/19",
          "B": "35.230.0.0/20",
          "C": "35.230.32.0/19",
          "D": "35.230.32.0/20"
        },
        "review": [
          {
            "detail": "\n  图片有点潦草：   @https://uploadfiles.nowcoder.com/images/20201127/207575826_1606453323798/B3FD97B311F497929E12BBC521D30C98@ \n"
          },
          {
            "detail": "\n @https://uploadfiles.nowcoder.com/images/20220317/291972796_1647500465308/CE1F42D34667518EA32AE6DEF1569F50@    来自 https://blog.csdn.net/weixin_44737877/article/details/103949302 \n"
          }
        ]
      },
      {
        "id": 39,
        "select": true,
        "detail": "UDP 协议实现分用（demultiplexing）时所依据的头部字段是",
        "answers": {
          "RightAnswer": "B",
          "A": "源端口号",
          "B": "目的端口号",
          "C": "长度",
          "D": "校验和"
        },
        "review": [
          {
            "detail": "\n需要明确几个概念:  复用: 多个用户使用一个 IO 发送消息. 分用: 一个 IO 收到的消息被分发给多个用户.  参考 《计算机网络》知识总结-3.复用和分用 - liangdu_Zuker （CSDN）\n"
          },
          {
            "detail": "\n  B     源端口号是在需要对方回信的时候才使用，A错。    目的端口号在终点交付报文的时候使用，B对。    长度和校验和根本就不符合分用的定义，故直接排除。    传输层分用的定义：接收方的传输层剥去报文首部后，能把这些数据正确交付到目的进程。 \n"
          }
        ]
      },
      {
        "id": 40,
        "select": true,
        "detail": "无须转换即可由 SMTP 协议直接传输的内容是",
        "answers": {
          "RightAnswer": "D",
          "A": "JPEG 图像",
          "B": "MPEG 视频",
          "C": "EXE 文件",
          "D": "ASCII 文本"
        },
        "review": [
          {
            "detail": "\n                                                                    只有ASCII才行。\n                                                            "
          }
        ]
      },
      {
        "id": 41,
        "select": false,
        "detail": "  给定一个含 n（n≥1）个整数的数组，请设计一个在时间上尽可能高效的算 法，找出数组中未出现的最小正整数。例如，数组{-5, 3, 2, 3}中未出现的最小正整数是 1；数组{1, 2, 3}中未出现的最小正整数是 4。要求：    （1）给出算法的基本设计思想。     （2）根据设计思想，采用 C 或 C++语言描述算法，关键之处给出注释。     （3）说明你所设计算法的时间复杂度和空间复杂度。 ",
        "answers": {
          "detail": "\n          1）题目要求算法时间上尽可能高效，因此采用空间换时间的办法。分配一个用于标记的 数组 B[n]，用来记录 A 中是否出现了 1～n 中的正整数，B[0]对应正整数 1，B[n-1]对应正整数 n，初始化 B 中全部为 0。由于 A 中含有 n 个整数，因此可能返回的值是 1～n + 1，当 A 中 n 个数恰好为 1～n 时返回 n + 1。当数组 A 中出现了小于等于 0 或大于 n 的值时，会导致 1～n 中出现空余位置，返回结果必然在 1～n 中，因此对于 A 中出现了小于等于 0 或大于 n 的值可 以不采取任何操作。         经过以上分析可以得出算法流程：从 A[0]开始遍历 A，若 0 < A[i] <= n，则令 B[A[i]-1] = 1； 否则不进行操作。对 A 遍历结束后，开始遍历数组 B，若能查找到第一个满足 B[i] == 0 的下标 i，返回 i + 1 即为结果，此时说明 A 中未出现的最小正整数在 1～n 之间。若 B[i]全部不为 0， 返回 i + 1（跳出循环时 i = n，i + 1 等于 n + 1），此时说明 A 中未出现的最小正整数是 n + 1     int findMissMin(int A[], int n)\n{\n    int i, *B;                          //标记数组\n    B = (int *)malloc(sizeof(int) * n); //分配空间\n    memset(B, 0, sizeof(int) * n);      //赋初值为 0\n    for (i = 0; i < n; i++)\n        if (A[i] > 0 && A[i] <= n) //若 A[i]的值介于 1～n，则标记数组 B\n            B[A[i] - 1] = 1;\n    for (i = 0; i < n; i++) //扫描数组 B，找到目标值\n        if (B[i] == 0)\n            break;\n    return i + 1; //返回结果\n}\n   2）时间复杂度：遍历 A 一次，遍历 B 一次，两次循环内操作步骤为 O(1)量级，因此时间 复杂度为 O(n)。空间复杂度：额外分配了 B[n]，空间复杂度为 O(n)。 \n"
        },
        "review": [
          {
            "detail": "\nint min_elem(int A[],n)\n{\n    int *s=new int [n+1];\n    for(int i=0;i<n+1;i++)\n    {\n         s[i]=0;\n    }\n    for(i=0;i<n;i++)\n    {\n        if(A[i]>0&&A[i]<n+1)s[A[i]-1]=1;\n    }\n    for(i=0;i<n;i++)\n    {\n        if(s[i]==0)return i+1;\n    }\n    return n+1;\n} \n"
          }
        ]
      },
      {
        "id": 42,
        "select": false,
        "detail": "  拟建设一个光通信骨干网络连通 BJ、CS、XA、QD、JN、NJ、TL 和 WH 8 个城市，题 42 图中无向边上的权值表示两个城市间备选光纤的铺设费用。   @https://uploadfiles.nowcoder.com/images/20200927/330907_1601195130622_4D7D6C3F78F1F994B587680EB5111A83@       请回答下列问题。     （1）仅从铺设费用角度出发，给出所有可能的最经济的光纤铺设方案（用带权图表示）， 并计算相应方案的总费用。     （2）题 42 图可采用图的哪种存储结构？给出求解问题（1）所使用的算法名称。     （3）假设每个城市采用一个路由器按（1）中得到的最经济方案组网，主机 H1 直接连接在 TL 的路由器上，主机 H2 直接连接在 BJ 的路由器上。若 H1 向 H2 发送一个 TTL = 5 的 IP 分组， 则 H2 是否可以收到该 IP 分组？ ",
        "answers": {
          "detail": "\n  1）为了求解最经济的方案，可以把问题抽象为求无向带权图的最小生成树。可以采用手 动 Prim 算法或 Kruskal 算法作图。注意本题最小生成树有两种构造，如下图所示。      @https://uploadfiles.nowcoder.com/images/20200927/330907_1601195195457_B09EC1A6F3704ADF2297BDBE8CD16510@          方案的总费用为 16。       2）存储题中的图可以采用邻接矩阵（或邻接表）。构造最小生成树采用 Prim 算法（或 Kruskal 算法）。       3）TTL = 5，即 IP 分组的生存时间（最大传递距离）为 5，方案 1 中 TL 和 BJ 的距离过远， TTL = 5 不足以让 IP 分组从 H1 传送到 H2，因此 H2 不能收到 IP 分组。而方案 2 中 TL 和 BJ 邻近，H2 可以收到 IP 分组。 \n"
        },
        "review": []
      },
      {
        "id": 43,
        "select": false,
        "detail": "  假定计算机的主频为 500MHz，CPI 为 4。现有设备 A 和 B，其数据传输速率 分别为 2MB/s 和 40MB/s，对应 I/O 接口中各有一个 32 位数据缓冲寄存器。请回答下列问题， 要求给出计算过程。     （1）若设备 A 采用定时查询 I/O 方式，每次输入/输出都至少执行 10 条指令。设备 A 最多 间隔多长时间查询一次才能不丢失数据？CPU 用于设备 A 输入/输出的时间占 CPU 总时间的百 分比至少是多少？     （2）在中断 I/O 方式下，若每次中断响应和中断处理的总时钟周期数至少为 400，则设备 B 能否采用中断 I/O 方式？为什么？     （3）若设备 B 采用 DMA 方式，每次 DMA 传送的数据块大小为 1000B，CPU 用于 DMA 预处理和后处理的总时钟周期数为 500，则 CPU 用于设备 B 输入/输出的时间占 CPU 总时间的 百分比最大是多少？ ",
        "answers": {
          "detail": "\n  解答：     1）程序定时向缓存端口查询数据，由于缓存端口大小有限，必须在传输完端口大小的数 据时访问端口，以防止部分数据未被及时读取而丢失。设备 A 准备 32 位数据所用的时间为 4B/2MB = 2μs，所以最多每隔 2μs 必须查询一次，每秒的查询次数至少是 1s/2μs = 5×10 5，每秒 CPU 用于设备 A 输入/输出的时间至少为 5×10 5×10×4 = 2×10 7 个时钟周期，占整个 CPU 时间的 百分比至少是 2×10 7 /500M = 4%。        2）中断响应和中断处理的时间为 400×(1/500M) = 0.8μs，这时只需判断设备 B 准备 32 位 数据要多久，如果准备数据的时间小于中断响应和中断处理的时间，那么数据就会被刷新，造 成丢失。经过计算，设备 B 准备 32 位数据所用的时间为 4B/40MB = 0.1μs，因此设备 B 不适合 采用中断 I/O 方式。        3）在 DMA 方式中，只有预处理和后处理需要 CPU 处理，数据的传送过程是由 DMA 控 制的。设备 B 每秒的 DMA 次数最多为 40MB/1000B = 40000，CPU 用于设备 B 输入/输出的时 间最多为 40000×500 = 2×10 7 个时钟周期，占 CPU 总时间的百分比最大为 2×10 7 /500M = 4%。 \n"
        },
        "review": []
      },
      {
        "id": 44,
        "select": false,
        "detail": "  某计算机采用页式虚拟存储管理方式，按字节编址。CPU 进行存储访问的过 程如题 44 图所示。 根据题 44 图回答下列问题。     （1）主存物理地址占多少位?     （2）TLB 采用什么映射方式？TLB 是用 SRAM 还是用 DRAM 实现？     （3）Cache 采用什么映射方式？若 Cache 采用 LRU 替换算法和回写（Write Back）策略， 则 Cache 每行中除数据（Data）、Tag 和有效位，还应有哪些附加位？Cache 的总容量是多少？ Cache 中有效位的作用是什么？     （4）若 CPU 给出的虚拟地址为 0008 C040H，则对应的物理地址是多少？是否在 Cache 中 命中？说明理由。若 CPU 给出的虚拟地址为 0007 C260H，则该地址所在主存块映射到的 Cache 组号是多少？      @https://uploadfiles.nowcoder.com/images/20200927/330907_1601195936641_D349864CE13B00C3CFDB21F941C0F513@ ",
        "answers": {
          "detail": "\n  解答：     1）物理地址由实页号和页内地址拼接，因此其位数为 16 + 12 = 28 或直接可得 20 + 3 + 5 = 28。        2）TLB 采用全相联映射，可以把页表内容调入任一块空 TLB 项中，TLB 中每项都有一个比较器，没有映射规则，只要空闲就行。TLB 采用静态存储器 SRAM，读写速度快，但成本高， 多用于容量较小的高速缓冲存储器。        3）从图中可以看到，Cache 中每组有两行，故采用 2 路组相联映射方式。 因为是 2 路组相联并采用 LRU 替换算法，所以每行（或每组）需要 1 位 LRU 位；因为采用回写策略，所以每行有 1 位修改位（脏位），根据脏位判断数据是否被更新，若脏位为 1 则需要写回内存        28 位物理地址中 Tag 字段占 20 位，组索引字段占 3 位，块内偏移地址占 5 位，故 Cache 共有 2 3 = 8 组，每组 2 行，每行有 2 5 = 32B，故 Cache 总容量为 8×2×(20 + 1 + 1 + 1+32×8) = 4464 位 = 558 字节。 Cache 中有效位用来指出所在 Cache 行中的信息是否有效。       4）虚拟地址分为两部分：虚页号、页内地址；物理地址分为两部分：实页号、页内地址。 利用虚拟地址的虚页号部分去查找 TLB 表（缺失时从页表调入），将实页号取出后和虚拟地址 的页内地址拼接，就形成了物理地址。虚页号 008CH 恰好在 TLB 表中对应实页号 0040H（有 效位为 1，说明存在），虚拟地址的后 3 位为页内地址 040H，则对应的物理地址是 0040040H。 物理地址为 0040040H，其中高 20 位 00400H 为标志字段，低 5 位 00000B 为块内偏移量， 中间 3 位 010B 为组号 2，因此将 00400H 与 Cache 中的第 2 组两行中的标志字段同时比较，可 以看出，虽然有一个 Cache 行中的标志字段与 00400H 相等，但对应的有效位为 0，而另一 Cache 行的标志字段与 00400H 不相等，故访问 Cache 不命中。 因为物理地址的低 12 位与虚拟地址低 12 位相同，即为 001001100000B。根据物理地址的 结构，物理地址的后八位 01100000B 的前三位 011B是组号，因此该地址所在的主存映射到 Cache 的组号为 3。    \n"
        },
        "review": [
          {
            "detail": "\n  我说一点我困惑不已的地方, 那就是它到底是4路组相联, 还是2路组相联. 因为我就错以为是4路组相联. 看这幅图:@https://uploadfiles.nowcoder.com/images/20211122/381981692_1637563867056/85836E56CBE1168794AB17E7DB3EA6E9@    对比一下, 可知, 一般来说, 一行是一个set. 而且mux的端口数=比较器的个数=相联数. 因此相联数是2. \n"
          }
        ]
      },
      {
        "id": 45,
        "select": false,
        "detail": "  请根据题 44 图给出的虚拟存储管理方式(某计算机采用页式虚拟存储管理方式，按字节编址)，回答下列问题。   @https://uploadfiles.nowcoder.com/images/20200927/330907_1601196266958_A63463899CDA7F23196E8204061FCBDD@       （1）某虚拟地址对应的页目录号为 6，在相应的页表中对应的页号为 6，页内偏移量为 8， 该虚拟地址的十六进制表示是什么？     （2）寄存器 PDBR 用于保存当前进程的页目录起始地址，该地址是物理地址还是虚拟地 址？进程切换时，PDBR 的内容是否会变化？说明理由。同一进程的线程切换时，PDBR 的内 容是否会变化？说明理由。     （3）为了支持改进型 CLOCK 置换算法，需要在页表项中设置哪些字段？       ",
        "answers": {
          "detail": "\n  解答：     1）由图可知，地址总长度为 32 位，高 20 位为虚页号，低 12 位为页内地址，且虚页号高 10 位为页目录号，低 10 位为页号。展开成二进制表示为   @https://uploadfiles.nowcoder.com/images/20200927/330907_1601196401366_F7FE972F657F7C05CA357F1ACC637644@    故十六进制表示为 0180 6008H       2）PDBR 为页目录基址地址寄存器（Page-Directory Base Register），其存储页目录表物理 内存基地址。进程切换时，PDBR 的内容会变化；同一进程的线程切换时，PDBR 的内容不会 变化。每个进程的地址空间、页目录和 PDBR 的内容存在一一对应的关系。进程切换时，地址 空间发生了变化，对应的页目录及其起始地址也相应变化，因此需要用进程切换后当前进程的 页目录起始地址刷新 PDBR。同一进程中的线程共享该进程的地址空间，其线程发生切换时， 地址空间不变，线程使用的页目录不变，因此 PDBR 的内容也不变       3）改进型 CLOCK 置换算法需要用到使用位和修改位，故需要设置访问字段（使用位）和 修改字段（脏位） \n"
        },
        "review": []
      },
      {
        "id": 46,
        "select": false,
        "detail": "  某文件系统采用索引结点存放文件的属性和地址信息，簇大小为 4KB。每个 文件索引结点占 64B，有 11 个地址项，其中直接地址项 8 个，一级、二级和三级间接地址项各 1 个，每个地址项长度为 4B。请回答下列问题。    （1）该文件系统能支持的最大文件长度是多少？（给出计算表达式即可。）    （2）文件系统用 1M（1M = 2 20）个簇存放文件索引结点，用 512M 个簇存放文件数据。若 一个图像文件的大小为 5600B，则该文件系统最多能存放多少个图像文件？     （3）若文件 F1 的大小为 6KB，文件 F2 的大小为 40KB，则该文件系统获取 F1 和 F2 最后 一个簇的簇号需要的时间是否相同？为什么？ ",
        "answers": {
          "detail": "\n  解答：    （1）簇大小为 4KB，每个地址项长度为 4B，故每簇有 4KB/4B = 1024 个地址项。最大文件 的物理块数可达 8 + 1×1024 + 1×1024 2 + 1×1024 3，每个物理块（簇）大小为 4KB，故最大文件 长度为(8 + 1×1024 + 1×1024 2 + 1×1024 3)×4KB = 32KB + 4MB + 4GB + 4TB。     （2）文件索引结点总个数为 1M×4KB/64B = 64M，5600B 的文件占 2 个簇，512M 个簇可 存放的文件总个数为 512M/2 = 256M。可表示的文件总个数受限于文件索引结点总个数，故能存储 64M 个大小为 5600B 的图像文件。     （3）文件 F1 的大小为 6KB < 4KB×8 = 32KB，故获取文件 F1 的最后一个簇的簇号只需要 访问索引结点的直接地址项。文件 F2 的大小为 40KB，4KB×8 < 40KB < 4KB×8 + 4KB×1024， 故获取 F2 的最后一个簇的簇号还需要读一级索引表。综上，需要的时间不相同 \n"
        },
        "review": [
          {
            "detail": "\n@https://uploadfiles.nowcoder.com/images/20210720/690195856_1626767896243/966FE6771FF1B74787EBFD50DF607898@\n"
          }
        ]
      },
      {
        "id": 47,
        "select": false,
        "detail": "  某公司的网络如题 47 图所示。IP 地址空间 192.168.1.0/24 被均分给销售部和 技术部两个子网，并已分别为部分主机和路由器接口分配了 IP 地址，销售部子网的 MTU = 1500B，技术部子网的 MTU = 800B。 请回答下列问题。     （1）销售部子网的广播地址是什么？技术部子网的子网地址是什么？若每个主机仅分配一 个 IP 地址，则技术部子网还可以连接多少台主机？    （2）假设主机 192.168.1.1 向主机 192.168.1.208 发送一个总长度为 1500B 的 IP 分组，IP 分 组的头部长度为 20B，路由器在通过接口 F1 转发该 IP 分组时进行了分片。若分片时尽可能分 为最大片，则一个最大 IP 分片封装数据的字节数是多少？至少需要分为几个分片？每个分片的片偏移量是多少？      @https://uploadfiles.nowcoder.com/images/20200927/330907_1601196612691_63E95F6B69D6D6E2E1002CC7BAEC4C99@ ",
        "answers": {
          "detail": "\n  解答： 1）广播地址是网络地址中主机号全 1 的地址（主机号全 0 的地址代表网络本身）。销售部 和技术部均分配了 192.168.1.0/24 的 IP 地址空间，IP 地址的前 24 位为子网的网络号。于是在后 8 位中划分部门的子网，选择前 1 位作为部门子网的网络号。令销售部子网的网络号为 0，技术 部子网的网络号为 1，则技术部子网的完整地址为 192.168.1.128；令销售部子网的主机号全 1， 可以得到该部门的广播地址为 192.168.1.127。               每个主机仅分配一个 IP 地址，计算目前还可以分配的主机数，用技术部可以分配的主机数减 去已分配的主机数，技术部总共可以分配给计算机的主机数为 2 7- 2 = 126（减去全 0 和全 1 的主机 号）。已经分配了 208-129 + 1 = 80 个，此外还有 1 个 IP 地址分配给了路由器的端口（192.168.1.254）， 因此还可以分配 126 - 80 - 1 = 45 台。                  2）判断分片的大小，需要考虑各个网段的 MTU，而且注意分片的数据长度必须是 8B 的 整数倍。由题可知，在技术部子网内，MTU = 800B，IP 分组头部长 20B，最大 IP 分片封装数 据的字节数为[(800 - 20)/8]×8 = 776。至少需要的分片数为[(1500 - 20)/776] = 2。第 1 个分片的 偏移量为 0；第 2 个分片的偏移量为 776/8 = 97。 \n"
        },
        "review": []
      }
    ]
  },
  {
    "title": 2017,
    "testDetail": [
      {
        "id": 1,
        "select": true,
        "detail": "  下列函数的时间复杂度是   int func(int n){\n int i=0, sum=0;\n while(sum < n) sum += ++i;\n return i;\n}\n   ",
        "answers": {
          "RightAnswer": "B",
          "A": "O(logn)",
          "B": "O(n",
          "C": "O(n)",
          "D": "O(nlogn)"
        },
        "review": [
          {
            "detail": "\n++i， i = 1，2，3，4，5，···，k。 s = 1+2+3+4+5+···+k = k*(k+1)/2。 即此时 sum = k*(k+1)/2 >= n，(k+1)2 > 2n，得到k > (2n)1/2 - 1。\n"
          }
        ]
      },
      {
        "id": 2,
        "select": true,
        "detail": "  下列关于栈的叙述中，错误的是 。     Ⅰ．采用非递归方式重写递归程序时必须使用栈     Ⅱ．函数调用时，系统要用栈保存必要的信息     Ⅲ．只要确定了入桟次序，即可确定出栈次序    Ⅳ．栈是一种受限的线性表，允许在其两端进行操作 ",
        "answers": {
          "RightAnswer": "C",
          "A": "仅 I",
          "B": "仅 I、Ⅱ、Ⅲ",
          "C": "仅 I、Ⅲ、Ⅳ",
          "D": "仅Ⅱ、Ⅲ、Ⅳ"
        },
        "review": [
          {
            "detail": "\n    I. 尾递归可以直接使用循环       II.确定了入桟次序，不能确定出栈次序       IV．栈是一种受限的线性表，允许在其一端（栈顶）进行操作   \n"
          }
        ]
      },
      {
        "id": 3,
        "select": true,
        "detail": "适用于压缩存储稀疏矩阵的两种存储结构是",
        "answers": {
          "RightAnswer": "A",
          "A": "三元组表和十字链表",
          "B": "三元组表和邻接矩阵",
          "C": "十字链表和二叉链表",
          "D": "邻接矩阵和十字链表"
        },
        "review": []
      },
      {
        "id": 4,
        "select": true,
        "detail": "要使一棵非空二叉树的先序序列与中序序列相同，其所有非叶结点须满足的条件是",
        "answers": {
          "RightAnswer": "B",
          "A": "只有左子树",
          "B": "只有右子树",
          "C": "结点的度均为 1",
          "D": "结点的度均为 2"
        },
        "review": []
      },
      {
        "id": 5,
        "select": true,
        "detail": "  已知一棵二叉树的树形如下图所示，其后序序列为 e,a,c,b,d,g,f，树中与结点 a 同层的结点是   @https://uploadfiles.nowcoder.com/images/20200926/330908_1601127151054_35B491BB1ECEE2870E6DCD50CDE915DA@ ",
        "answers": {
          "RightAnswer": "B",
          "A": "c",
          "B": "d",
          "C": "f",
          "D": "g"
        },
        "review": [
          {
            "detail": "\n                                                                    后序序列是先左再右后中间，所以对号入座可知选d\n                                                            "
          },
          {
            "detail": "\n                                                                    后跟序列：每次都是先遍历树的左子树，然后再遍历树的右子树，最后再遍历根节点，以此类推，直至遍历完整个树。\n"
          }
        ]
      },
      {
        "id": 6,
        "select": true,
        "detail": "  已知字符集{a,b,c,d,e,f,g,h}，若各字符的哈夫曼编码依次是 0100，10, 0000, 0101，001, 011，11，0001，则编码序列 0100011001001011110101 的译码结果是    ",
        "answers": {
          "RightAnswer": "D",
          "A": "a c g a b f h",
          "B": "a d b a g b b",
          "C": "a f b e a g d",
          "D": "a f e e f g d"
        },
        "review": []
      },
      {
        "id": 7,
        "select": true,
        "detail": "已知无向图 G 含有 16 条边，其中度为 4 的顶点个数为 3，度为 3 的顶点个数为 4，其他顶点的度均小于 3。图 G 所含的顶点个数至少是",
        "answers": {
          "RightAnswer": "B",
          "A": "10",
          "B": "11",
          "C": "13",
          "D": "15"
        },
        "review": [
          {
            "detail": "\nB.无向图边数的两倍等于各顶点度数的总和。由于其他顶点的度均小于3，可以设它们的度都为2，设它们的数量是x，可列出这样的方程4*3+3*4+2*x=16*2，解得x=4。4+3+3=11，B正确。\n"
          },
          {
            "detail": "\n无向图边数的两倍等于各顶点度数的总和。由于其他顶点的度均小于3，可以设它们的度都为2，设它们的数量是x，可列出这样的方程4*3+3*4+2*x=16*2，解得x=4。4+3+4=11\n"
          }
        ]
      },
      {
        "id": 8,
        "select": true,
        "detail": "  下列二叉树中，可能成为折半查找判定树（不含外部结点）的是    ",
        "answers": {
          "RightAnswer": "A",
          "A": "",
          "B": "",
          "C": "",
          "D": ""
        },
        "review": [
          {
            "detail": "\n折半查找判定树有右子树肯定有左子树\n"
          }
        ]
      },
      {
        "id": 9,
        "select": true,
        "detail": "下列应用中，适合使用 B+树的是",
        "answers": {
          "RightAnswer": "B",
          "A": "编译器中的词法分析",
          "B": "关系数据库系统中的索引",
          "C": "网络中的路由表快速查找",
          "D": "操作系统的磁盘空闲块管理"
        },
        "review": []
      },
      {
        "id": 10,
        "select": true,
        "detail": "  在内部排序时，若选择了归并排序而没有选择插人排序，则可能的理由是    Ⅰ．归并排序的程序代码更短     Ⅱ．归并排序的占用空间更少     Ⅲ．归并排序的运行效率更高 ",
        "answers": {
          "RightAnswer": "B",
          "A": "仅Ⅱ",
          "B": "仅Ⅲ",
          "C": "仅Ⅰ、Ⅱ",
          "D": "仅Ⅰ、Ⅲ"
        },
        "review": []
      },
      {
        "id": 11,
        "select": true,
        "detail": "  下列排序方法中，若将顺序存储更换为链式存储，则算法的时间效率会降低的是     Ⅰ．插人排序 Ⅱ．选择排序 Ⅲ．起泡排序 Ⅳ．希尔排序 Ⅴ．堆排序 ",
        "answers": {
          "RightAnswer": "D",
          "A": "仅Ⅰ、Ⅱ",
          "B": "仅Ⅱ、Ⅲ",
          "C": "仅Ⅲ、Ⅳ",
          "D": "仅Ⅳ、Ⅴ"
        },
        "review": [
          {
            "detail": "\n                                                                    D 希尔排序和堆排序都利用了顺序存储的随机访问特性，而链式存储不支持这种特性，所以时间复杂度会变复杂\n                                                            "
          }
        ]
      },
      {
        "id": 12,
        "select": true,
        "detail": "假定计算机 M1 和 M2 具有相同的指令集体系结构（ISA)，主频分别为 1.5GHz 和 1.2 GHz。在 M1 和 M2 上 运行某基准程序 P，平均 CPI 分别为 2 和 1，则程序 P 在 M1 和 M2 上运行时间的比值是",
        "answers": {
          "RightAnswer": "C",
          "A": "0.4",
          "B": "0.625",
          "C": "1.6",
          "D": "2.5"
        },
        "review": [
          {
            "detail": "\n  答案是 C    执行时间 = (指令数 × CPI) / 时钟频率.    由于 M1 和 M2 具有相同的指令系结构, 则程序 P 在 M1 和 M2 的指令数相同.    于是比值为 CPI1 / 时钟频率1 : CPI2 / 时钟频率2    即 2/1.5 : 1/1.2 = 1.6 \n"
          }
        ]
      },
      {
        "id": 13,
        "select": true,
        "detail": "  某计算机主存按字节编址，由 4 个 64M×8 位的 DRAM 芯片采用交叉编址方式构成，并与宽度为 32 位的存 储器总线相连，主存每次最多读写 32 位数据。若 double 型变量 x 的主存地址为 804 001AH，则读取 x 需要的存储周期数是    ",
        "answers": {
          "RightAnswer": "C",
          "A": "1",
          "B": "2",
          "C": "3",
          "D": "4"
        },
        "review": [
          {
            "detail": "\n                                                                    不是，一次读取32位说明是低位交叉编址，4个芯片，四体并行低位交叉存储器总共就4个模块，不存在2-9，低位交叉编址后两位为模块体的体号，（A=10%4=2，体号从0开始）double是64位也就是8B字节，按字节编址，要读8个字节，每次可读32位也就是4个字节，低位交叉编址第一轮是（模块2-模块3）第二轮是（0-3）最后一轮是（模块0-1）就读完了\n                                                            "
          },
          {
            "detail": "\n                                                                    网上找答案看了很多回答，感觉找不到自己能完全理解的解释，以下整理了两种出现的多的方法以及我自己的一些理解  首先 double 的存储在芯片中是下图这么存的 @https://uploadfiles.nowcoder.com/images/20220611/153159550_1654955031063/F7BF9BB58633DD10E5001DEFD2C08599@  方法1： 读取双精度浮点型数据就是读取64位数据，即从M2开始按交叉编址的顺序往后读 8 个字，在这里就晓得这种解法可以和具体地址无关  题目的问题问的是，存取周期数而不是存取时间，存取周期 = 存取时间 + 恢复时间   按流水线的算法算出总时间 t = T + 7 * T / 4 = 2 * T + 3 * T / 4 ≈ 3T(根据题意显然是向上取整)   方法2： 另外一种解法大概就是利用题目所说每次最多读写 32 位数据+边界不对齐这两点来判断解题的思路，所以得先从 M0 开始读取，读三行，每行时间读取时间为 T，所以总共需要三个存取周期。   个人看法1： 如果让我反驳方法2认可方法1的话，我认为题目中的最多 32 位这个条件就是为了说明使多体并行的结构成立，也就是 4 个存储器，每个存储器的存储单元为 8 bit，4 * 8 = 32，而多体并行存储器的并行是按流水线的算法来运作的，也就是并不是真正的同时运行，只是在读取过程中最多有 4 个存储周期在时序上重叠而已。实际上存储器的占用和释放都是错开的，不是同时的。所可能不能简单地理解为我每次读多少个内存块，每次花多少时间。  个人看法2： 如果让我反驳方法1认可方法2的话，我的想法是，4个DRAM芯片最后是连到宽度为32位的数据总线上的，所以不需要采取每个模块按流水线的方法来交替激活和释放，可以每次直接同时选择四个芯片进行传输\n"
          },
          {
            "detail": "\n @https://uploadfiles.nowcoder.com/images/20211026/108295591_1635248092567/6F4B30D0B0DE99F5438558A94BE38066@    考时序的，和地址没有关系，两个周期取不完，    连续存取m个字所需的时间为t=T+(m-1)*r，T为存取周期，r为总线传输周期=1/4T \n"
          }
        ]
      },
      {
        "id": 14,
        "select": true,
        "detail": "  某 C 语言程序段如下   @https://uploadfiles.nowcoder.com/images/20200926/330908_1601130274310_FAA989295E509D3DFC71AAD69B1DC9AC@       下列关于数组 a 的访问局部性的描述中，正确的是 ",
        "answers": {
          "RightAnswer": "A",
          "A": "时间局部性和空间局部性皆有",
          "B": "无时间局部性，有空间局部性",
          "C": "有时间局部性，无空间局部性",
          "D": "时间局部性和空间局部性皆无"
        },
        "review": [
          {
            "detail": "\n 时间局部性是一旦一条指令执行了，则在不久的将来它可能再被执行。   空间局部性是一旦一个存储单元被访问，那么它附近的存储单元也很快被访问。    显然，这里的循环指令本身具有时间局部性，它对数组a的访问具有空间局部性，选A。 \n"
          }
        ]
      },
      {
        "id": 15,
        "select": true,
        "detail": "下列寻址方式中，最适合按下标顺序访问一维数组元素的是",
        "answers": {
          "RightAnswer": "D",
          "A": "相对寻址",
          "B": "寄存器寻址",
          "C": "直接寻址",
          "D": "变址寻址"
        },
        "review": [
          {
            "detail": "\n 隐含寻址：指令隐含操作数地址    立即寻址：指令地址字段是操作数本身    直接寻址：地址字段直接指出操作数内存地址    间接寻址：地址字段是操作数的形式地址    寄存器寻址：操作数在寄存器中，地址字段是操作数在通用寄存器编号    相对寻址：程序计数器内容加上指令形式地址是操作数有效地址    基址和变址寻址：基址寄存器内容加上指令形式地址    堆栈寻址：操作数存放在堆栈中 \n"
          }
        ]
      },
      {
        "id": 16,
        "select": true,
        "detail": "某计算机按字节编址，指令字长固定且只有两种指令格式，其中三地址指令 29 条，二地址指令 107 条，每个 地址字段为 6 位，则指令字长至少应该是",
        "answers": {
          "RightAnswer": "A",
          "A": "24 位",
          "B": "26 位",
          "C": "28 位",
          "D": "32 位"
        },
        "review": [
          {
            "detail": "\n                                                                    首先，三地址指令有29条，所以操作码至少为5位，所以剩余32－29=3种操作码给二地址指令。又二地址指令是比三地址指令少6位地址码，但是操作码比三地址指令多6位。所以二地址指令操作码一共3种×2^6种=192>107，所以二地址指令够了，指令字长最少为23位，为8的倍数就是24。(注意操作码位数转换为变成2的多少次方就是操作码的种数了，注意转换)\n                                                            "
          },
          {
            "detail": "\n                                                                    假设操作码位数为x位。那么剩余的三地址指令条数还有2^X-29。又因为地址码为6位，所以有：(2^X-29)*2^6>=107;解得x>=5。所以操作码位数>=5+6*3=23\n                                                            "
          }
        ]
      },
      {
        "id": 17,
        "select": true,
        "detail": "  下列关于超标量流水线特性的叙述中，正确的是    Ⅰ．能缩短流水线功能段的处理时间     Ⅱ．能在一个时钟周期内同时发射多条指令     Ⅲ．能结合动态调度技术提高指令执行并行性 ",
        "answers": {
          "RightAnswer": "C",
          "A": "仅Ⅱ",
          "B": "仅Ⅰ、Ⅲ",
          "C": "仅Ⅱ、Ⅲ",
          "D": "Ⅰ、Ⅱ和Ⅲ"
        },
        "review": []
      },
      {
        "id": 18,
        "select": true,
        "detail": "下列关于主存储器（MM）和控制存储器（CS）的叙述中，错误的是",
        "answers": {
          "RightAnswer": "B",
          "A": "MM 在 CPU 外，CS 在 CPU 内",
          "B": "MM 按地址访问，CS 按内容访问",
          "C": "MM 存储指令和数据，CS 存储微指令",
          "D": "MM 用 RAM 和 ROM 实现，CS 用 ROM 实现"
        },
        "review": [
          {
            "detail": "\n                                                                    TLB快表是按内容访问\n                                                            "
          },
          {
            "detail": "\n                                                                    b\n                                                            "
          },
          {
            "detail": "\n                                                                    B 都是按地址访问， D中主板上的BIOS程序存储在ROM中，也是主存的一部分。\n                                                            "
          }
        ]
      },
      {
        "id": 19,
        "select": true,
        "detail": "下列关于指令流水线数据通路的叙述中，错误的是",
        "answers": {
          "RightAnswer": "A",
          "A": "包含生成控制信号的控制部件",
          "B": "包含算术逻辑运算部件（ALU)",
          "C": "包含通用寄存器组和取指部件 ",
          "D": "由组合逻辑电路和时序逻辑电路组合而成"
        },
        "review": [
          {
            "detail": "\n                                                                    CPU由数据通路和控制部件构成，因此数据通路不包含控制部件\n                                                            "
          }
        ]
      },
      {
        "id": 20,
        "select": true,
        "detail": "下列关于多总线结构的叙述中，错误的是",
        "answers": {
          "RightAnswer": "D",
          "A": "靠近 CPU 的总线速度较快 ",
          "B": "存储器总线可支持突发传送方式",
          "C": "总线之间须通过桥接器相连",
          "D": "PC I-Express×l6 采用并行传输方式"
        },
        "review": [
          {
            "detail": "\n  PCI-Express 采用串行数据传输，PCI采用并行数据传输 \n"
          }
        ]
      },
      {
        "id": 21,
        "select": true,
        "detail": "I/O 指令实现的数据传送通常发生在 ",
        "answers": {
          "RightAnswer": "D",
          "A": "I/O 设备和 I/O 端口之间",
          "B": "通用寄存器和 I/O 设备之间",
          "C": "I/O 端口和 I/O 端口之间",
          "D": "通用寄存器和 I/O 端口之间"
        },
        "review": []
      },
      {
        "id": 22,
        "select": true,
        "detail": "下列关于多重中断系统的叙述中，错误的是",
        "answers": {
          "RightAnswer": "B",
          "A": "在一条指令执行结束时响应中断",
          "B": "中断处理期间 CPU 处于关中断状态",
          "C": "中断请求的产生与当前指令的执行无关",
          "D": "CPU 通过采样中断请求信号检测中断请求"
        },
        "review": []
      },
      {
        "id": 23,
        "select": true,
        "detail": "  假设 4 个作业到达系统的时刻和运行时间如下表所示   @https://uploadfiles.nowcoder.com/images/20200927/330908_1601172684095_D7E1D00B6C6D04E6CFC7E489BFF4BB64@    系统在 t=2 时开始作业调度。若分別采用先来先服务和短作业优先调度算法，则选中的作业分别是  ",
        "answers": {
          "RightAnswer": "D",
          "A": "J2、J3 ",
          "B": "J1、J4",
          "C": "J2、J4 ",
          "D": "J1、J3"
        },
        "review": []
      },
      {
        "id": 24,
        "select": true,
        "detail": "  执行系统调用的过程包括如下主要操作：     ①返回用户态     ②执行陷人(trap)指令     ③传递系统调用参数     ④执行相应的服务程序     正确的执行顺序是 ",
        "answers": {
          "RightAnswer": "C",
          "A": "②->③->①->④",
          "B": "②->④->③->①",
          "C": "③->②->④>①",
          "D": "③->④->②->①"
        },
        "review": []
      },
      {
        "id": 25,
        "select": true,
        "detail": "  某计算机按字节编址，其动态分区内存管理采用最佳适应算法，每次分配和回收内存后都对空闲分区链重新 排序。当前空闲分区信息如下表所示   @https://uploadfiles.nowcoder.com/images/20200927/330908_1601172789363_F2BB83FF553B8F2F67FBDDB321C991E1@    回收起始地址为 60 K、大小为 140 KB 的分区后，系统中空闲分区的数量、空闲分区链第一个分区的起始地址和 大小分别是 ",
        "answers": {
          "RightAnswer": "B",
          "A": "3、20 K、380 KB",
          "B": "3、500 K、80 KB",
          "C": "4、20 K、180 KB",
          "D": "4、500 K、80 KB"
        },
        "review": []
      },
      {
        "id": 26,
        "select": true,
        "detail": "某文件系统的簇和磁盘扇区大小分别为 1 KB 和 512 B。若一个文件的大小为 1026B，则系统分配给该文件的磁盘空间大小是",
        "answers": {
          "RightAnswer": "D",
          "A": "1026 B",
          "B": "1536 B",
          "C": "1538 B",
          "D": "2048 B"
        },
        "review": []
      },
      {
        "id": 27,
        "select": true,
        "detail": "下列有关基于时间片的进程调度的叙述中，错误的是",
        "answers": {
          "RightAnswer": "B",
          "A": "时间片越短，进程切换的次数越多，系统也越大",
          "B": "当前进程的时间片用完后，该进程状态由执行态变为阻塞态",
          "C": "时钟中断发生后，系统会修改当前进程在时间片内的剩余时间",
          "D": "影响时间片大小的主要因素包括响应时间、系统开销和进程数量等"
        },
        "review": [
          {
            "detail": "\n                                                                    应该变为就绪态\n                                                            "
          }
        ]
      },
      {
        "id": 28,
        "select": true,
        "detail": "  与单道程序系统相比，多道程序系统的优点是 。     Ⅰ．CPU 利用率高     Ⅱ．系统开销小     Ⅲ．系统吞吐量大     Ⅳ．I/O 设备利用率高 ",
        "answers": {
          "RightAnswer": "D",
          "A": "仅Ⅰ、Ⅲ",
          "B": "仅Ⅰ、Ⅳ",
          "C": "仅Ⅱ、Ⅲ",
          "D": "仅Ⅰ、Ⅲ、Ⅳ"
        },
        "review": []
      },
      {
        "id": 29,
        "select": true,
        "detail": "  下列选项中，磁盘逻辑格式化程序所做的工作是 。     Ⅰ．对磁盘进行分区     Ⅱ．建立文件系统的根目录     Ⅲ．确定磁盘扇区校验码所占位数     Ⅳ．对保存空闲磁盘块信息的数据结构进行初始化 ",
        "answers": {
          "RightAnswer": "B",
          "A": "仅Ⅱ ",
          "B": "仅Ⅱ、Ⅳ",
          "C": "仅Ⅲ、Ⅳ ",
          "D": "仅Ⅰ、Ⅱ、Ⅳ"
        },
        "review": []
      },
      {
        "id": 30,
        "select": true,
        "detail": "某文件系统中，针对每个文件，用户类别分为 4 类：安全管理员、文件主、文件主的伙伴、其他用户；访问 权限分为 5 种：完全控制、执行、修改、读取、写入。若文件控制块中用二进制位串表示文件权限，为表示不同类别用户对一个文件的访问权限，则描述文件权限的位数至少应为",
        "answers": {
          "RightAnswer": "D",
          "A": "5",
          "B": "9",
          "C": "12",
          "D": "20"
        },
        "review": []
      },
      {
        "id": 31,
        "select": true,
        "detail": "  若文件 f1 的硬链接为 f2，两个进程分别打开 f1 和 f2，获得对应的文件描述符为 fd1 和 fd2，则下列叙述中， 正确的是    Ⅰ．f1 和 f2 的读写指针位置保持相同     Ⅱ．f1 和 f2 共享同一个内存索引结点     Ⅲ．fd1 和 fd2 分别指向各自的用户打开文件表中的一项 ",
        "answers": {
          "RightAnswer": "B",
          "A": "仅Ⅰ",
          "B": "仅Ⅱ、Ⅲ",
          "C": "仅Ⅰ、Ⅱ",
          "D": "Ⅰ、Ⅱ和Ⅲ"
        },
        "review": []
      },
      {
        "id": 32,
        "select": true,
        "detail": "  系统将数据从磁盘读到内存的过程包括以下操作：     ①DMA 控制器发出中断请求     ②初始化 DMA 控制器并启动磁盘     ③从磁盘传输一块数据到内存缓冲区     ④执行“DMA 结束”中断服务程序 正确的执行顺序是    ",
        "answers": {
          "RightAnswer": "B",
          "A": "③->①->②->④",
          "B": "②->③->①->④",
          "C": "②->①->③->④",
          "D": "①->②->④->③"
        },
        "review": []
      },
      {
        "id": 33,
        "select": true,
        "detail": "  假设 OSI 参考模型的应用层欲发送 400 B 的数据（无拆分），除物理层和应用层之外，其他各层在封装 PDU 时均引人 20 B 的额外开销，则应用层数据传输效率约为     ",
        "answers": {
          "RightAnswer": "A",
          "A": "80%",
          "B": "83%",
          "C": "87%",
          "D": "91%"
        },
        "review": []
      },
      {
        "id": 34,
        "select": true,
        "detail": "若信道在无噪声情况下的极限数据传输速率不小于信噪比为 30dB 条件下的极限数据传输速率，则信号状态数至少是",
        "answers": {
          "RightAnswer": "D",
          "A": "4",
          "B": "8",
          "C": "16",
          "D": "32"
        },
        "review": [
          {
            "detail": "\n  2Wlog2N >= Wlog2(1+S/N)   W是信道带宽，N是信号状态数，S/N是信噪比    其中噪声分贝dB=10log10(S/N)      将数据带入计算可得N≥32 \n"
          }
        ]
      },
      {
        "id": 35,
        "select": true,
        "detail": "  在下图所示的网络中,若主机 H 发送一个封装访问 Internet 的 IP 分组的 IEEE 802.11 数据帧 F,则帧 F 的地址 1、 地址 2 和地址 3 分别是   @https://uploadfiles.nowcoder.com/images/20200927/330908_1601173183195_3EB059DA90F6CC27AEB10E96C3D0FBDB@ ",
        "answers": {
          "RightAnswer": "B",
          "A": "00-12-34-56-78-9a，00-12-34-56-78-9b，00-12-34-56-78-9c",
          "B": "00-12-34-56-78-9b，00-12-34-56-78-9a，00-12-34-56-78-9c",
          "C": "00-12-34-56-78-9b，00-12-34-56-78-9c，00-12-34-56-78-9a",
          "D": "00-12-34-56-78-9a，00-12-34-56-78-9c，00-12-34-56-78-9b"
        },
        "review": [
          {
            "detail": "\n                                                                    帧 F 的地址 1（接收地址）、 地址 2（发送地址） 和地址 3（目的地址）\n                                                            "
          }
        ]
      },
      {
        "id": 36,
        "select": true,
        "detail": "下列 IP 地址中，只能作为 IP 分组的源 IP 地址但不能作为目的 IP 地址的是",
        "answers": {
          "RightAnswer": "A",
          "A": "0.0.0.0",
          "B": "127.0.0.1",
          "C": "200.10.10.3",
          "D": "255.255.255.255"
        },
        "review": [
          {
            "detail": "\n                                                                    0.0.0.0 表示本网络上的本主机\n                                                            "
          }
        ]
      },
      {
        "id": 37,
        "select": true,
        "detail": "直接封装 RIP、OSPF、BGP 报文的协议分别是",
        "answers": {
          "RightAnswer": "D",
          "A": "TCP、UDP、IP",
          "B": "TCP、IP、UDP",
          "C": "UDP、TCP、IP",
          "D": "UDP、IP、TCP"
        },
        "review": [
          {
            "detail": "\n  答案：D       题目中提到的是直接封装，    RIP报文直接封装在UDP中，OSPF报文直接封装在IP中，GBP报文直接封装在TCP中      @https://uploadfiles.nowcoder.com/compress/mw1000/images/20201122/414912900_1606042284194_EAF78E707AC2E75DD0AAEB17623FA8F3@   @https://uploadfiles.nowcoder.com/compress/mw1000/images/20201122/414912900_1606042406351_9FA2473594EF31D4A97EDE94ABF5B81F@   @https://uploadfiles.nowcoder.com/compress/mw1000/images/20201122/414912900_1606042463433_FA937E6F16AF4A70CB279272321257CA@    \n"
          }
        ]
      },
      {
        "id": 38,
        "select": true,
        "detail": "若将网络 21.3.0.0/16 划分为 128 个规模相同的子网，则每个子网可分配的最大 IP 地址个数是",
        "answers": {
          "RightAnswer": "C",
          "A": "254",
          "B": "256",
          "C": "510",
          "D": "512"
        },
        "review": [
          {
            "detail": "\n                                                                    128=2的7次方，16-7=9，所以9个主机位，9的平方-2=510\n                                                            "
          }
        ]
      },
      {
        "id": 39,
        "select": true,
        "detail": "若甲向乙发起一个 TCP 连接，最大段长 MSS=1 KB，RTT = 5 ms,乙开辟的接收缓存为 64 KB,则甲从连接建立 成功至发送窗口达到 32 KB，需经过的时间至少是",
        "answers": {
          "RightAnswer": "A",
          "A": "25 ms ",
          "B": "30 ms",
          "C": "160 ms",
          "D": "165 ms"
        },
        "review": [
          {
            "detail": "\n  王道上的答案   @https://uploadfiles.nowcoder.com/images/20201128/207575826_1606563126845/A77A12271BC3984C35983ADF3DC7ED3D@ \n"
          }
        ]
      },
      {
        "id": 40,
        "select": true,
        "detail": "下列关于 FTP 协议的叙述中，错误的是",
        "answers": {
          "RightAnswer": "C",
          "A": "数据连接在每次数据传输完毕后就关闭",
          "B": "控制连接在整个会话期间保持打开状态",
          "C": "服务器与客户端的 TCP 20 端口建立数据连接",
          "D": "客户端与服务器的 TCP 21 端口建立控制连接"
        },
        "review": [
          {
            "detail": "\n  21控制端口，20数据端口    下面这个链接有说明：   http://www.xpshuai.cn/posts/57750/ \n"
          },
          {
            "detail": "\n                                                                    服务器端控制进程接收到客户发来的文件传输请求，（服务器端）就创建数据传输进程和数据连接，传输完毕关闭数据传输连接并结束运行\n                                                            "
          }
        ]
      },
      {
        "id": 41,
        "select": false,
        "detail": "  请设计一个算法，将给定的表达式树（二叉树）转换为等价的中缀表达式（通过括号反映操作符的 计算次序）并输出。例如，当下列两棵表达式树作为算法的输人时：   @https://uploadfiles.nowcoder.com/images/20200927/330908_1601173422753_6EBDEA22BE46497C147812ECB672A42A@       输出的等价中缀表达式分别为(a+b)*(c*(-d))和(a*b)+(-(c-d))。 二叉树结点定义如下:  typedef struct node{ \n    char data[10]; //存储操作数或操作符 \n    struct node *left, *right; \n}\nBTree;   要求：      (1)给出算法的基本设计思想。     (2)根据设计思想，采用 C 或 C++语言描述算法，关键之处给出注释。 ",
        "answers": {
          "detail": "\n  解析：     (1)算法的基本设计思想 表达式树的中序序列加上必要的括号即为等价的中缀表达式。可以基于二叉树的中序遍历策略得到所需的表达式。 （3 分）     表达式树中分支结点所对应的子表达式的计算次序，由该分支结点所处的位置决定。为得到正确的中缀表达式， 需要在生成遍历序列的同时，在适当位置增加必要的括号。显然，表达式的最外层（对应根结点）及操作数（对应叶 结点）不需要添加括号。（2 分）        (2)算法实现（10 分）     将二叉树的中序遍历递归算法稍加改造即可得本题答案。除根结点和叶结点外，遍历到其他结点时在遍历 其左子树之前加上左括号，在遍历完右子树后加上右括号。  void BtreeToE(BTree *root)\n{\n    BtreeToExp(root, 1); //根的高度为 1\n}\nvoid BtreeToExp(BTree *root, int deep)\n{\n    if (root == NULL)\n        return;                                         //空结点返回\n    else if (root->left == NULL && root->right == NULL) //若为叶结点\n        printf(“% s”, root->data);                      //输出操作数，不加括号\n    else\n    {\n        if (deep > l)printf(“(”); //若有子表达式则加 1 层括号\n        BtreeToExp(root->left, deep + 1);\n        printf(“% s”, root->data); //输出操作符\n        BtreeToExp(root->right, deep + 1);\n        if (deep > l) printf(“)”); //若有子表达式则加 1 层括号\n    }\n}\n\n   \n"
        },
        "review": [
          {
            "detail": "\nvoid inorder(BTree root)\n{\n    if(root==null)return;\n   if(root->left!=null||root->right!=null)\n   {\n       cout<<'(';\n        inorder(root->left);\n       cout<<root->data;\n        inorder(root->right);\n        cout<<')';\n    }\n    else cout<<root-data;\n}\nvoid main(Btree root)\n{\n    inorder(root);\n} \n"
          },
          {
            "detail": "\nInOrderTraverse(BTree T)\n{\n    if(T)\n    {\n        pritnf(\"(\");\n        InOrderTraverse(T->left);\n        printf(\"%c\",T->data);\n        InOrderTraverse(T->right);\n        printf(\")\");\n    }\n} \n"
          }
        ]
      },
      {
        "id": 42,
        "select": false,
        "detail": "  使用 Prim(普里姆）算法求带权连通图的最小（代价）生成树(MST)。请回答下列问题。     (1)对下列图 G，从顶点 A 开始求 G 的 MST，依次给出按算法选出的边。    (2)图 G 的 MST 是唯一的吗？    (3)对任意的带权连通图，满足什么条件时，其 MST 是唯一的？   @https://uploadfiles.nowcoder.com/images/20200927/330908_1601173675372_4C8CC59FCC2DFFA34B3C843E42F23A15@ ",
        "answers": {
          "detail": "\n  (1)Prim 算法属于贪心策略。算法从一个任意的顶点开始，一直长大到覆盖图中所有顶点为止。算法每一步在连接 树集合 S 中顶点和其他顶点的边中，选择一条使得树的总权重增加最小的边加入集合 S。当算法终止时，S 就是最小生 成树。     ①S 中顶点为 A，候选边为(A,D)、(A,B)、(A,E)，选择(A,D)加入 S。     ②S 中顶点为 A、D，候选边为(A,B)、(A,E)、(D,E)、(C,D)，选择(D,E)，加入 S。     ③S 中顶点为 A、D、E，候选边为(A,B)、(C,D)、(C,E)，选择(C,E)加入 S。     ④S 中顶点为 A、D、E、C，候选边为(A,B)、(B,C)，选择(B,C)加入 S。 ⑤S 就是最小生成树。 依次选出的边为： (A，D),(D，E),(C，E),(B，C) （4 分）        【评分说明】每正确选对一条边且次序正确,给 1 分。若考生选择的边正确，但次序不完全正确，酌情给分。     (2)图 G 的 MST 是唯一的。（2 分）第一小题的最小生成树包括了图中权值最小的四条边，其他边都比这四条 边大，所以此图的 MST 唯一。    (3)当带权连通图的任意一个环中所包含的边的权值均不相同时，其 MST 是唯一的。（2 分）此题不要求回答 充分必要条件，所以回答一个限制边权值的充分条件即可    ①若考生答案中给出的是其他充分条件，例如“带权连通图的所有边的权值均不相同”，同样给 分。     ②若考生给出的充分条件对图的顶点数和边数做了某些限制，例如，限制了图中顶点的个数（顶点个数少 于 3 个）、限制了图的形状（图中没有环）等，则最高给 1 分。    ③答案部分正确，酌情给分 \n"
        },
        "review": [
          {
            "detail": "\n  （1）(A,D)->(D,E)->(E,C)->(C,B)   （2）唯一   （3）当图（带权连通图）中所有边的权值均不同时MST唯一（此题不要求回答充分 必要条件,所以回答一个限制边权值的充分条件即可）  \n"
          }
        ]
      },
      {
        "id": 43,
        "select": false,
        "detail": "  已知@https://uploadfiles.nowcoder.com/images/20200927/330908_1601173794145_0799B07D9A2877F5BE09B120A46F65EB@，计算 f(n)的 C 语言函数 f1 如下：   @https://uploadfiles.nowcoder.com/images/20200927/330908_1601173824518_96AE618A68A85FD02BF6B72CCE386429@       将 f1 中的 int 都改为 float，可得到计算 f(n)的另一个函数 f2。假设 unsigned 和 int 型数据都占 32 位，float 采用 IEEE 754 单精度标准。请回答下列问题。     (1)当 n=0 时，f1 会出现死循环，为什么？若将 f1 中的变量 i 和 n 都定义为 int 型，则 f1 是否还会出现死循环？为 什么？     (2)f1(23)和 f2(23)的返回值是否相等？机器数各是什么（用十六进制表示）？      (3)f1(24)和 f2(24)的返回值分别为 33 554 431 和 33 554 432.0，为什么不相等？     (4)f(31)=232-1，而 f1(31)的返回值却为-1,为什么？若使 f1(n)的返回值与 f(n)相等，则最大的 n 是多少？     (5)f2(127)的机器数为 7F80 0000H，对应的值是什么？若使 f2(n）的结果不溢出，则最大的 n 是多少？若使 f2(n) 的结果精确（无舍入），则最大的 n 是多少？ ",
        "answers": {
          "detail": "\n  解析：     (1)由于 i 和 n 是unsigned 型，故“i<=n-l”是无符号数比较，n=0 时，n-1 的机器数为全1，值是2 32 -1,为 unsigned 型可表示的最大数，条件“i<=n-1”永真，因此出现死循环。（2 分）      若 i 和 n 改为 int 类型，则不会出现死循环。（1 分）     因为“i<=n-1”是带符号整数比较，n=0 时，n-1 的值是-1，当 i=0 时条件“i<=n-1”不成立，此时退出 for 循环。 （1 分）        (2)f1(23)与 f2(23)的返回值相等。（1 分）    f(23)=223+1 -1=224 -1，它的二进制形式是 24 个 1。int 占 32 位，没有 溢出。float 有 1 个符号位，8 个指数位，23 个底数位，23 个底数位可以表示 24 位的底数。所以两者返回值相等。 f1(23)的机器数是 00FF FFFFH，（1 分）     f2(23)的机器数是 4B7F FFFFH。（1 分）     显而易见前者是 24 个 1，即 0000 0000 1111 1111 1111 1111 1111 1111（2），后者符号位是 0，指数位为 23+127(10)=1001 0110（2），底数位是 111 1111 1111 1111 1111 1111（2）。        (3)当 n=24 时，f(24)=1 1111 1111 1111 1111 1111 1111 B,而 float 型数只有 24 位有效位，舍入后数值增大， 所以 f2(24)比 f1(24)大 1。（1 分）        【评分说明】只要说明 f2(24)需舍人处理即可给分。 (4)显然 f(31)已超出了 int 型数据的表示范围，用 f1(31)实现时得到的机器数为 32 个 1，作为 int 型数解释时 其值为-1,即 f1(31)的返回值为-1。（1 分）     因为 int 型最大可表示数是 0 后面加 31 个 1，故使 f1(n)的返回值与 f(n)相等的最大 n 值是 30。（1 分）        【评分说明】对于第二问，只要给出 n=30 即可给分。     (5)IEEE 754 标准用“阶码全 1、尾数全 0”表示无穷大。f2 返回值为 float 型，机器数 7F80 0000H 对应的值是+ ∞。(1 分）     当 n=126 时，f(126)=2127 -1=1.1…1×2 126，对应阶码为 127+126=253，尾数部分舍人后阶码加 1，最终阶码为 254, 是 IEEE 754 单精度格式表示的最大阶码。故使 f2 结果不溢出的最大 n 值为 126。（1 分）     当 n=23 时，f(23)为 24 位 1,float 型数有 24 位有效位，所以不需舍人，结果精确。故使 f2 获得精确结果的最大 n 值为 23。(1 分）        【评分说明】对于第二问，只要给出 n=23,即可给分。对于第三问，只要给出 n=126，即可给分。 \n"
        },
        "review": []
      },
      {
        "id": 44,
        "select": false,
        "detail": "  在按字节编址的计算机 M 上，题 43 中 f1 的部分源程序(阴影部分）与对应的机器级代码（包括指令的虚拟地址）如下：   @https://uploadfiles.nowcoder.com/images/20200927/330908_1601173999721_C80FD11DACAB61DF2CD6A4983E4D17B0?x-oss-process=image/resize,p_58@       其中，机器级代码行包括行号、虚拟地址、机器指令和汇编指令。请回答下列问题。     (1)计算机 M 是 RISC 还是 CISC？为什么？    (2)f1 的机器指令代码共占多少字节？要求给出计算过程。     (3)第 20 条指令 cmp 通过 i 减 n-1 实现对 i 和 n-1 的比较。执行 f1(0)过程中当 i=0 时，cmp 指令执行后，进/借位标 志 CF 的内容是什么？要求给出计算过程。     (4)第 23 条指令 shl 通过左移操作实现了 power *2 运算，在 f2 中能否也用 shl 指令实现 power *2？为什么？ ",
        "answers": {
          "detail": "\n  解析：     (1)M 为 CISC。（1 分）     M 的指令长短不一，不符合 RISC 指令系统特点。（1 分）        (2)f1 的机器代码占 96B。（1 分）     因为 f1 的第一条指令“push ebp”所在的虚拟地址为 0040 1020H，最后一条指令“ret”所在的虚拟地址为 0040 107FH，所以，f1 的机器指令代码长度为 0040 107FH - 0040 1020H + 1 = 60H = 96 个字节。（1 分）        (3)CF=1。（1 分）     cmp 指令实现 i 与 n-1 的比较功能，进行的是减法运算。在执行 f1(0)过程中，n=0，当 i=0 时，i=0000 0000H， 并且 n-1=FFFF FFFFH。因此，当执行第 20 条指令时，在补码加/减运算器中执行“0 减 FFFF FFFFH”的操作，即 0000 0000H + 0000 0000H+1 = 0000 0001H，此时，进位输出 C = 0，减法运算时的借位标志 CF = C ㊉ 1 = 1。（2 分）        (4)f2 中不能用 shl 指令实现 power*2。（1 分）     因为 shl 指令用来将一个整数的所有有效数位作为一个整体左移；而 f2 中的变量 power 是 float 型，其机器数中 不包含最高有效数位，但包含了阶码部分，将其作为一个整体左移时并不能实现“乘 2”的功能，因而 f2 中不能用 shl 指令实现 power*2。(2 分）浮点数运算比整型运算要复杂，耗时也较长。 \n"
        },
        "review": []
      },
      {
        "id": 45,
        "select": false,
        "detail": "  假定上题(题44)给出的计算机 M 采用二级分页虚拟存储管理方式，虚拟地址格式如下：   @https://uploadfiles.nowcoder.com/images/20200927/330908_1601174189128_C1E02B382184838D75CAE333EBD0D62D@       请针对题 43 的函数 f1 和题 44 中的机器指令代码，回答下列问题。     (1)函数 f1 的机器指令代码占多少页？     (2)取第 1 条指令（push ebp)时，若在进行地址变换的过程中需要访问内存中的页目录和页表，则会分别访问它们 各自的第几个表项（编号从 0 开始）？     (3)M 的 I/O 采用中断控制方式。若进程 P 在调用 f1 之前通过 scanf()获取 n 的值，则在执行 scanf()的过程中，进程 P 的状态会如何变化？ CPU 是否会进入内核态？ ",
        "answers": {
          "detail": "\n    解析：      (1)函数 f1 的代码段中所有指令的虚拟地址的高 20 位相同，因此 f1 的机器指令代码在同一页中，仅占用 1 页。 （1 分）页目录号用于寻找页目录的表项，该表项包含页表的位置。页表索引用于寻找页表的表项，该表项包含页的位置。          (2)push ebp 指令的虚拟地址的最高 10 位（页目录号）为 00 0000 0001，中间 10 位（页表索引）为 00 0000 0001， 所以，取该指令时访问了页目录的第 1 个表项，（1 分）在对应的页表中访问了第 1 个表项。（1 分）         (3)在执行 scanf()的过程中，进程 P 因等待输人而从执行态变为阻塞态。（1 分）输人结束时，P 被中断处理程 序唤醒，变为就绪态。（1 分）P 被调度程序调度，变为运行态。（1 分）CPU 状态会从用户态变为内核态。（1 分）    \n"
        },
        "review": []
      },
      {
        "id": 46,
        "select": false,
        "detail": "  某进程中有 3 个并发执行的线程 thread1、thread2 和 thread3，其伪代码如下所示。   @https://uploadfiles.nowcoder.com/images/20200927/330908_1601174303819_62235A90DC0E383C4F74500771DF04E1?x-oss-process=image/resize,p_53@       请添加必要的信号量和 P、V(或 wait()、signal())操作，要求确保线程互斥访问临界资源，并且最大程度地并发执行。 ",
        "answers": {
          "detail": "\n  解析：    先找出线程对在各个变量上的互斥、并发关系。如果是一读一写或两个都是写，那么这就是互斥关系。每一个互 斥关系都需要一个信号量进行调节。     semaphore mutex_y1=1; //mutex_y1 用于 thread1 与 thread3 对变量 y 的互斥访问。     semaphore mutex_y2=1; //mutex_y2 用于 thread2 与 thread3 对变量 y 的互斥访问。     semaphore mutex_z=1; //mutex_z 用于变量 z 的互斥访问。      @https://uploadfiles.nowcoder.com/images/20200927/330908_1601174346215_E759F15795632A78A47DA5B31623C456@      @https://uploadfiles.nowcoder.com/images/20200927/330908_1601174358182_42AF6469C23DA814B4CD9E0112F058DA@    \n"
        },
        "review": []
      },
      {
        "id": 47,
        "select": false,
        "detail": "  甲乙双方均采用后退 N 帧协议（GBN)进行持续的双向数据传输，且双方始终采用捎带确认，帧长均为 1000 B。Sx,y和 Rx,y分别表示甲方和乙方发送的数据帧，其中：x 是发送序号；y 是确认序号（表示希望接收对方的下一 帧序号）；数据帧的发送序号和确认序号字段均为 3 比特。信道传输速率为 100Mbps，RTT=0.96ms。下图给出了甲方发 送数据帧和接收数据帧的两种场景，其中 t0为初始时刻，此时甲方的发送和确认序号均为 0，t1时刻甲方有足够多的数 据待发送。   @https://uploadfiles.nowcoder.com/images/20200927/330908_1601174437145_8203063708BABD45426F4163DA8735D9?x-oss-process=image/resize,p_64@       请回答下列问题。     (1)对于图(a)，t0 时刻到 t1 时刻期间，甲方可以断定乙方已正确接收的数据帧数是多少？正确接收的是哪儿个帧（请 用 Sx,y 形式给出）？     (2)对于图(a)，从 t1 时刻起，甲方在不出现超时且未收到乙方新的数据帧之前，最多还可以发送多少个数据帧？其 中第一个帧和最后一个帧分别是哪个（请用 Sx,y 形式给出）？     (3)对于图(b)，从 t1 时刻起，甲方在不出现新的超时且未收到乙方新的数据帧之前，需要重发多少个数据帧？重发 的第一个帧是哪个（请用 Sx,y 形式给出）？     (4)甲方可以达到的最大信道利用率是多少？ ",
        "answers": {
          "detail": "\n  (1)t0时刻到 t1时刻期间，甲方可以断定乙方已正确接收了 3 个数据帧，（1 分）分别是 S0,0、S1,0、S2,0。（1 分）R3,3 说明乙发送的数据帧确认号是 3，即希望甲发送序号 3 的数据帧，说明乙已经接收了序号为 0-2 的数据帧。        (2)从 t1时刻起，甲方最多还可以发送 5 个数据帧，（1 分）其中第一个帧是 S5,2，(1 分）最后一个数据帧是 S1,2。 （1 分）发送序号 3 位，有 8 个序号。在 GBN 协议中，序号个数>=发送窗口+1，所以这里发送窗口最大为 7。此时已发 送了 S3,0 和 S4,1，所以最多还可以发送 5 个帧。       (3)甲方需要重发 3 个数据帧，（1 分）重发的第一个帧是 S2,3。(1 分）在 GBN 协议中，接收方发送了 N 帧后， 检测出错，则需要发送出错帧及其之后的帧。S2,0 超时，所以重发的第一帧是 S2。已收到乙的 R2 帧，所以确认号应 为 3。       (4)甲方可以达到的最大信道利用率是：   @https://uploadfiles.nowcoder.com/images/20200927/330908_1601174505026_5466FBFC512C3DEDC39B914FD3B63260@       U = 发送数据的时间 / 从开始发送第一帧到收到第一个确认帧的时间 = N * Td /(Td + RTT + Ta) U 是信道利用率，N 是发送窗口的最大值，Td 是发送一数据帧的时间，RTT 是往返时间，Ta 是发送一确认帧的时 间。这里采用捎带确认，Td=Ta。       \n"
        },
        "review": []
      }
    ]
  },
  {
    "title": 2016,
    "testDetail": [
      {
        "id": 1,
        "select": true,
        "detail": "  已知表头元素为 c 的单链表在内存中的存储状态如下表所示。   @https://uploadfiles.nowcoder.com/images/20200927/330909_1601174647444_83854D2A4C6D618A4251B01DE50AE4AC@       现将 f 存放于 1014H 处并插入到单链表中，若 f 在逻辑上位于 a 和 e 之间，则 a, e, f 的“链接地址”依次是 ",
        "answers": {
          "RightAnswer": "D",
          "A": "1010H, 1014H, 1004H",
          "B": "1010H, 1004H, 1014H",
          "C": "1014H, 1010H, 1004H ",
          "D": "1014H, 1004H, 1010H"
        },
        "review": []
      },
      {
        "id": 2,
        "select": true,
        "detail": "  已知一个带有表头结点的双向循环链表 L，结点结构为 @https://uploadfiles.nowcoder.com/images/20200927/330909_1601174709136_3BB88797AE38A10570AD4C8506B0DD3E@ ，其中，prev 和 next 分别是指向 其直接前驱和直接后继结点的指针。现要删除指针 p 所指的结点，正确的语句序列是    ",
        "answers": {
          "RightAnswer": "D",
          "A": "p->next->prev = p->prev; ",
          "B": "p->next->prev = p->next; ",
          "C": "p->next->prev = p->next; ",
          "D": "p->next->prev = p->prev; "
        },
        "review": []
      },
      {
        "id": 3,
        "select": true,
        "detail": "  设有图下图所示的火车车轨，入口到出口之间有 n 条轨道，列车的行进方向均为从左至右，列车可驶入任意一 条轨道。现有编号为 1~9 的 9 列列车，驶入的次序依次是 8,4,2,5,3,9,1,6,7。若期望驶出的次序依次为 1~9，则 n 至少 是   @https://uploadfiles.nowcoder.com/images/20200927/330909_1601174780912_8C2DF3113C4898C49798E2C99B86498D@    ",
        "answers": {
          "RightAnswer": "C",
          "A": "2",
          "B": "3",
          "C": "4",
          "D": "5"
        },
        "review": [
          {
            "detail": "\n                                                                    将其视为多条队列，每条队列满足：先入队的元素小于**队的元素(如果8和4在同一队列，8在4的后面），这样8入队列1，4入队列2，2入队列3，5入队列2（也可以将5入队列3，但这时剩下的元素就必须放到一个新的队列中，无法使其“至少”），3入队列3，9入队列1，这时共占了3个队列，后面还有元素1，直接再占用一个新的队列4，1从队列4出队后，6、7可以入队到队列2、3、4，综上：最少占用4个队列。其中，确保满足：1）队列中后面的元素大于前面的元素；2）确保占用最少。\n                                                            "
          }
        ]
      },
      {
        "id": 4,
        "select": true,
        "detail": "有一个 100 阶的三对角矩阵 M，其元素 mi,j（1≤i≤100,1≤j≤100）按行优先依次压缩存入下标从 0 开始的一 维数组 N 中。元素 m30,30在 N 中的下标是",
        "answers": {
          "RightAnswer": "B",
          "A": "86",
          "B": "87",
          "C": "88",
          "D": "89"
        },
        "review": [
          {
            "detail": "\n                                                                    a[k]-->k=2i+j-2;   30*2+30-2 下标0开始所以-1最后为87\n                                                            "
          }
        ]
      },
      {
        "id": 5,
        "select": true,
        "detail": "若森林 F 有 15 条边、25 个结点，则 F 包含树的个数是",
        "answers": {
          "RightAnswer": "C",
          "A": "8",
          "B": "9",
          "C": "10",
          "D": "11"
        },
        "review": [
          {
            "detail": "\n 森林不一定是二叉树，三叉。。有多个孩子节点。   当一棵树时，假设5个结点，得到4条边，形成一棵树。5-4=1；   形成两棵树的情况下，浪费一个结点，得到3条边，形成两棵树。5-3=2；   因此递推出关系：一棵树的边数为15，有25个结点，形成25-15=10棵。 \n"
          }
        ]
      },
      {
        "id": 6,
        "select": true,
        "detail": "  下列选项中，不是下图深度优先搜索序列的是   @https://uploadfiles.nowcoder.com/images/20200927/330909_1601175099481_905BF5CAE97E40E013A5AEC2FD60339E@    ",
        "answers": {
          "RightAnswer": "D",
          "A": "V1, V5, V4, V3, V2",
          "B": "V1, V3, V2, V5, V4",
          "C": "V1, V2, V5, V4, V3",
          "D": "V1, V2, V3, V4, V5"
        },
        "review": []
      },
      {
        "id": 7,
        "select": true,
        "detail": "若将 n 个顶点 e 条弧的有向图采用邻接表存储，则拓扑排序算法的时间复杂度是",
        "answers": {
          "RightAnswer": "B",
          "A": "O(n)",
          "B": "O(n+e) ",
          "C": "O(n",
          "D": "O(n*e)"
        },
        "review": []
      },
      {
        "id": 8,
        "select": true,
        "detail": "  使用迪杰斯特拉（Dijkstra）算法求下图中从顶点 1 到其他各顶点的最短路径，依次得到的各最短路径的目标顶点是   @https://uploadfiles.nowcoder.com/images/20200927/330909_1601175203945_18FA6575100A6357E9281E9AF677B2A8@ ",
        "answers": {
          "RightAnswer": "B",
          "A": "5, 2, 3, 4, 6",
          "B": "5, 2, 3, 6, 4",
          "C": "5, 2, 4, 3, 6 ",
          "D": "5, 2, 6, 3, 4"
        },
        "review": [
          {
            "detail": "\n                                                                    设已求出最短路的顶点集合为S,未求出最短路的顶点集合为U｡按最短路递增次序依次将U中顶点加入到S。在加入过程中保持从原点到S各顶点最短路径长度不大于到U中各顶点最短路径长度。\n                                                            "
          }
        ]
      },
      {
        "id": 9,
        "select": true,
        "detail": "  在有 n（n＞1000）个元素的升序数组 A 中查找关键字 x。查找算法的伪代码如下所示    k=0; while(k<n 且 A[k]<x) k=k+3; if(k<n 且 A[k]==x) 查找成功; else if(k-1<n 且 A[k-1]==x) 查找成功;         else if(k-2=n 且 A[k-2]==x) 查找成功;                 else 查找失败;       本算法与折半查找算法相比，有可能具有更少比较次数的情形是     ",
        "answers": {
          "RightAnswer": "B",
          "A": "当 x 不在数组中",
          "B": "当 x 接近数组开头处",
          "C": "当 x 接近数组结尾处",
          "D": "当 x 位于数组中间位置"
        },
        "review": []
      },
      {
        "id": 10,
        "select": true,
        "detail": "B+树不同于 B 树的特点之一是",
        "answers": {
          "RightAnswer": "A",
          "A": "能支持顺序查找",
          "B": "结点中含有关键字",
          "C": "根结点至少有两个分支",
          "D": "所有叶结点都在同一层上"
        },
        "review": []
      },
      {
        "id": 11,
        "select": true,
        "detail": "对 10TB 的数据文件进行排序，应使用的方法是",
        "answers": {
          "RightAnswer": "D",
          "A": "希尔排序",
          "B": "堆排序",
          "C": "快速排序",
          "D": "归并排序"
        },
        "review": [
          {
            "detail": "\n你们 \n"
          }
        ]
      },
      {
        "id": 12,
        "select": true,
        "detail": "将高级语言源程序转换为机器级目标代码文件的程序是",
        "answers": {
          "RightAnswer": "C",
          "A": "汇编程序",
          "B": "链接程序",
          "C": "编译程序",
          "D": "解释程序"
        },
        "review": [
          {
            "detail": "\n                                                                    C\n                                                            "
          }
        ]
      },
      {
        "id": 13,
        "select": true,
        "detail": "  有如下 C 语言程序段    short si = -32767;    unsigned short usi = si;    执行上述两条语句后，usi 的值为 ",
        "answers": {
          "RightAnswer": "D",
          "A": "-32767",
          "B": "32767",
          "C": "32768",
          "D": "32769"
        },
        "review": [
          {
            "detail": "\n  -32767的原码用二进制表示为 1111 1111 1111 1111   (@https://www.nowcoder.com/equation?tex=2%5E%7B15%7D%20-%201@)   ,用机器码表示 则为 1000 0000 0000 0001，将该值赋给无符号型short ，那么usi的机器码就是1000 0000 0000 0001，最高位的1不再代表符号位，对应的数值就是@https://www.nowcoder.com/equation?tex=2%5E%7B15%7D%20%2B%201@    = 35768 + 1 =35769 \n"
          },
          {
            "detail": "\n                                                                    short为16位，C语言中的数据在内存中为补码表示形式，si对应的补码二进制形式表示为1000 0000 0000 0001B，最前面的一位“1”为符号位，表示负数，即－32767。由signed型转化为等长的unsigned型数据时，符号位成为数据的一部分，即负数转化为无符号树数（即正数）时，其数值将发生变化。usi对应的补码二进制表示与si的表示相同，但表示正数，为32769\n                                                            "
          }
        ]
      },
      {
        "id": 14,
        "select": true,
        "detail": "某计算机字长为 32 位，按字节编址，采用小端（Little Endian）方式存放数据。假定有一个 double 型变量， 其机器数表示为 1122 3344 5566 7788H，存放在 0000 8040H 开始的连续存储单元中，则存储单元 0000 8046H 中存放的是",
        "answers": {
          "RightAnswer": "A",
          "A": "22H",
          "B": "33H",
          "C": "66H",
          "D": "77H"
        },
        "review": [
          {
            "detail": "\n  因为是小端对齐方式，故低字节放到低地址，高字节放到高地址；   88H为最低字节，存放在 0000 8040H 地址中   0000 8046H-0000 8040H=6H=6   所以对应0000 8046H存放的为22H     \n"
          }
        ]
      },
      {
        "id": 15,
        "select": true,
        "detail": "  有如下 C 语言程序段：    for(k=0; k<1000; k++)             a[k] = a[k]+32;    若数组 a 及变量 k 均为 int 型，int 型数据占 4B，数据 Cache 采用直接映射方式，数据区大小为 1KB、块大小为 16B， 该程序段执行前 Cache 为空，则该程序段执行过程中访问数组 a 的 Cache 缺失率约为     ",
        "answers": {
          "RightAnswer": "C",
          "A": "1.25%",
          "B": "2.5%",
          "C": "12.5% ",
          "D": "25%"
        },
        "review": [
          {
            "detail": "\n                                                                    每块可以放4个数据。读取的时候4次未命中一次，存入结果的时候4次均命中。故答案为1/8\n                                                            "
          },
          {
            "detail": "\n                                                                    a[k]的访问步骤是：先访问cache，cache缺失，之后从主存中取出一个块调入cache，这个块中的后几个数据都是命中的，本题中一个数据占4B，一个块大小是16B，这说明一个块中有4个数据，关键是后面还有一次写，这说明一次循环要八次访问cache，其中只有第一次是缺失的，后面七次都是命中的，所以缺失率是12.5%；     \n"
          }
        ]
      },
      {
        "id": 16,
        "select": true,
        "detail": "某存储器容量为 64KB，按字节编址，地址 4000H~5FFFH 位 ROM 区，其余为 RAM 区。若采用 8K×4 位的 SRAM 芯片进行设计，则需要该芯片的数量是",
        "answers": {
          "RightAnswer": "C",
          "A": "7",
          "B": "8",
          "C": "14",
          "D": "16"
        },
        "review": [
          {
            "detail": "\n 5FFFH -4000H= 1fff = 111  11   1111   1111 =8KB    64KB-8KB = 56KB   56KB / 8KB =7 片8kB   7 * 2=14 片 8k*4bit \n"
          }
        ]
      },
      {
        "id": 17,
        "select": true,
        "detail": "  某指令格式如下所示。   @https://uploadfiles.nowcoder.com/images/20200927/330909_1601175695774_6479C5E2EFFD85A8D059B3AFA3AE1F61@    其中 M 为寻址方式，I 为变址寄存器编号，D 为形式地址。若采用先变址后间址的寻址方式，则操作数的有效地址是 ",
        "answers": {
          "RightAnswer": "C",
          "A": "I+D",
          "B": "(I)+D",
          "C": "((I)+D)",
          "D": "((I))+D"
        },
        "review": []
      },
      {
        "id": 18,
        "select": true,
        "detail": "某计算机主存空间为 4GB，字长为 32 位，按字节编址，采用 32 位字长指令字格式。若指令按字边界对齐存 放，则程序计数器（PC）和指令寄存器（IR）的位数至少分别是",
        "answers": {
          "RightAnswer": "B",
          "A": "30、30",
          "B": "30、32",
          "C": "32、30",
          "D": "32、32"
        },
        "review": [
          {
            "detail": "\n  指令寄存器 32 位    PC 这里只需要定位到有多少条指令即可 @https://www.nowcoder.com/equation?tex=%5Cfrac%7B4GB%7D%7B4B%7D%3D2%5E%7B30%7D@，因此只需要30位 \n"
          },
          {
            "detail": "\n  题目给定按边界对齐存放指令，并且问至少多少位。    指令IR：32位    PC：30位 每次定位一条指令，并且指令按边界对齐存放，因此无需定位到每个字节。只需定位字即可。 \n"
          },
          {
            "detail": "\n 机器字长32，若指令按字边界对齐存放，就是一个字里面只有一条指令。如果没有这句话，指令就可能在两个字里面，这时pc要定位到 每个字节上了。     \n"
          }
        ]
      },
      {
        "id": 19,
        "select": true,
        "detail": "  在无转发机制的五段基本流水线（取指、译码/读寄存器、运算、访写回寄存器）中，下列指令序列存在数据冒险的指令对是   I1：add R1，R2，R3；（R2）+（R3）→R1    I2：add R5，R2，R4；（R2）+（R4）→R5    I3：add R4，R5，R3；（R5）+（R3）→R4     I4：add R5，R2，R6；（R2）+（R6）→R5 ",
        "answers": {
          "RightAnswer": "B",
          "A": "I1 和 I2",
          "B": "I2 和 I3",
          "C": "I2 和 I4",
          "D": "I3 和 I4"
        },
        "review": [
          {
            "detail": "\n                                                                    I2写R5，I3读R5，存在数据冒险\n                                                            "
          }
        ]
      },
      {
        "id": 20,
        "select": true,
        "detail": "单周期处理器中所有指令的指令周期为一个时钟周期。下列关于单周期处理器的叙述中，错误的是",
        "answers": {
          "RightAnswer": "A",
          "A": "可以采用单总线结构数据通路",
          "B": "处理器时钟频率较低",
          "C": "在指令执行过程中控制信号不变",
          "D": "每条指令的 CPI 位 1"
        },
        "review": [
          {
            "detail": "\n                                                                    单周期cpu一个时钟处理完取指令，寻址等操作，有多种类型数据，而单总线一个时钟只能传输一类数据\n                                                            "
          },
          {
            "detail": "\n  A单周期一个时钟周期完成取指令，执行指令。而单总线结构的数据通路一个指令周期分为多个机器周期，例如取指令周期，一个机器周期分为多个时钟周期 \n"
          }
        ]
      },
      {
        "id": 21,
        "select": true,
        "detail": "下列关于总线设计的叙述中，错误的是",
        "answers": {
          "RightAnswer": "A",
          "A": "并行总线传输比串行总线传输速度快",
          "B": "采用信号线复用技术可减少信号线数量",
          "C": "采用突发传输方式可提高总线数据传输率",
          "D": "采用分离事务通信方式可提高总线利用率"
        },
        "review": []
      },
      {
        "id": 22,
        "select": true,
        "detail": "异常是指令执行过程中在处理器内部发生的特殊事件，中断是来自处理器外部的请求事件。下列关于中断或 异常情况的叙述中，错误的是 ",
        "answers": {
          "RightAnswer": "A",
          "A": "“访存时缺页”属于中断",
          "B": "“整数除以 0”属于异常",
          "C": "“DMA 传送结束”属于中断",
          "D": "“存储保护错”属于异常"
        },
        "review": []
      },
      {
        "id": 23,
        "select": true,
        "detail": "  下列关于批处理系统的叙述中，正确的是    I．批处理系统允许多个用户与计算机直接交互     II．批处理系统分为单道批处理系统和多道批处理系统     III．中断技术使得多道批处理系统和 I/O 设备可与 CPU 并行工作 ",
        "answers": {
          "RightAnswer": "A",
          "A": "仅 II、III",
          "B": "仅 II",
          "C": "仅 I、II",
          "D": "仅 I、III"
        },
        "review": []
      },
      {
        "id": 24,
        "select": true,
        "detail": "某单 CPU 系统中有输入和输出设备各 1 台，现有 3 个并发执行的作业，每个作业的输入、计算和输出时间均 分别为 2ms、3ms 和 4ms，且都按输入、计算和输出的顺序执行，则执行完 3 个作业需要的时间最少是",
        "answers": {
          "RightAnswer": "B",
          "A": "15ms",
          "B": "17ms",
          "C": "22ms",
          "D": "27ms"
        },
        "review": []
      },
      {
        "id": 25,
        "select": true,
        "detail": "系统中有 3 个不同的临界资源 R1、R2 和 R3，被 4 个进程 p1、p2、p3 及 p4 共享。各进程对资源的需求为： p1 申请 R1 和 R2，p2 申请 R2 和 R3，p3 申请 R1 和 R3，p4 申请 R2。若系统出现死锁，则处于死锁状态的进程数至少是",
        "answers": {
          "RightAnswer": "C",
          "A": "1",
          "B": "2",
          "C": "3",
          "D": "4"
        },
        "review": [
          {
            "detail": "\nhttps://www.jianshu.com/p/d7cbc32165b4\n"
          },
          {
            "detail": "\n                                                                    出现死锁的条件，循环等待，也就是说要出现死锁必须位于一个环上，没有位于环上的点不用考虑\n                                                            "
          }
        ]
      },
      {
        "id": 26,
        "select": true,
        "detail": "某系统采用改进型 CLOCK 置换算法，页表项中字段 A 为访问位，M 为修改位。A=0 表示页每页被修改过， M=1 表示页被修改过。按（A，M）所有可能的取值，将页分为四类：（0，0）、（1，0）、（0，1）和（1，1），则该算法淘汰页的次序为",
        "answers": {
          "RightAnswer": "A",
          "A": "（0，0），（0，1），（1，0），（1，1）",
          "B": "（0，0），（1，0），（0，1），（1，1）",
          "C": "（0，0），（0，1），（1，1），（1，0）",
          "D": "（0，0），（1，1），（0，1），（1，0）"
        },
        "review": []
      },
      {
        "id": 27,
        "select": true,
        "detail": "  使用 TSL（Test and Set Lock）指令实现进程互斥的伪代码如下所示。   @https://uploadfiles.nowcoder.com/images/20200927/330909_1601176245830_0F2EC7F825BB0F6ED8880CA3D736C2E9@       下列与该实现机制相关的叙述中，正确的是    ",
        "answers": {
          "RightAnswer": "B",
          "A": "退出临界区的进程负责唤醒阻塞态进程",
          "B": "等待进入临界区的进程不会主动放弃 CPU",
          "C": "上述伪代码满足“让权等待”的同步准则",
          "D": "while(TSL(&lock))语句应在关中断状态下执行"
        },
        "review": []
      },
      {
        "id": 28,
        "select": true,
        "detail": "  某进程的段表内容如下所示   @https://uploadfiles.nowcoder.com/images/20200927/330909_1601176289249_9B73989C11728907C9231D4FA4E99B1C@       当访问段号为 2、段内地址为 400 的逻辑地址时，进行地址转换的结果是 ",
        "answers": {
          "RightAnswer": "D",
          "A": "段缺失异常",
          "B": "得到内存地址 4400",
          "C": "越权异常 ",
          "D": "越界异常"
        },
        "review": [
          {
            "detail": "\n                                                                    访问段号2，找到基址为4000，段长为300的段，段内地址为400>300,产生越界异常\n                                                            "
          }
        ]
      },
      {
        "id": 29,
        "select": true,
        "detail": "  某进程访问页面的序列如下所示。   @https://uploadfiles.nowcoder.com/images/20200927/330909_1601176337225_8856560EC04C7724BDE397B8EEBC358C@       若工作集的窗口大小为 6，则在 t 时刻的工作集为 ",
        "answers": {
          "RightAnswer": "A",
          "A": "{6, 0, 3, 2}",
          "B": "{2, 3, 0, 4}",
          "C": "{0, 4, 3, 2, 9}",
          "D": "{4, 5, 6, 0, 3, 2}"
        },
        "review": []
      },
      {
        "id": 30,
        "select": true,
        "detail": "  进程 P1 和 P2 均包含并发执行的线程，部分伪代码描述如下所示   @https://uploadfiles.nowcoder.com/images/20200927/330909_1601176382036_341BDFF458178790F2708DF548902E3F@       下列选项中，需要互斥执行的操作是    ",
        "answers": {
          "RightAnswer": "C",
          "A": "a =1 与 a = 2",
          "B": "a = x 与 b = x",
          "C": "x += 1 与 x += 2",
          "D": "x += 1 与 x += 3"
        },
        "review": [
          {
            "detail": "\n                                                                    同一进程内的两个线程会并发执行，而x是P1进程的全局变量，线程一和线程二需要互斥访问，则C正确。\n                                                            "
          }
        ]
      },
      {
        "id": 31,
        "select": true,
        "detail": "下列关于 SPOOLing 技术的叙述中，错误的是",
        "answers": {
          "RightAnswer": "D",
          "A": "需要外存的支持",
          "B": "需要多道程序设计技术的支持",
          "C": "可以让多个作业共享一台独占设备",
          "D": "由用户作业控制设备与输入/输出井之间的数据传送"
        },
        "review": []
      },
      {
        "id": 32,
        "select": true,
        "detail": "下列关于管程的叙述中，错误的是 ",
        "answers": {
          "RightAnswer": "A",
          "A": "管程只能用于实现进程的互斥",
          "B": "管程是由编程语言支持的进程同步机制",
          "C": "任何时候只能有一个进程在管程中执行",
          "D": "管程中定义的变量只能被管程内的过程访问"
        },
        "review": []
      },
      {
        "id": 33,
        "select": true,
        "detail": "33-1",
        "answers": {
          "RightAnswer": "C",
          "A": "2、2、1",
          "B": "2、2、2",
          "C": "3、2、1",
          "D": "3、2、2"
        },
        "review": [
          {
            "detail": "\n  C    集线器是一个多端口的中继器，工作在物理层。以太网交换机是一个多端口的网桥，工作在数据链路层。路由器是网络层设备，它实现了网络模型的下三层，即物理层、数据链路层和网络层。题中Rl、 Switch和Hub分别是路由器、交换机和集线器，实现的最高层功能分别是络层(即3)、数据链路层(即2)和物理层(即1) \n"
          }
        ]
      },
      {
        "id": 34,
        "select": true,
        "detail": "33-2",
        "answers": {
          "RightAnswer": "C",
          "A": "8kbps",
          "B": "20kbps",
          "C": "40kbps",
          "D": "80kbps"
        },
        "review": []
      },
      {
        "id": 35,
        "select": true,
        "detail": "33-3",
        "answers": {
          "RightAnswer": "D",
          "A": "仅 H2 ",
          "B": "仅 H3 ",
          "C": "仅 H1、H2",
          "D": "仅 H2、H3"
        },
        "review": []
      },
      {
        "id": 36,
        "select": true,
        "detail": "33-4",
        "answers": {
          "RightAnswer": "B",
          "A": "200m",
          "B": "205m",
          "C": "359m",
          "D": "512m"
        },
        "review": [
          {
            "detail": "\n 复制一个答案：    从题图可知，Hub为100Base-T集线器，也就是传输速率为100Mb/s。    以太网规定最短帧长为64B（规定最短帧长的目的在于使得处于以太网两端的主机可以检测到所发送的帧是否遭遇了碰撞），对于100Mb/s的以太网，其争用期为 (8b × 64) ÷ 100Mb/s = 5.12μs（考生应当熟记该值），这包括以太网端到端的信号传播往返时延RTT和Hub所产生的时延。因此，以太网端到端的单程信号传播时延为 5.12μs ÷ 2 – 1.535μs = 1.025μs，从而H3与H4之间理论上可以相距的最远距离为 200m/μs × 1.025μs = 205m \n"
          }
        ]
      },
      {
        "id": 37,
        "select": true,
        "detail": "33-5",
        "answers": {
          "RightAnswer": "B",
          "A": "2",
          "B": "3",
          "C": "16",
          "D": "17"
        },
        "review": []
      },
      {
        "id": 38,
        "select": true,
        "detail": "33-6",
        "answers": {
          "RightAnswer": "D",
          "A": "192.168.3.251，130.18.10.1",
          "B": "192.168.3.251，201.1.3.9",
          "C": "201.1.3.8，130.18.10.1",
          "D": "201.1.3.10，130.18.10.1"
        },
        "review": [
          {
            "detail": "\n                                                                    为什么源ip地址不是192.168.3.251啊？不是说在转发IP数据报时只重新封装mac地址吗\n                                                            "
          },
          {
            "detail": "\n                                                                    注意，192.168开头是c类私有地址，所以需要net路由器转换源地址，另外同一链路属于同一网段，不同网段由路由器隔开。同一网段的网络号相同\n                                                            "
          }
        ]
      },
      {
        "id": 39,
        "select": true,
        "detail": "33-7",
        "answers": {
          "RightAnswer": "C",
          "A": "H1 不能与 H2 进行正常 IP 通信",
          "B": "H2 与 H4 均不能访问 Internet",
          "C": "H1 不能与 H3 进行正常 IP 通信",
          "D": "H3 不能与 H4 进行正常 IP 通信"
        },
        "review": []
      },
      {
        "id": 40,
        "select": true,
        "detail": "33-8",
        "answers": {
          "RightAnswer": "C",
          "A": "0，3",
          "B": "1，3",
          "C": "0，4",
          "D": "1，4"
        },
        "review": [
          {
            "detail": "\n  选择C。    最少是 0 次，是指如果本机的 DNS 缓存中有，那么就不同发送 DNS 请求，注意是本机，不是本地域名服务器。       最多的 4 次，分别是主机-本地域名服务器，本地域名服务器-根域名服务器，本地域名服务器-顶级域名服务器，顶级域名服务器-权限域名服务器。 \n"
          }
        ]
      },
      {
        "id": 41,
        "select": false,
        "detail": " @https://uploadfiles.nowcoder.com/images/20200927/330909_1601176946002_5934EFF1085079B5E452A670C4ED5224?x-oss-process=image/resize,p_90@       41．假设题 33~41 图中的 H3 访问 Web 服务器 S 时，S 为新建的 TCP 连接分配了 20KB（K=1024）的接收缓存， 最大段长 MSS=1KB，平均往返时间 RTT=200ms。H3 建立连接时的初始序号为 100，且持续以 MSS 大小的段向 S 发送 数据，拥塞窗口初始阈值为 32KB；S 对收到的每个段进行确认，并通告新的接收窗口。假定 TCP 连接建立完成后，S 端的 TCP 接收缓存仅有数据存入而无数据取出。请回答下列问题。     （1）在TCP 连接建立过程中，H3 收到的 S 发送过来的第二次握手 TCP 段的 SYN 和 ACK 标志位的值分别是多少？ 确认序号是多少？     （2）H3 收到的第 8 个确认段所通告的接收窗口是多少？此时 H3 的拥塞窗口变为多少？H3 的发送窗口变为多少？     （3）当 H3 的发送窗口等于 0 时，下一个待发送的数据段序号是多少？H3 从发送第 1 个数据段到发送窗口等于 0 时刻为止，平均数据传输速率是多少（忽略段的传输延时）？     （4）若 H3 与 S 之间通信已经结束，在 t 时刻 H3 请求断开该连接，则从 t 时刻起，S 释放该连接的最短时间是多少？ ",
        "answers": {
          "detail": "\n  解析：     （1）TCP连接的建立分以下三个阶段。首先，H3向Web服务器S发出连接请求报文段，这时首部中的同步位SYN=1， ACK=0，同时选择一个初始序号 seq=100。TCP 规定，SYN 报文段（即 SYN=1 的报文段）不能携带数据，但是要消耗 一个序号。接着，S 收到连接请求报文段，为自己选择一个初始序号 seq=y，向 A 发送确认。这个报文段 SYN=1，ACK=1， seq=y，确认号 ack 是 100+1=101。它不能携带数据，但是也要消耗一个序号。最后，H3 收到 S 的确认报文段后，还要 向 S 给出确认。这份确认报文段 SYN=0，ACK=1，确认号 ack=y+1，自己的序号 seq=101。因此，第二次握手 TCP 段 的 SYN=1，（1 分）ACK=1；（1 分）确认序号是 101。（1 分）        （2）题目规定 S 对收到的每个段（MSS 大小的段）进行确认，并通告新的接收窗口，而且 TCP 接收缓存仅有数据 存入而无数据取出。H3 收到的第 8 个确认段所通告的接收窗口是 20-8=12KB；（1 分）在慢开始算法里，发送方 H3 先 设置拥塞窗口 cwnd=1KB，接下来每收到一个对新报文段的确认就使发送方的拥塞窗口加 1KB。H3 共收到 8 个确认段， 所以此时 H3 的拥塞窗口变为 1+8=9KB；（1 分）发送窗口=min{拥塞窗口，接收窗口}，所以 H3 的发送窗口变为 min{9， 12}=9KB。（1 分）        （3）TCP 是用字节作为窗口和序号的单位。当 H3 的发送窗口等于 0KB 时，也就是接收窗口等于 0KB 时，下一个 待发送段的序号是 20K+101=20×1024+101=20581；（1 分）H3 从发送第 1 个段到发送窗口等于 0KB 时刻为止，经过五 个传输轮次，每个传输轮次的时间就是往返 RTT，因此平均数据传输速率是 20KB/(5×200ms)=20KB/s=20.48kbps。（1 分）        （4）通信结束后，H3 向 S 发送连接释放报文段。S 收到 H3 的连接释放报文段后，马上发出确认报文段。此时 S 已经没有数据需要传输，于是它也马上发出连接释放报文段。H3 在收到 S 的连接释放报文段后，发出确认报文段。S 在收到这份确认后就释放 TCP 连接。因此从 t 时刻起，S 释放该连接的最短时间是：H3 的连接释放报文段传送到 S 的 时间+S 的连接释放报文段传送到 H3 的时间+H3 的确认报文段传送到 S 的时间=1.5×200ms=300ms。（1 分） \n"
        },
        "review": []
      },
      {
        "id": 42,
        "select": false,
        "detail": "  如果一棵非空 k（k≥2）叉树 T 中每个非叶结点都有 k 个孩子，则称 T 为正则 k 叉树。请回答下列问题并给出推导过程。     （1）若 T 有 m 个非叶结点，则 T 中的叶结点有多少个？     （2）若 T 的高度为 h（单结点的树 h=1），则 T 的结点数最多为多少个？最少为多少个？ ",
        "answers": {
          "detail": "\n  （1）根据定义，正则 k 叉树中仅含有两类结点；叶结点（个数记为 n0）和度为 k 的分支结点（个数记为 n1）。树 T 中的结点总数n=n0+nk=n0+m。树中所含的边数e=n-1，这些边均为m个度为k的结点发出的，即e=m×k。整理得：n0+m=m ×k+1，故 n0=（k-1）×m+1。（3 分）       （2）高度为 h 的正则 k 叉树 T 中，含最多结点的树形为：除第 h 层外，第 1 到第 h-1 层的结点都是度为 k 的分支 结点；而第 h 层均为叶结点，即树是“满”树。此时第 j（1≤j≤h）层结点数为 k j-1，结点总数 M1为：   @https://uploadfiles.nowcoder.com/images/20200927/330909_1601177124755_0A1EC1F3E0468CDEE2C62ABF9742BAB8@          含最少结点的正则 k 叉树的树形为：第 1 层只有根结点，第 2 到第 h-1 层仅含 1 个分支结点和 k-1 个叶结点，第 h 层有 k 个叶结点。即除根外第 2 到第 h 层中每层的结点数均为 k，故 T 中所含结点总数 M2 为： M2=1+(h-1)×k （2 分）          【评分说明】 ①参考答案仅给出一种推导过程，若考生采用其他推导方法且正确，同样给分。②若考生仅给出结果，但没有推 导过程，则（1）、（2）的最高得分分别是 2 分和 3 分。若推导过程或答案不完全正确，酌情给分。 \n"
        },
        "review": [
          {
            "detail": "\n（1）1.全部节点个数 = 叶子节点个数 + 非叶子节点个数 （“常识”）2.树枝个数（即边数） = 全部节点个数 - 1（树的性质）3.树枝个数 = 全部节点的度数之和（不知道的可以画个图，这好像也是性质）4.全部节点的度数之和 = 度数为k的节点个数 * k + 度数为k-1的节点个数 * k-1 + …… +度数为0的节点个数 * 0 = 度数为k的节点个数 * k + 度数为0的节点个数 * 0 =  度数为k的节点个数 * k = 非叶子节点个数 * k（正则K叉树的定义）由以上四个等式就能求出来叶子节点的个数为(k-1)m+1（2）最多：@https://uploadfiles.nowcoder.com/images/20210101/51419423_1609506127041/8A5F006FFD4CE801C8E888EC3BC68361@第一层数量：1；第二层数量：k；第三层树林里：k^2；……，等比数列，最终得到(1-k^h)/(1-k)最少：@https://uploadfiles.nowcoder.com/images/20210101/51419423_1609506330308/8A5F006FFD4CE801C8E888EC3BC68361@除了第一层之外，每一层都是k个，最终得到k(h-1)+1拙劣滑稽，大佬轻喷\n"
          }
        ]
      },
      {
        "id": 43,
        "select": false,
        "detail": "  已知由 n（n≥2）个正整数构成的集合 A={ak|0≤k＜n}，将其划分为两个不相交的子集 A1和 A2，元素个数分 别是 n1和 n2，A1和 A2中元素之和分别为 S1和 S2。设计一个尽可能高效的划分算法，满足|n1-n2|最小且|S1-S2|最大。要求：     （1）给出算法的基本设计思想。     （2）根据设计思想，采用 C 或 C++语言描述算法，关键之处给出注释。     （3）说明你所设计算法的平均时间复杂度和空间复杂度。 ",
        "answers": {
          "detail": "\n @https://uploadfiles.nowcoder.com/images/20200927/330909_1601177223258_FFC9ED840D55E7965AB3D7428C6E49E5@            @https://uploadfiles.nowcoder.com/images/20200927/330909_1601177247348_A56BA6F19AADE57C5F3200FBB586E635@      @https://uploadfiles.nowcoder.com/images/20200927/330909_1601177276387_04B0CBB44CF185350D7792AF2E052C96@ \n"
        },
        "review": [
          {
            "detail": "\nint quick_part(int A[],int n)\n{\n    int i=0,j=n-1,part=A[i],temp=0,i_0=i,j_0=j,sum=0;\n    while(1)\n    {\n        while(i<j)\n        {\n            while(A[j]>part)j--;\n            while(A[i]<part)i++;\n            temp=A[j];\n            A[j]=A[i];\n            A[i]=temp;\n        }\n        A[i]=part;\n        if(i==n/2)break;\n        if(i>n/2)\n        {\n            j=i-1;\n            i=i_0;\n            j_0=j;\n            i_0=i;\n        }\n        else\n        {\n            i=i+1;\n            j=j_0;\n            j_0=j;\n            i_0=i;\n        }\n    }\n    for(j=i;j<n;j++)\n        {\n            sum=sum+A[j];\n        }\n       for(j=0;j<i;j++)\n        {\n            sum=sum-A[j];\n        }\n        return sum;  \n} \n"
          }
        ]
      },
      {
        "id": 44,
        "select": false,
        "detail": "  假定 CPU 主频为 50MHz，CPI 为 4。设备 D 采用异步串行通信方式向主机传送 7 位 ASCII 字符，通信规程中 有 1 位奇校验位和 1 位停止位，从 D 接收启动命令到字符送入 I/O 端口需要 0.5ms。请回答下列问题，要求说明理由。     （1）每传送一个字符，在异步串行通信线上共需传输多少位？在设备 D 持续工作过程中，每秒钟最多可向 I/O 端 口送入多少个字符？     （2）设备 D 采用中断方式进行输入/输出，示意图如下：   @https://uploadfiles.nowcoder.com/images/20200927/330909_1601177463055_48F4B6173D79C2B0D04B973C29A582D3@       I/O 端口每收到一个字符申请一次中断，中断响应需 10 个时钟周期，中断服务程序共有 20 条指令，其中第 15 条 指令启动 D 工作。若 CPU 需从 D 读取 1000 个字符，则完成这一任务所需时间大约是多少个时钟周期？CPU 用于完成 这一任务的时间大约是多少个时钟周期？在中断响应阶段 CPU 进行了哪些操作？ ",
        "answers": {
          "detail": "\n  解析：     （1）每传送一个 ASCII 字符，需要传输的位数有 1 位起始位、7 位数据位（ASCII 字符占 7 位）、1 位奇校验位和 1 位停止位，故总位数为 1+7+1+1=10。（2 分） I/O 端口每秒钟最多可接收 1000/0.5=2000 个字符。（1 分）     【评分说明】对于第一问，若考生回答总位数为 9，则给 1 分。        （2）一个字符传送时间包括：设备 D 将字符送 I/O 端口的时间、中断响应时间和中断服务程序前 15 条指令的执行 时间。时钟周期为 1/(50MHz)=20ns，设备 D 将字符送 I/O 端口的时间为 0.5ms/20ns=2.5×104个时钟周期。一个字符的 传送时间大约为 2.5×104 +10+15×4=25070 个时钟周期。完成 1000 个字符传送所需时间大约为 1000×25070=25070000 个时钟周期。（3 分） CPU 用于该任务的时间大约为 1000×(10+20×4)= 9×104个时钟周期。（1 分） 在中断响应阶段，CPU 主要进行以下操作：关中断、保护断点和程序状态、识别中断源。（2 分）    【评分说明】 ①位于第一问，若答案是 25070020，则同样给分；若答案是 25000000 或 25000020，则给 2 分。如果没有给出分 布计算步骤，但算式和结果正确，同样给分。 ②对于第三问，只要回答关中断和保护断点，就给 2 分，其他答案酌情给分。 \n"
        },
        "review": []
      },
      {
        "id": 45,
        "select": false,
        "detail": "  某计算机采用页式虚拟存储管理方式，按字节编址，虚拟地址为 32 位，物理地址为 24 位，页大小为 8KB； TLB 采用全相联映射；Cache 数据区大小为 64KB，按 2 路组相联方式组织，主存块大小为 64B。存储访问过程的示意图如下   @https://uploadfiles.nowcoder.com/images/20200927/330909_1601177570528_61145FD2E809770937A2552B8C2E71EE@       请回答下列问题。     （1）图中字段 A~G 的位数各是多少？TLB 标记字段 B 中存放的是什么信息？     （2）将块号为 4099 的主存块装入到 Cache 中时，所映射的 Cache 组号是多少？对应的 H 字段内容是什么？     （3）Cache 缺失处理的时间开销大还是缺页处理的时间开销大？为什么？ ",
        "answers": {
          "detail": "\n  解析：     （1）页大小为 8KB，页内偏移地址为 13 位，故 A=B=32-13=19；D=13；C=24-13=11；主存块大小为 64B，故 G=6。 2 路组相联，每组数据区容量有 64B×2=128B，共有 64KB/128B=512 组，故 F=9；E=24-G-F=24-6-9=9。 因而 A=19，B=19，C=11，D=13，E=9，F=9，G=6。（各 1 分，共 7 分） TLB 中标记字段 B 的内容是虚页号，表示该 TLB 项对应哪个虚页的页表项。（1 分）        （2）块号 4099=00 0001 0000 0000 0011B，因此，所映射的 Cache 组号为 0 0000 0011B=3，（1 分）对应的 H 字段 内容为 0 0000 1000B。（1 分）        （3）Cache 缺失带来的开销小，而处理缺页的开销大。（1 分）因为缺页处理需要访问磁盘，而 Cache 缺失只要访 问主存。（1 分） 【评分说明】对于（3）中第 2 问，若考生回答因为缺页需要软件实现而 Cache 缺失用硬件实现，则同样给分。        （4）因为采用直写策略时需要同时写快速存储器和慢速存储器，而写磁盘比写主存慢很多，所以，在 Cache-主存 层次，Cache 可以采用直写策略，而在主存-外存（磁盘）层次，修改页面内容时总是采用回写策略。（2 分） \n"
        },
        "review": []
      },
      {
        "id": 46,
        "select": false,
        "detail": "  某进程调度程序采用基于优先数（priority）的调度策略，即选择优先数最小的进程运行，进程创建时由用户 指定一个 nice 作为静态优先数。为了动态调整优先数，引入运行时间 cpuTime 和等待时间 waitTime，初值均为 0。进程处于执行态时，cpuTime 定时加 1，且 waitTime 置 0；进程处于就绪态时，cpuTime 置 0，waitTime 定时加 1。请回答下列问题。     （1）若调度程序只将 nice 的值作为进程的优先数，即 priority=nice，则可能会出现饥饿现象，为什么？     （2）使用 nice、cpuTime 和 waitTime 设计一种动态优先数计算方法，以避免产生饥饿现象，并说明 waitTime 的作 用。 ",
        "answers": {
          "detail": "\n  解析：     （1）由于采用了静态优先数，当就绪队列中总有优先数较小的进程时，优先数较大的进程一直没有机会运行，因 而会出现饥饿现象。（2 分）        （2）优先数 priority 的计算公式为：    priority=nice+k1×cpuTime-k2×waitTime，其中 k1＞0，k2＞0，用来分别调整 cpuTime 和 waitTime 在 priority 中所占的比例。（3 分）waitTime 可使长时间等待的进程优先数减少，从而避免出现饥饿现象。（1 分）       【评分说明】     ①公式中包含 nice 给 1 分，利用 cpuTime 增大优先数给 1 分，利用 waitTime 减少优先数给 1 分；部分正确，酌情 给分。     ②若考生给出包含 nice、cpuTime 和 waitTime 的其他合理的优先数计算方法，同样给分。 \n"
        },
        "review": [
          {
            "detail": "\n  (1)由于采用了静态优先数，当就绪队列中总有优先数较小的进程时，优先数较大的进程一直 没有机会运行,因而会出现饥饿现象。(2分) (2)优先数priority的计算公式为:priority=rice+k1×cpuTime-k2×waitTime,其中k1>0,k2>0,用来分别调整cpuTime和waitTime在priority中所占的比例·(3分)wait.Time可使长时间等待的进程优先数减小,从而避免出现饥饿现象。(1分) 【评分说明】 ①公式中包含nice给1分,利用cpuTime增大优先数给1分，利用wait Time减少优先数给1分;部分正确,酌情给分。 ②若考生给出包含nice、cpuIime和wait Time的其他合理的优先数计算方法，同样给分。 \n"
          }
        ]
      },
      {
        "id": 47,
        "select": false,
        "detail": "  某磁盘文件系统使用链接分配方式组织文件，簇大小为 4KB。目录文件的每个目录项包括文件名和文件的第 一个簇号，其他簇号存放在文件分配表 FAT 中。     （1）假定目录树如下图所示，各文件占用的簇号及顺序如下表所示，其中 dir、dir1 是目录，file1、file2 是用户文件。请给出所有目录文件的内容。   @https://uploadfiles.nowcoder.com/images/20200927/330909_1601177774999_CDCA646645C8687B555F264881C525AC@       （2）若 FAT 的每个表项仅存放簇号，占 2 个字节，则 FAT 的最大长度为多少字节？该文件系统支持的文件长度最 大是多少？     （3）系统通过目录文件和 FAT 实现对文件的按名存取，说明 file1 的 106、108 两个簇号分别存放在 FAT 的哪个表 项中。     （4）假设仅 FAT 和 dir 目录文件已读入内存，若需将文件 dir/dir1/file1 的第 5000 个字节读入内存，则要访问哪几个簇？ ",
        "answers": {
          "detail": "\n @https://uploadfiles.nowcoder.com/images/20200927/330909_1601177813775_54DE91521EE0150DCCBA5FA91C5479EA@          （2）由于 FAT 的簇号为 2 个字节，即 16 比特，因此在 FAT 表中最多允许 2 16（65536）个表项，一个 FAT 文件最 多包含 2 16（65536）个簇。FAT 的最大长度为 2 16×2B=128KB。（1 分）文件的最大长度是 2 16×4B=256MB。（1 分）     【评分说明】若考生考虑到文件结束标志、坏块标志等，且答案正确，同样给分。       （3）在 FAT 的每个表项中存放下一个簇号。file1 的簇号 106 存放在 FAT 的 100 号表项中，（1 分）簇号 108 存放在 FAT 的 106 号表项中。（1 分）       （4）先在 dir 目录文件里找到 dir1 的簇号，然后读取 48 号簇，得到 dir1 目录文件，接着找到 file1 的第一个簇号， 据此在 FAT 里查找 file1 的第 5000 个字节所在的簇号，最后访问磁盘中的该簇。因此，需要访问目录文件 dir1 所在的 48 号簇，（1 分）及文件 file1 的 106 号簇。（1 分） \n"
        },
        "review": []
      }
    ]
  },
  {
    "title": 2015,
    "testDetail": [
      {
        "id": 1,
        "select": true,
        "detail": "  已知程序如下：  int S(int n)\n{ \n    return (n<=0)?0:s(n-1)+n;\n} \nvoid main()\n{ \n    cout<< S(1);\n} 程序运行时使用栈来保存调用过程的信息，自栈底到栈顶保存的信息依次对应的是 ",
        "answers": {
          "RightAnswer": "A",
          "A": "main()→S(1)→S(0)",
          "B": "S(0)→S(1)→main()",
          "C": "main()→S(0)→S(1) ",
          "D": "S(1)→S(0)→main()"
        },
        "review": []
      },
      {
        "id": 2,
        "select": true,
        "detail": "先序序列为 a,b,c,d 的不同二叉树的个数是",
        "answers": {
          "RightAnswer": "B",
          "A": "13 ",
          "B": "14",
          "C": "15",
          "D": "16"
        },
        "review": []
      },
      {
        "id": 3,
        "select": true,
        "detail": "下列选项给出的是从根分别到达两个叶结点路径上的权值序列，能属于同一棵哈夫曼树的是 ",
        "answers": {
          "RightAnswer": "D",
          "A": "24,10,5 和 24,10,7",
          "B": "24,10,5 和 24,12,7",
          "C": "24,10,10 和 24,14,11",
          "D": "24,10,5 和 24,14,6"
        },
        "review": [
          {
            "detail": "\nhttps://blog.csdn.net/qq_28979491/article/details/100097275?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522162684244016780265451290%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=162684244016780265451290&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~baidu_landing_v2~default-1-100097275.first_rank_v2_pc_rank_v29&utm_term=%E4%B8%8B%E5%88%97%E9%80%89%E9%A1%B9%E7%BB%99%E5%87%BA%E7%9A%84%E6%98%AF%E4%BB%8E%E6%A0%B9%E5%88%86%E5%88%AB%E5%88%B0%E8%BE%BE%E4%B8%A4%E4%B8%AA%E5%8F%B6%E7%BB%93%E7%82%B9%E8%B7%AF%E5%BE%84%E4%B8%8A%E7%9A%84%E6%9D%83%E5%80%BC%E5%BA%8F%E5%88%97%EF%BC%8C%E8%83%BD%E5%B1%9E%E4%BA%8E%E5%90%8C%E4%B8%80%E6%A3%B5%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91%E7%9A%84%E6%98%AF&spm=1018.2226.3001.4187\n                                                            "
          }
        ]
      },
      {
        "id": 4,
        "select": true,
        "detail": "现有一棵无重复关键字的平衡二叉树（AVL 树），对其进行中序遍历可得到一个降序序列。下 列关于该平衡二叉树的叙述中，正确的是",
        "answers": {
          "RightAnswer": "D",
          "A": "根结点的度一定为 2",
          "B": "树中最小元素一定是叶结点",
          "C": "最后插入的元素一定是叶结点 ",
          "D": "树中最大元素一定是无左子树"
        },
        "review": []
      },
      {
        "id": 5,
        "select": true,
        "detail": "设有向图 G=(V,E)，顶点集 V={V0,V1,V2,V3}，边集 E={<v0,v1><v0>，<v0,v2><v0>，<v0,v3><v0>，<v1,v3><v1>}。若 从顶点 V0 开始对图进行深度优先遍历，则可能得到的不同遍历序列个数是</v1></v0></v0></v0>",
        "answers": {
          "RightAnswer": "D",
          "A": "2",
          "B": "3",
          "C": "4",
          "D": "5"
        },
        "review": []
      },
      {
        "id": 6,
        "select": true,
        "detail": "  求下面带权图的最小（代价）生成树时，可能是克鲁斯卡（Kruskal）算法第 2 次选中但不是普 里姆（Prim）算法（从 V4开始）第 2 次选中的边是   @https://uploadfiles.nowcoder.com/images/20200927/330910_1601200243817_3C74CF6FE6FFC727D448D14F4C399873@ ",
        "answers": {
          "RightAnswer": "C",
          "A": "(V1,V3)",
          "B": "(V1,V4)",
          "C": "(V2,V3)",
          "D": "(V3,V4)"
        },
        "review": []
      },
      {
        "id": 7,
        "select": true,
        "detail": "下列选项中，不能构成折半查找中关键字比较序列的是",
        "answers": {
          "RightAnswer": "A",
          "A": "500,200,450,180",
          "B": "500,450,200,180",
          "C": "180,500,200,450",
          "D": "180,200,500,450"
        },
        "review": []
      },
      {
        "id": 8,
        "select": true,
        "detail": "已知字符串 S 为“abaabaabacacaabaabcc”，模式串 t 为“abaabc”。采用 KMP 算法进行匹配，第一 次出现“失配”(s[i]≠t[j]) 时，i=j=5，则下次开始匹配时，i 和 j 的值分别是",
        "answers": {
          "RightAnswer": "C",
          "A": "i=1,j=0",
          "B": "i=5,j=0",
          "C": "i=5,j=2",
          "D": "i=6,j=2"
        },
        "review": []
      },
      {
        "id": 9,
        "select": true,
        "detail": "下列排序算法中，元素的移动次数与关键字的初始排列次序无关的是",
        "answers": {
          "RightAnswer": "C",
          "A": "直接插入排序",
          "B": "冒泡排序",
          "C": "基数排序",
          "D": "快速排序"
        },
        "review": []
      },
      {
        "id": 10,
        "select": true,
        "detail": "已知小根堆为 8,15,10,21,34,16,12，删除关键字 8 之后需重建堆，在此过程中，关键字之间的比较次数是",
        "answers": {
          "RightAnswer": "C",
          "A": "1",
          "B": "2",
          "C": "3",
          "D": "4"
        },
        "review": []
      },
      {
        "id": 11,
        "select": true,
        "detail": "希尔排序的组内排序采用的是",
        "answers": {
          "RightAnswer": "A",
          "A": "直接插入排序 ",
          "B": "折半插入排序",
          "C": "快速排序",
          "D": "归并排序"
        },
        "review": [
          {
            "detail": "\n                                                                    A\n                                                            "
          }
        ]
      },
      {
        "id": 12,
        "select": true,
        "detail": "  计算机硬件能够直接执行的是    Ⅰ．机器语言程序     Ⅱ．汇编语言程序     Ⅲ．硬件描述语言程序 ",
        "answers": {
          "RightAnswer": "A",
          "A": "仅Ⅰ",
          "B": "仅Ⅰ、Ⅱ",
          "C": "仅Ⅰ、Ⅲ",
          "D": "Ⅰ、Ⅱ、Ⅲ"
        },
        "review": [
          {
            "detail": "\n                                                                    <p>计算机能直接执行的只有机器语言，就是二进制的0和1,其它高级语言都要通过编译器编译成机器语言计算机才能执行。</p>\n                                                            "
          }
        ]
      },
      {
        "id": 13,
        "select": true,
        "detail": "由 3 个“1”和 5 个“0”组成的 8 位二进制补码，能表示的最小整数是 ",
        "answers": {
          "RightAnswer": "B",
          "A": "-126 ",
          "B": "-125 ",
          "C": "-32",
          "D": "-3"
        },
        "review": []
      },
      {
        "id": 14,
        "select": true,
        "detail": "  下列有关浮点数加减运算的叙述中，正确的是    Ⅰ. 对阶操作不会引起阶码上溢或下溢     Ⅱ. 右规和尾数舍入都可能引起阶码上溢     Ⅲ. 左规时可能引起阶码下溢     Ⅳ. 尾数溢出时结果不一定溢出 ",
        "answers": {
          "RightAnswer": "D",
          "A": "仅Ⅱ、Ⅲ",
          "B": "仅Ⅰ、Ⅱ、Ⅳ",
          "C": "仅Ⅰ、Ⅲ、Ⅳ ",
          "D": "Ⅰ、Ⅱ、Ⅲ、Ⅳ"
        },
        "review": []
      },
      {
        "id": 15,
        "select": true,
        "detail": "．假定主存地址为 32 位，按字节编址，主存和 Cache 之间采用直接映射方式，主存块大小为 4 个字，每字 32 位，采用回写（Write Back）方式，则能存放 4K 字数据的 Cache 的总容量的位数至少是 ",
        "answers": {
          "RightAnswer": "C",
          "A": "146k",
          "B": "147K",
          "C": "148K",
          "D": "158K"
        },
        "review": [
          {
            "detail": "\n                                                                    一块四个字，一个字32位（4B，所以块内是4*32/8=16B，按字节编地址，块内地址需要4位。4k容量cache，所以cache有1k个快，所以块号占10位。所以标识位就是32-4-10=18位，还有有效位，以及脏位（采用写回法）。所以总容量为4k*32+1k*（18+1+1）=148k\n                                                            "
          }
        ]
      },
      {
        "id": 16,
        "select": true,
        "detail": "假定编译器将赋值语句“x=x+3;”转换为指令”add xaddr, 3”，其中 xaddr 是 x 对应的存储单元地 址。若执行该指令的计算机采用页式虚拟存储管理方式，并配有相应的 TLB，且 Cache 使用直写（Write Through）方式，则完成该指令功能需要访问主存的次数至少是",
        "answers": {
          "RightAnswer": "B",
          "A": "0",
          "B": "1",
          "C": "2",
          "D": "3"
        },
        "review": [
          {
            "detail": "\n  取值，运算，写回：    取指令之后会根据x的地址去内存中取出x的数值。如果指令所在的页位于TLB中，则无需访问内存，直接根据TLB中的实页号去找相应的页；  因为有cache的存在，所以会先访问cache，此时如果要寻找的页位于cache,则无需访问内存，直接在cache中取出x的值； 取出x的值并运算完后，通过写直通法进行写入，因为写直通法是cache和内存一起写入，所以此时必须要访问一次内存，所以答案是1次。 \n"
          }
        ]
      },
      {
        "id": 17,
        "select": true,
        "detail": "下列存储器中，在工作期间需要周期性刷新的是",
        "answers": {
          "RightAnswer": "B",
          "A": "SRAM",
          "B": "SDRAM",
          "C": "ROM",
          "D": "FLASH"
        },
        "review": []
      },
      {
        "id": 18,
        "select": true,
        "detail": "某计算机使用 4 体交叉编址存储器，假定在存储器总线上出现的主存地址（十进制）序列为 8005，8006，8007，8008，8001，8002，8003，8004，8000，则可能发生访存冲突的地址对是",
        "answers": {
          "RightAnswer": "D",
          "A": "8004 和 8008",
          "B": "8002 和 8007",
          "C": "8001 和 8008",
          "D": "8000 和 8004"
        },
        "review": []
      },
      {
        "id": 19,
        "select": true,
        "detail": "下列有关总线定时的叙述中，错误的是",
        "answers": {
          "RightAnswer": "C",
          "A": "异步通信方式中，全互锁协议最慢",
          "B": "异步通信方式中，非互锁协议的可靠性最差",
          "C": "同步通信方式中，同步时钟信号可由各设备提供",
          "D": "半同步通信方式中，握手信号的采样由同步时钟控制"
        },
        "review": []
      },
      {
        "id": 20,
        "select": true,
        "detail": "若磁盘转速为 7200 转/分，平均寻道时间为 8ms,每个磁道包含 1000 个扇区，则访问一个扇区 的平均存取时间大约是",
        "answers": {
          "RightAnswer": "B",
          "A": "8.1ms",
          "B": "12.2ms",
          "C": "16.3ms",
          "D": "20.5ms"
        },
        "review": []
      },
      {
        "id": 21,
        "select": true,
        "detail": "在采用中断 I/O 方式控制打印输出的情况下，CPU 和打印控制接口中的 I/O 端口之间交换的信息不可能是",
        "answers": {
          "RightAnswer": "B",
          "A": "打印字符",
          "B": "主存地址",
          "C": "设备状态",
          "D": "控制命令"
        },
        "review": []
      },
      {
        "id": 22,
        "select": true,
        "detail": "内部异常（内中断）可分为故障（fault）、陷阱（trap）和终止（abort）三类。下列有关内部异常的叙述中，错误的是",
        "answers": {
          "RightAnswer": "D",
          "A": "内部异常的产生与当前执行指令相关",
          "B": "内部异常的检测由 CPU 内部逻辑实现",
          "C": "内部异常的响应发生在指令执行过程中",
          "D": "内部异常处理后返回到发生异常的指令继续执行"
        },
        "review": []
      },
      {
        "id": 23,
        "select": true,
        "detail": "处理外部中断时，应该由操作系统保存的是",
        "answers": {
          "RightAnswer": "B",
          "A": "程序计数器(PC)的内容",
          "B": "通用寄存器的内容",
          "C": "块表(TLB)中的内容",
          "D": "Cache 中的内容"
        },
        "review": [
          {
            "detail": "\n                                                                    PC值由中断隐指令自动保存。\n                                                            "
          }
        ]
      },
      {
        "id": 24,
        "select": true,
        "detail": "假定下列指令已装入指令寄存器。则执行时不可能导致 CPU 从用户态变为内核态(系统态)的 是",
        "answers": {
          "RightAnswer": "C",
          "A": "DIV R0,R1 ; (R0)/(R1)→R0",
          "B": "INT n ; 产生软中断",
          "C": "NOT R0 ; 寄存器 R0 的内容取非",
          "D": "MOV R0,addr ; 把地址 addr 处的内存数据放入寄存器 R0 中"
        },
        "review": []
      },
      {
        "id": 25,
        "select": true,
        "detail": "下列选项中，会导致进程从执行态变为就绪态的事件是",
        "answers": {
          "RightAnswer": "D",
          "A": "执行 P(wait)操作 ",
          "B": "申请内存失败 ",
          "C": "启动 I/O 设备",
          "D": "被高优先级进程抢占"
        },
        "review": []
      },
      {
        "id": 26,
        "select": true,
        "detail": "  若系统 S1 采用死锁避免方法，S2 采用死锁检测方法。下列叙述中，正确的是    Ⅰ．S1 会限制用户申请资源的顺序，而 S2 不会     Ⅱ．S1 需要进程运行所需资源总量信息，而 S2 不需要     Ⅲ．S1 不会给可能导致死锁的进程分配资源，而 S2 会 ",
        "answers": {
          "RightAnswer": "B",
          "A": "仅Ⅰ、Ⅱ ",
          "B": "仅Ⅱ、Ⅲ ",
          "C": "仅Ⅰ、Ⅲ",
          "D": "Ⅰ、Ⅱ、Ⅲ"
        },
        "review": [
          {
            "detail": "\n  死锁检测采用资源分配图。    在简化资源分配图时，先找出既不阻塞又不孤点的进程Pi，消去其请求边和分配边，，若能小区其所有的边，则称该图可以完全简化。    也是限制了分配顺序 \n"
          }
        ]
      },
      {
        "id": 27,
        "select": true,
        "detail": "系统为某进程分配了 4 个页框，该进程已访问的页号序列为 2,0,2,9,3,4,2,8,2,4,8,4,5。若进程要 访问的下一页的页号为 7，依据 LRU 算法，应淘汰页的页号是",
        "answers": {
          "RightAnswer": "A",
          "A": "2",
          "B": "3",
          "C": "4",
          "D": "8"
        },
        "review": []
      },
      {
        "id": 28,
        "select": true,
        "detail": "在系统内存中设置磁盘缓冲区的主要目的是",
        "answers": {
          "RightAnswer": "A",
          "A": "减少磁盘 I/O 次数",
          "B": "减少平均寻道时间",
          "C": "提高磁盘数据可靠性",
          "D": "实现设备无关性"
        },
        "review": []
      },
      {
        "id": 29,
        "select": true,
        "detail": "在文件的索引节点中存放直接索引指针10个，一级和二级索引指针各1个。磁盘块大小为1KB， 每个索引指针占 4 个字节。若某文件的索引节点已在内存中，则把该文件偏移量（按字节编址）为 1234 和 307400 处所在的磁盘块读入内存，需访问的磁盘块个数分别是",
        "answers": {
          "RightAnswer": "B",
          "A": "1,2 ",
          "B": "1,3",
          "C": "2,3",
          "D": "2,4"
        },
        "review": [
          {
            "detail": "\n                                                                    一个磁盘可以存放  1KB/4=256 个指针 直接索引指针为10个，代表偏移量在0－2560之间的都可以通过直接索引得到。  一级索引指针1个，256*256=65536，在2561－68096(65536+2560)之间需要访问两个磁盘块。  二级索引指针1个，所以在68096－256^3+68096之间需要访问三个磁盘块。 \n                                                            "
          }
        ]
      },
      {
        "id": 30,
        "select": true,
        "detail": "在请求分页系统中，页面分配策略与页面置换策略不能组合使用的是",
        "answers": {
          "RightAnswer": "C",
          "A": "可变分配，全局置换",
          "B": "可变分配，局部置换",
          "C": "固定分配，全局置换",
          "D": "固定分配，局部置换"
        },
        "review": []
      },
      {
        "id": 31,
        "select": true,
        "detail": "文件系统用位图法表示磁盘空间的分配情况，位图存于磁盘的 32～127 号块中，每个盘块占 1024 个字节，盘块和块内字节均从 0 开始编号。假设要释放的盘块号为 409612，则位图中要修改的位 所在的盘块号和块内字节序号分别是",
        "answers": {
          "RightAnswer": "C",
          "A": "81、1",
          "B": "81、2",
          "C": "82、1",
          "D": "82、2"
        },
        "review": [
          {
            "detail": "\nhttps://blog.csdn.net/u011240016/article/details/53128504\n"
          },
          {
            "detail": "\n                                                                    (409612+1)÷(1024×8)=50...13 32+50-1+1=82 13mod8 + 1 - 1=1\n                                                            "
          }
        ]
      },
      {
        "id": 32,
        "select": true,
        "detail": "某硬盘有 200 个磁道（最外侧磁道号为 0），磁道访问请求序列为：130,42,180,15,199，当前磁 头位于第 58 号磁道并从外侧向内侧移动。按照 SCAN 调度方法处理完上述请求后，磁头移过的磁道数 是",
        "answers": {
          "RightAnswer": "C",
          "A": "208",
          "B": "287",
          "C": "325",
          "D": "382"
        },
        "review": []
      },
      {
        "id": 33,
        "select": true,
        "detail": "通过 POP3 协议接收邮件时，使用的传输层服务类型是",
        "answers": {
          "RightAnswer": "D",
          "A": "无连接不可靠的数据传输服务",
          "B": "无连接可靠的数据传输服务",
          "C": "有连接不可靠的数据传输服务",
          "D": "有连接可靠的数据传输服务"
        },
        "review": []
      },
      {
        "id": 34,
        "select": true,
        "detail": "  使用两种编码方案对比特流 01100111 进行编码的结果如下图所示，编码 1 和编码 2 分别是   @https://uploadfiles.nowcoder.com/images/20200927/330910_1601201898222_7F64DA95B342E510C418FFBDE320997F@          ",
        "answers": {
          "RightAnswer": "A",
          "A": "NRZ 和曼彻斯特编码",
          "B": "NRZ 和差分曼彻斯特编码",
          "C": "NRZI 和曼彻斯特编码",
          "D": "NRZI 和差分曼彻斯特编码"
        },
        "review": []
      },
      {
        "id": 35,
        "select": true,
        "detail": "主机甲通过 128kbps 卫星链路，采用滑动窗口协议向主机乙发送数据，链路单向传播延迟为 250ms，帧长为 1000 字节。不考虑确认帧的开销，为使链路利用率不小于 80%，帧序号的比特数至少是",
        "answers": {
          "RightAnswer": "B",
          "A": "3",
          "B": "4",
          "C": "7",
          "D": "8"
        },
        "review": [
          {
            "detail": "\n@https://uploadfiles.nowcoder.com/images/20201129/207575826_1606618475639/9CE7950951D3146BB9E7AB66CFAC6C18@\n"
          }
        ]
      },
      {
        "id": 36,
        "select": true,
        "detail": "下列关于 CSMA/CD 协议的叙述中，错误的是",
        "answers": {
          "RightAnswer": "B",
          "A": "边发送数据帧，边检测是否发生冲突",
          "B": "适用于无线网络，以实现无线链路共享",
          "C": "需要根据网络跨距和数据传输速率限定最小帧长",
          "D": "当信号传播延迟趋近 0 时，信道利用率趋近 100%"
        },
        "review": []
      },
      {
        "id": 37,
        "select": true,
        "detail": "下列关于交换机的叙述中，正确的是",
        "answers": {
          "RightAnswer": "A",
          "A": "以太网交换机本质上是一种多端口网桥",
          "B": "通过交换机互连的一组工作站构成一个冲突域",
          "C": "交换机每个端口所连网络构成一个独立的广播域",
          "D": "以太网交换机可实现采用不同网络层协议的网络互联"
        },
        "review": []
      },
      {
        "id": 38,
        "select": true,
        "detail": "  某路由器的路由表如下表所示：   @https://uploadfiles.nowcoder.com/images/20200927/330910_1601202022507_1666DB46F65C589EE703A95051DF6BD8@   @https://uploadfiles.nowcoder.com/images/20200927/330910_1601202033931_72512DAA605789359599A6EF226E2105@    若路由器收到一个目的地址为 169.96.40.5 的 IP 分组，则转发该 IP 分组的接口是 ",
        "answers": {
          "RightAnswer": "C",
          "A": "S1",
          "B": "S2",
          "C": "S3",
          "D": "S4"
        },
        "review": [
          {
            "detail": "\n                                                                    最长前缀匹配原则\n                                                            "
          }
        ]
      },
      {
        "id": 39,
        "select": true,
        "detail": "主机甲和主机乙新建一个 TCP 连接，甲的拥塞控制初始阈值为 32KB，甲向乙始终以 MSS=1KB 大小的段发送数据，并一直有数据发送；乙为该连接分配 16KB 接收缓存，并对每个数据段进行确认， 忽略段传输延迟。若乙收到的数据全部存入缓存，不被取走，则甲从连接建立成功时刻起，未发送超时 的情况下，经过 4 个 RTT 后，甲的发送窗口是",
        "answers": {
          "RightAnswer": "A",
          "A": "1KB",
          "B": "8KB",
          "C": "16KB",
          "D": "32KB"
        },
        "review": []
      },
      {
        "id": 40,
        "select": true,
        "detail": "  某浏览器发出的 HTTP 请求报文如下：   @https://uploadfiles.nowcoder.com/images/20200927/330910_1601202119890_16B32EEA5677CA42D60126C675C9AF51@       下列叙述中，错误的是        ",
        "answers": {
          "RightAnswer": "C",
          "A": "该浏览器请求浏览 index.html",
          "B": "Index.html 存放在 www.test.edu.cn 上",
          "C": "该浏览器请求使用持续连接",
          "D": "该浏览器曾经浏览过 www.test.edu.cn"
        },
        "review": [
          {
            "detail": "\n                                                                    题目要求选择错误的，没有keep-alive字段\n                                                            "
          }
        ]
      },
      {
        "id": 41,
        "select": false,
        "detail": "  用单链表保存 m 个整数，结点的结构为：[data][link]，且|data|≤n（n 为正整数）。现 要求设计一个时间复杂度尽可能高效的算法，对于链表中 data 的绝对值相等的结点，仅保留第一次出 现的结点而删除其余绝对值相等的结点。例如，若给定的单链表 head 如下：   @https://uploadfiles.nowcoder.com/images/20200927/330910_1601202369885_0D69A60C73E3A9D793DEAFBF6312F355@    则删除结点后的 head 为：   @https://uploadfiles.nowcoder.com/images/20200927/330910_1601202386081_EE97878E5AE51C870584A73BCF3B5424@       要求：     1）给出算法的基本设计思想。     2）使用 C 或 C++语言，给出单链表结点的数据类型定义。    3）根据设计思想，采用 C 或 C++语言描述算法，关键之处给出注释。     4）说明你所设计算法的时间复杂度和空间复杂度。 ",
        "answers": {
          "detail": "\n  解答:    1）算法的基本设计思想 算法的核心思想是用空间换时间。使用辅助数组记录链表中已出现的数值，从而只需对链表进行 一趟扫描。 因为|data|≤n，故辅助数组 q 的大小为 n+1，各元素的初值均为 0。依次扫描链表中的各结点，同 时检查 q[|data|]的值，如果为 0，则保留该结点，并令 q[|data|]=1；否则，将该结点从链表中删除。       2）使用 C 语言描述的单链表结点的数据类型定义   @https://uploadfiles.nowcoder.com/images/20200927/330910_1601202442003_F4F966F936DF03156173EF82AC7545D2@       3）算法实现   @https://uploadfiles.nowcoder.com/images/20200927/330910_1601202463139_905F86593941A52F76000B1A1A3CF6F9@       【评分说明】若考生设计的算法满足题目的功能要求且正确，则酌情给分。 \n"
        },
        "review": [
          {
            "detail": "\nnode* delete_elem(node* head)\n{\n    if(head==null||head->next==null)return head;\n    node *p=head,*q=p->next;\n    int *s=new int [n+1];\n    int i=0;\n    for(;i<n+1;i++)\n    {\n        s[i]=0;\n    }\n    while(q)\n    {\n       if(s[abs(q->data)]==1)\n        {\n            p->next=q->next;\n            delete q;\n            q=p->next;\n        }\n        else\n        {\n            s[abs(q->data)]=1;\n            p=p->next;\n            q=q->next;\n        }\n    }\n    return head;\n} \n"
          }
        ]
      },
      {
        "id": 42,
        "select": false,
        "detail": "  已知含有 5 个顶点的图 G 如下图所示   @https://uploadfiles.nowcoder.com/images/20200927/330910_1601202522849_A55B444CD1D45BCFBF923107B9E60EE9@       请回答下列问题：     1）写出图 G 的邻接矩阵 A（行、列下标从 0 开始）。     2）求 A 2，矩阵 A 2中位于 0 行 3 列元素值的含义是什么？     3）若已知具有 n（n≥2）个顶点的图的邻接矩阵为 B，则 B m（2≤m≤n）中非零元素的含义是什 么？ ",
        "answers": {
          "detail": "\n @https://uploadfiles.nowcoder.com/images/20200927/330910_1601202580489_3B85D320090F18BB89514C3ACC569B6E@ \n"
        },
        "review": []
      },
      {
        "id": 43,
        "select": false,
        "detail": "  某 16 位计算机的主存按字节编码，存取单位为 16 位；采用 16 位定长指令字格式； CPU 采用单总线结构，主要部分如下图所示。图中 R0～R3 为通用寄存器；T 为暂存器；SR 为移位寄 存器，可实现直送（mov）、左移一位（left）和右移一位（right）3 种操作，控制信号为 SRop，SR 的 输出由信号 SRout 控制；ALU 可实现直送 A（mova）、A 加 B（add）、A 减 B（sub）、A 与 B（and）、 A 或 B（or）、非 A（not）、A 加 1（inc）7 种操作，控制信号为 ALUop      @https://uploadfiles.nowcoder.com/images/20200927/330910_1601202938073_15888E09FB86932F9BB952FCE6E98266@       请回答下列问题。     1）图中哪些寄存器是程序员可见的？为何要设置暂存器 T？    2）控制信号 ALUop 和 SRop 的位数至少各是多少？     3）控制信号 SRout 所控制部件的名称或作用是什么？     4）端点①～⑨中，哪些端点须连接到控制部件的输出端？     5）为完善单总线数据通路，需要在端点①～⑨中相应的端点之间添加必要的连线。写出连线 的起点和终点，以正确表示数据的流动方向。    6）为什么二路选择器 MUX 的一个输入端是 2？ ",
        "answers": {
          "detail": "\n  解答：     1）程序员可见寄存器为通用寄存器（R0～R3）和 PC。因为采用了单总线结构，因此，若无暂存 器 T，则 ALU 的 A、B 端口会同时获得两个相同的数据，使数据通路不能正常工作。     【评分说明】回答通用寄存器（R0～R3），给分；回答 PC，给分；部分正确，酌情给分。设置暂存 器 T 的原因若回答用于暂时存放端口 A 的数据，则给分，其他答案，酌情给分。       2）ALU 共有 7 种操作，故其操作控制信号 ALUop 至少需要 3 位；移位寄存器有 3 种操作，其操 作控制信号 SRop 至少需要 2 位。        3）信号 SRout 所控制的部件是一个三态门，用于控制移位器与总线之间数据通路的连接与断开。     【评分说明】只要回答出三态门或者控制连接/断开，即给分。        4）端口①、②、③、⑤、⑧须连接到控制部件输出端。     【评分说明】答案包含④、⑥、⑦、⑨中任意一个，不给分；答案不全酌情给分。        5）连线 1，⑥→⑨；连线 2，⑦→④。     【评分说明】回答除上述连线以外的其他连线，酌情给分。        6）因为每条指令的长度为 16 位，按字节编址，所以每条指令占用 2 个内存单元，顺序执行时， 下条指令地址为(PC)+2。MUX 的一个输入端为 2，可便于执行(PC)+2 操作。 \n"
        },
        "review": []
      },
      {
        "id": 44,
        "select": false,
        "detail": "  题 43 中描述的计算机，其部分指令执行过程的控制信号如下图所示   @https://uploadfiles.nowcoder.com/images/20200927/330910_1601203057620_EDA376204B6C7E9C07F7F2FE5B8C3DC2?x-oss-process=image/resize,p_75@       该机指令格式如下图所示，支持寄存器直接和寄存器间接两种寻址方式，寻址方式位分别为 0 和 1， 通用寄存器 R0～R3 的编号分别为 0、1、2 和 3。      @https://uploadfiles.nowcoder.com/images/20200927/330910_1601203091444_707ED1C13FA6896681B1909B706C705C?x-oss-process=image/resize,p_84@       请回答下列问题。     1）该机的指令系统最多可定义多少条指令？        2）假定 inc、shl 和 sub 指令的操作码分别为 01H、02H 和 03H，则以下指令对应的机器代码 各是什么？     ① inc R1 ; R1 + 1→R1     ② shl R2,R1 ; (R1) << 1→R2     ③ sub R3, (R1),R2 ; ((R1)) – (R2) → R3        3）假设寄存器 X 的输入和输出控制信号分别为 Xin 和 Xout，其值为 1 表示有效，为 0 表示 无效（例如，PCout=1 表示 PC 内容送总线）；存储器控制信号为 MEMop，用于控制存储器的读 (read）和写(write)操作。写出题图 a 中标号①～⑧处的控制信号或控制信号的取值。        4）指令“sub R1,R3,(R2)”和“inc R1”的执行阶段至少各需要多少个时钟周期？    ",
        "answers": {
          "detail": "\n  解答：        1）指令操作码有 7 位，因此最多可定义 2 7 =128 条指令。        2）各条指令的机器代码分别如下： 2014 年全国硕士研究生入学统一考试计算机科学与技术学科联考计算机学科专业基础综合试题 ·011·     ①“inc R1”的机器码为：0000001 0 01 0 00 0 00，即 0240H。     ②“shl R2，R1”的机器码为：0000010 0 10 0 01 0 00，即 0488H。     ③“sub R3，(R1),R2”的机器码为：0000011 0 11 1 01 0 10，即 06EAH。        3）各标号处的控制信号或控制信号取值如下： ①0；②mov；③mova；④left；⑤read；⑥sub；⑦mov；⑧Srout。     【评分说明】答对两个给分。        4）指令“sub R1，R3，(R2)”的执行阶段至少包含 4 个时钟周期；指令“inc R1”的执行阶段至 少包含 2 个时钟周期 \n"
        },
        "review": [
          {
            "detail": "\n                                                                    为啥就7位了啊，就算后面那些操作数占9位怎么推出指令格式占16位呢？\n                                                            "
          }
        ]
      },
      {
        "id": 45,
        "select": false,
        "detail": "有 A、B 两人通过信箱进行辩论，每个人都从自己的信箱中取得对方的问题。将答案和向对方提出的新问题组成一个邮件放入对方的邮箱中。假设 A 的信箱最多放 M 个邮件，B 的信箱最多放 N 个邮件。初始时 A 的信箱中有 x 个邮件（0<x<M），B 的信箱中有 y 个（0<y<N）。辩论者每取出一个邮件，邮件数减 1。A 和 B 两人的操作过程描述如下：   CoBegin   @https://uploadfiles.nowcoder.com/images/20200927/330910_1601203295363_4D3BF3DEA2AA53D751C8CDE8AC3C994E@    CoEnd        当信箱不为空时，辩论者才能从信箱中取邮件，否则等待。当信箱不满时，辩论者才能将新邮件 放入信箱，否则等待。请添加必要的信号量和 P、V（或 wait、signal）操作，以实现上述过程的同步。 要求写出完整过程，并说明信号量的含义和初值 ",
        "answers": {
          "detail": "\n  解答：     semaphore Full_A = x; //Full_A 表示 A 的信箱中的邮件数量     semaphore Empty_A = M-x; // Empty_A 表示 A 的信箱中还可存放的邮件数量     semaphore Full_B = y; //Full_B 表示 B 的信箱中的邮件数量     semaphore Empty_B = N-y; // Empty_B 表示 B 的信箱中还可存放的邮件数量     semaphore mutex_A = 1; //mutex_A 用于 A 的信箱互斥     semaphore mutex_B = 1; //mutex_B 用于 B 的信箱互斥      @https://uploadfiles.nowcoder.com/images/20200927/330910_1601203363359_DE9A24446C74D18A3693FAC2411B02D0@ \n"
        },
        "review": []
      },
      {
        "id": 46,
        "select": false,
        "detail": "  某计算机系统按字节编址，采用二级页表的分页存储管理方式，虚拟地址格式如下所示：   @https://uploadfiles.nowcoder.com/images/20200927/330910_1601203394764_25F1CE00375DCB54B142A77A43CA2438@    请回答下列问题。     1）页和页框的大小各为多少字节？进程的虚拟地址空间大小为多少页？     2）假定页目录项和页表项均占 4 个字节，则进程的页目录和页表共占多少页？要求写出计算过程。     3）若某指令周期内访问的虚拟地址为 0100 0000H 和 0111 2048H，则进行地址转换时共访问多少 个二级页表？要求说明理由。 ",
        "answers": {
          "detail": "\n@https://uploadfiles.nowcoder.com/images/20200927/330910_1601203424947_A7215BD21D4002015ADB6854C0377195@\n"
        },
        "review": [
          {
            "detail": "\n                                                                    链接：https://www.nowcoder.com/questionTerminal/7901dbba0c0a472abcafda74491a4d6e 来源：牛客网   解答：    1）在分页存储管理方式中，将用户程序的地址空间分为若干个固定大小的区域，称为“页”或“页面”。相应地，将内存空间分为若干个物理块或页框（frame），页和页框大小相同。因此，页和页框大小均为212B=4KB。进程的虚拟地址空间大小为232/212=220页。    2）（210×4）/212（页目录所占页数）+（220×4）/212（页表所占页数）=1025页。    3）需要访问一个二级页表。因为虚拟地址0100 0000H和0111 2048H的最高10位的值都是4，页目录号相同，访问的是同一个二级页表。    【评分说明】用其他方法计算，思路和结果正确同样给分。 \n"
          }
        ]
      },
      {
        "id": 47,
        "select": false,
        "detail": "  某网络拓扑如图所示，其中路由器内网接口、DHCP 服务器、WWW 服务器与主机 1 均采用静态 IP 地址配置，相关地址信息见图中标注；主机 2～主机 N 通过 DHCP 服务器动态获取 IP 地址等配置信息   @https://uploadfiles.nowcoder.com/images/20200927/330910_1601203458134_3237E41E2671D53E0B3B47F6C4DDCD0F?x-oss-process=image/resize,p_78@       请回答下列问题。     1）DHCP 服务器可为主机 2～主机 N 动态分配 IP 地址的最大范围是什么？主机 2 使用 DHCP 协 议获取 IP 地址的过程中，发送的封装 DHCP Discover     2）若主机 2 的 ARP 表为空，则该主机访问 Internet 时，发出的第一个以太网帧的目的 MAC 地址 是什么？封装主机 2 发往 Internet 的 IP 分组的以太网帧的目的 MAC 地址是什么？     3）若主机 1 的子网掩码和默认网关分别配置为 255.255.255.0 和 111.123.15.2，则该主机是否能访 问 WWW 服务器？是否能访问 Internet？请说明理由。 ",
        "answers": {
          "detail": "\n  解答：     1）DHCP 服务器可为主机 2～主机 N 动态分配 IP 地址的最大范围是：111.123.15.5～111.123.15.254； 主机 2 发送的封装 DHCP Discover 报文的 IP 分组的源 IP 地址和目的 IP 地址分别是 0.0.0.0 和 255.255.255.255。     2）主机 2 发出的第一个以太网帧的目的 MAC 地址是 ff-ff-ff-ff-ff-ff；封装主机 2 发往 Internet 的 IP 分组的以太网帧的目的 MAC 地址是 00-a1-a1-a1-a1-a1。    3）主机 1 能访问 WWW 服务器，但不能访问 Internet。由于主机 1 的子网掩码配置正确而默认网 关 IP 地址被错误地配置为 111.123.15.2（正确 IP 地址是 111.123.15.1），所以主机 1 可以访问在同一个子 网内的 WWW 服务器，但当主机 1 访问 Internet 时，主机 1 发出的 IP 分组会被路由到错误的默认网关 （111.123.15.2），从而无法到达目的主机。 \n"
        },
        "review": []
      }
    ]
  },
  {
    "title": 2014,
    "testDetail": [
      {
        "id": 1,
        "select": true,
        "detail": "  下列程序段的时间复杂度是     。       count=0;       for(k=1;k<=n;k*=2)          for(j=1;j<=n;j++)               count++;    ",
        "answers": {
          "RightAnswer": "C",
          "A": "O(log",
          "B": "O(n)",
          "C": "O(nlog",
          "D": "O(n"
        },
        "review": []
      },
      {
        "id": 2,
        "select": true,
        "detail": "假设栈初始为空，将中缀表达式 a/b+(c*d-e*f)/g 转换为等价的后缀表达式的过程中，当扫描到 f 时，栈中的元素依次是     。",
        "answers": {
          "RightAnswer": "B",
          "A": "+ ( * -",
          "B": "+ ( - *",
          "C": "/ + ( * - *",
          "D": "/ + - *"
        },
        "review": []
      },
      {
        "id": 3,
        "select": true,
        "detail": "循环队列放在一维数组A[0…M-1]中，end1 指向队头元素，end2 指向队尾元素的后一个位置。假设队列两端均可进行入队和出队操作，队列中最多能容纳 M-1  个元素。初始时为空。下列判断队空和队满的条件中，正确的是     。",
        "answers": {
          "RightAnswer": "A",
          "A": "队空：end1 == end2；    队满：end1 == (end2+1)mod M",
          "B": "队空：end1 == end2；    队满：end2 == (end1+1)mod (M-1)",
          "C": "队空：end2 == (end1+1)mod M； 队满：end1 == (end2+1)mod M",
          "D": "队空：end1 == (end2+1)mod M； 队满：end2 == (end1+1)mod (M-1)"
        },
        "review": []
      },
      {
        "id": 4,
        "select": true,
        "detail": "  若对如下的二叉树进行中序线索化，则结点 x 的左、右线索指向的结点分别是     。                                  @https://uploadfiles.nowcoder.com/images/20200927/305420_1601205325963_4BEE949ED68E02D7BA8187BD2C273843@ ",
        "answers": {
          "RightAnswer": "D",
          "A": "e、c",
          "B": "e、a",
          "C": "d、c",
          "D": "b 、 a"
        },
        "review": []
      },
      {
        "id": 5,
        "select": true,
        "detail": "将森林 F 转换为对应的二叉树 T，F 中叶结点的个数等于     。",
        "answers": {
          "RightAnswer": "C",
          "A": "T 中叶结点的个数",
          "B": "T 中度为 1 的结点个数",
          "C": "T 中左孩子指针为空的结点个数",
          "D": "T 中右孩子指针为空的结点个数"
        },
        "review": []
      },
      {
        "id": 6,
        "select": true,
        "detail": "5 个字符有如下 4 种编码方案，不．是．前缀编码的是     。",
        "answers": {
          "RightAnswer": "D",
          "A": "01,0000,0001,001,1",
          "B": "011,000,001,010,1",
          "C": "000,001,010,011,100",
          "D": "0,100,110,1110,1100"
        },
        "review": []
      },
      {
        "id": 7,
        "select": true,
        "detail": "  对如下所示的有向图进行拓扑排序，得到的拓扑序列可能是     。   @https://uploadfiles.nowcoder.com/images/20200927/305420_1601205354309_F299D6B6707F7259F212DFD416FEC996@ ",
        "answers": {
          "RightAnswer": "D",
          "A": "3,1,2,4,5,6",
          "B": "3,1,2,4,6,5",
          "C": "3,1,4,2,5,6",
          "D": "3,1,4,2,6,5"
        },
        "review": []
      },
      {
        "id": 8,
        "select": true,
        "detail": "用哈希（散列）方法处理冲突（碰撞）时可能出现堆积（聚集）现象，下列选项中， 会受堆积现象直接影响的是     。",
        "answers": {
          "RightAnswer": "D",
          "A": "存储效率",
          "B": "散列函数",
          "C": "装填(装载)因子",
          "D": "平均查找长度"
        },
        "review": []
      },
      {
        "id": 9,
        "select": true,
        "detail": "在一棵具有 15 个关键字的 4 阶B 树中，含关键字的结点个数最多是     。",
        "answers": {
          "RightAnswer": "D",
          "A": "5",
          "B": "6",
          "C": "10",
          "D": "15"
        },
        "review": []
      },
      {
        "id": 10,
        "select": true,
        "detail": "用希尔排序方法对一个数据序列进行排序时，若第 1 趟排序结果为9,1,4,13,7,8,20,23,15，则该趟排序采用的增量（间隔）可能是     。",
        "answers": {
          "RightAnswer": "B",
          "A": "2",
          "B": "3",
          "C": "4",
          "D": "5"
        },
        "review": [
          {
            "detail": "\n                                                                    B\n                                                            "
          }
        ]
      },
      {
        "id": 11,
        "select": true,
        "detail": "下列选项中，不可能是快速排序第 2 趟排序结果的是     。",
        "answers": {
          "RightAnswer": "C",
          "A": "2,3,5,4,6,7,9",
          "B": "2,7,5,6,4,3,9",
          "C": "3,2,5,4,7,6,9",
          "D": "4,2,3,5,7,6,9"
        },
        "review": []
      },
      {
        "id": 12,
        "select": true,
        "detail": "程序P 在机器 M 上的执行时间是 20 秒，编译优化后，P 执行的指令数减少到原来的 70%，而CPI 增加到原来的 1.2 倍，则P 在M 上的执行时间是     。",
        "answers": {
          "RightAnswer": "D",
          "A": "8.4 秒",
          "B": "11.7 秒",
          "C": "14 秒",
          "D": "16.8 秒"
        },
        "review": []
      },
      {
        "id": 13,
        "select": true,
        "detail": "若 x=103，y=-25，则下列表达式采用 8 位定点补码运算实现时，会发生溢出的是     。",
        "answers": {
          "RightAnswer": "C",
          "A": "x+y",
          "B": "-x+y",
          "C": "x-y",
          "D": "-x-y"
        },
        "review": [
          {
            "detail": "\n                                                                    8位定点补码的范围是-128~127，转换为真值计算比较即可\n                                                            "
          }
        ]
      },
      {
        "id": 14,
        "select": true,
        "detail": "float 型数据据常用 IEEE754 单精度浮点格式表示。假设两个 float 型变量x 和 y 分别存放在 32 位寄存器 f1 和 f2 中，若(f1)=CC90 0000H，(f2)=B0C0 0000H，则 x 和 y 之间的关系为     。",
        "answers": {
          "RightAnswer": "A",
          "A": "x<y 且符号相同",
          "B": "x<y 且符号不同",
          "C": "x>y 且符号相同",
          "D": "x>y 且符号不同"
        },
        "review": []
      },
      {
        "id": 15,
        "select": true,
        "detail": "某容量为 256MB 的存储器由若干 4M×8 位的DRAM 芯片构成，该DRAM 芯片的地址引脚和数据引脚总数是     。",
        "answers": {
          "RightAnswer": "A",
          "A": "19",
          "B": "22",
          "C": "30",
          "D": "36"
        },
        "review": [
          {
            "detail": "\n容量为 4M * 8，则需要 22 条地址线、8 条数据线。 DRAM 芯片的地址线，在芯片中，是分时复用的，仅需一半的引脚数，即够用。 因此，容量为 4M * 8 的 DRAM 芯片，地址线需要 11 个引脚、数据线需要 8 个引脚。\n"
          }
        ]
      },
      {
        "id": 16,
        "select": true,
        "detail": "采用指令Cache 与数据 Cache 分离的主要目的是     。",
        "answers": {
          "RightAnswer": "D",
          "A": "降低Cache 的缺失损失",
          "B": "提高Cache 的命中率",
          "C": "降低CPU 平均访存时间",
          "D": "减少指令流水线资源冲突"
        },
        "review": []
      },
      {
        "id": 17,
        "select": true,
        "detail": "某计算机有 16 个通用寄存器，采用 32 位定长指令字，操作码字段（含寻址方式位）为 8 位，Store 指令的源操作数和目的操作数分别采用寄存器直接寻址和基址寻址方式。若基址寄存器可使用任一通用寄存器，且偏移量用补码表示，则 Store 指令中偏移量的取值范围是     。",
        "answers": {
          "RightAnswer": "A",
          "A": "-32768 ~ +32767",
          "B": "-32767 ~ +32768",
          "C": "-65536 ~ +65535",
          "D": "-65535 ~ +65536"
        },
        "review": [
          {
            "detail": "\n  总共32位二进制码，操作码占高位8位    即地址码为32-8=24位   16个通用寄存器即2^4（用4位二进制码表示）    源操作数和目的操作数都与通用寄存器有关    各自占4，4位    剩余24-4-4=16位为偏移量    16位用补码表示范围为-32768~32767（- 2 n-1 ～+ 2 n-1 –1） \n"
          }
        ]
      },
      {
        "id": 18,
        "select": true,
        "detail": "某计算机采用微程序控制器，共有 32 条指令，公共的取指令微程序包含 2 条微指令，各指令对应的微程序平均由 4 条微指令组成，采用断定法（下地址字段法）确定下条微指令地址，则微指令中下址字段的位数至少是     。",
        "answers": {
          "RightAnswer": "C",
          "A": "5",
          "B": "6",
          "C": "8",
          "D": "9"
        },
        "review": [
          {
            "detail": "\n                                                                    （32*4）+2＝130 2∧7＝128,2∧8＝256   128＜130＜256 \n                                                            "
          }
        ]
      },
      {
        "id": 19,
        "select": true,
        "detail": "某同步总线采用数据线和地址线复用方式，其中地址/数据线有 32 根，总线时钟频率为 66MHz，每个时钟周期传送两次数据(上升沿和下降沿各传送一次数据)，该总线的最大数据传输率(总线带宽)是     。",
        "answers": {
          "RightAnswer": "C",
          "A": "132 MB/s",
          "B": "264 MB/s",
          "C": "528 MB/s",
          "D": "1056 MB/s"
        },
        "review": []
      },
      {
        "id": 20,
        "select": true,
        "detail": "一次总线事务中，主设备只需给出一个首地址，从设备就能从首地址开始的若干连续单元读出或写入多个数据。这种总线事务方式称为     。",
        "answers": {
          "RightAnswer": "C",
          "A": "并行传输",
          "B": "串行传输",
          "C": "突发传输",
          "D": "同步传输"
        },
        "review": []
      },
      {
        "id": 21,
        "select": true,
        "detail": "下列有关 I/O 接口的叙述中，错误的是         。",
        "answers": {
          "RightAnswer": "D",
          "A": "状态端口和控制端口可以合用同一个寄存器",
          "B": "I/O 接口中CPU 可访问的寄存器称为 I/O 端口",
          "C": "采用独立编址方式时，I/O 端口地址和主存地址可能相同",
          "D": "采用统一编址方式时，CPU 不能用访存指令访问 I/O 端口"
        },
        "review": []
      },
      {
        "id": 22,
        "select": true,
        "detail": "若某设备中断请求的响应和处理时间为 100ns，每 400ns 发出一次中断请求，中断响应所允许的最长延迟时间为 50ns，则在该设备持续工作过程中，CPU 用于该设备的 I/O 时间占整个CPU 时间的百分比至少是     。",
        "answers": {
          "RightAnswer": "B",
          "A": "12.5%",
          "B": "25%",
          "C": "37.5%",
          "D": "50%"
        },
        "review": []
      },
      {
        "id": 23,
        "select": true,
        "detail": "下列调度算法中，不可能导致饥饿现象的是     。",
        "answers": {
          "RightAnswer": "A",
          "A": "时间片轮转",
          "B": "静态优先数调度",
          "C": "非抢占式短作业优先",
          "D": "抢占式短作业优先"
        },
        "review": [
          {
            "detail": "\n                                                                    a吧\n                                                            "
          }
        ]
      },
      {
        "id": 24,
        "select": true,
        "detail": "某系统有 n 台互斥使用的同类设备，三个并发进程分别需要 3、4、5 台设备，可确保系统不发生死锁的设备数 n 最小为     。",
        "answers": {
          "RightAnswer": "B",
          "A": "9",
          "B": "10",
          "C": "11",
          "D": "12"
        },
        "review": []
      },
      {
        "id": 25,
        "select": true,
        "detail": "下列指令中，不能在用户态执行的是     。",
        "answers": {
          "RightAnswer": "D",
          "A": "trap 指令",
          "B": "跳转指令",
          "C": "压栈指令",
          "D": "关中断指令"
        },
        "review": []
      },
      {
        "id": 26,
        "select": true,
        "detail": "一个进程的读磁盘操作完成后，操作系统针对该进程必做的是         。",
        "answers": {
          "RightAnswer": "A",
          "A": "修改进程状态为就绪态",
          "B": "降低进程优先级",
          "C": "给进程分配用户内存空间",
          "D": "增加进程时间片大小"
        },
        "review": [
          {
            "detail": "\n                                                                    为啥不是C?\n                                                            "
          }
        ]
      },
      {
        "id": 27,
        "select": true,
        "detail": "现有一个容量为 10GB 的磁盘分区，磁盘空间以簇(Cluster)为单位进行分配，簇的大小为 4KB，若采用位图法管理该分区的空闲空间，即用一位(bit)标识一个簇是否被分配， 则存放该位图所需簇的个数为     。",
        "answers": {
          "RightAnswer": "A",
          "A": "80",
          "B": "320",
          "C": "80K",
          "D": "320K"
        },
        "review": [
          {
            "detail": "\n 容量为10GB的磁盘分区，每个簇的大小是4kb共有2560个簇，需要2560Kbit才能管理2560个簇，存放2560Kbit需要的簇的数目为（2560k/8）B/4KB=80. \n"
          }
        ]
      },
      {
        "id": 28,
        "select": true,
        "detail": "  下列措施中，能加快虚实地址转换的是     。    I．增大快表(TLB)容量    II．让页表常驻内存    III．增大交换区(swap) ",
        "answers": {
          "RightAnswer": "C",
          "A": "仅I",
          "B": "仅 II",
          "C": "仅I、II",
          "D": "仅 II、III"
        },
        "review": []
      },
      {
        "id": 29,
        "select": true,
        "detail": "在一个文件被用户进程首次打开的过程中，操作系统需做的是         。",
        "answers": {
          "RightAnswer": "B",
          "A": "将文件内容读到内存中",
          "B": "将文件控制块读到内存中",
          "C": "修改文件控制块中的读写权限",
          "D": "将文件的数据缓冲区首指针返回给用户进程"
        },
        "review": []
      },
      {
        "id": 30,
        "select": true,
        "detail": "  在页式虚拟存储管理系统中，采用某些页面置换算法，会出现 Belady 异常现象， 即进程的缺页次数会随着分配给该进程的页框个数的增加而增加。下列算法中，可能出现Belady 异常现象的是     。    I．LRU 算法    II．FIFO 算法    III．OPT 算法 ",
        "answers": {
          "RightAnswer": "A",
          "A": "仅 II",
          "B": "仅I、II",
          "C": "仅I、III",
          "D": "仅 II、III"
        },
        "review": [
          {
            "detail": "\n                                                                    只有FIFO算法才会出现Belady现象\n                                                            "
          }
        ]
      },
      {
        "id": 31,
        "select": true,
        "detail": "下列关于管道(Pipe)通信的叙述中，正确的是     。",
        "answers": {
          "RightAnswer": "C",
          "A": "一个管道可实现双向数据传输",
          "B": "管道的容量仅受磁盘容量大小限制",
          "C": "进程对管道进行读操作和写操作都可能被阻塞",
          "D": "一个管道只能有一个读进程或一个写进程对其操作"
        },
        "review": []
      },
      {
        "id": 32,
        "select": true,
        "detail": "下列选项中，属于多级页表优点的是     。",
        "answers": {
          "RightAnswer": "D",
          "A": "加快地址变换速度",
          "B": "减少缺页中断次数",
          "C": "减少页表项所占字节数",
          "D": "减少页表所占的连续内存空间"
        },
        "review": []
      },
      {
        "id": 33,
        "select": true,
        "detail": "在 OSI 参考模型中，直接为会话层提供服务的是     。",
        "answers": {
          "RightAnswer": "C",
          "A": "应用层",
          "B": "表示层",
          "C": "传输层",
          "D": "网络层"
        },
        "review": [
          {
            "detail": "\n  物联网淑慧使用    下层为上层提供服务 \n"
          }
        ]
      },
      {
        "id": 34,
        "select": true,
        "detail": "  某以太网拓扑及交换机当前转发表如下图所示，主机 00-e1-d5-00-23-a1 向主机00-e1-d5-00-23-c1 发送 1 个数据帧， 主机 00-e1-d5-00-23-c1 收到该帧后， 向主机00-e1-d5-00-23-a1 发送 1 个确认帧，交换机对这两个帧的转发端口分别是（ ）。   @https://uploadfiles.nowcoder.com/images/20200927/305420_1601205799682_84D022CB958F1448E554F77C4F807504@ ",
        "answers": {
          "RightAnswer": "B",
          "A": "{3}和{1}",
          "B": "{2,3}和{1}",
          "C": "{2,3}和{1,2}",
          "D": "{1,2,3}和{1}"
        },
        "review": [
          {
            "detail": "\n                                                                    B, {2,3}和{1}\n"
          }
        ]
      },
      {
        "id": 35,
        "select": true,
        "detail": "下列因素中，不会影响信道数据传输速率的是     。",
        "answers": {
          "RightAnswer": "D",
          "A": "信噪比",
          "B": "频率宽带",
          "C": "调制速率",
          "D": "信号传播速度"
        },
        "review": []
      },
      {
        "id": 36,
        "select": true,
        "detail": "主机甲与主机乙之间使用后退N 帧协议(GBN)传输数据，甲的发送窗口尺寸为 1000，数据帧长为 1000 字节，信道带宽为 100Mbps，乙每收到一个数据帧立即利用一个短帧(忽略其传输延迟)进行确认，若甲乙之间的单向传播延迟是 50ms，则甲可以达到的最大平均数据传输速率约为     。",
        "answers": {
          "RightAnswer": "C",
          "A": "10Mbps",
          "B": "20Mbps",
          "C": "80Mbps",
          "D": "100Mbps"
        },
        "review": [
          {
            "detail": "\n1000*1000 = 10^6B 传过去的时间为：10^6*8/100Mbps = 0.08s 而传播时间为：0.05s*2 = 0.1s 所以能够传100*（0.08/0.1） = 80Mbps\n"
          }
        ]
      },
      {
        "id": 37,
        "select": true,
        "detail": "站点 A、B、C 通过CDMA 共享链路，A、B、C 的码片序列(chipping sequence)分别是(1,1,1,1)、(1,-1,1,-1)和(1,1,-1,-1)。若 C 从链路上收到的序列是(2,0,2,0,0,-2,0,-2,0,2,0,2)，则 C 收到A 发送的数据是     。",
        "answers": {
          "RightAnswer": "B",
          "A": "000",
          "B": "101",
          "C": "110",
          "D": "111"
        },
        "review": [
          {
            "detail": "\nC接收到的是A，B发送过来的叠加码片，C想要看A发送的数据，就将接收到的叠加码片与A的码片序列进行规格化内积操作：（2，0，2，0；0，-2，0，-2；0，2，0，2）每四位与（1，1，1，1）进行规格化内积，（2*1+0*1+2*1+0*1)/4=1;（0*1+-2*1+0*1+-2*1)/4=-1，-1即0;（0*1+2*1+0*1+2*1)/4=1;可以得到结果101\n"
          }
        ]
      },
      {
        "id": 38,
        "select": true,
        "detail": "主机甲和主机乙已建立了 TCP 连接，甲始终以 MSS=1KB 大小的段发送数据，并一直有数据发送；乙每收到一个数据段都会发出一个接收窗口为 10KB 的确认段。若甲在 t 时刻发生超时时拥塞窗口为 8KB，则从 t 时刻起，不再发生超时的情况下，经过 10 个 RTT 后，甲的发送窗口是     。",
        "answers": {
          "RightAnswer": "A",
          "A": "10KB",
          "B": "12KB",
          "C": "14KB",
          "D": "15KB"
        },
        "review": [
          {
            "detail": "\n   ssthresh被设定为8的一半即4，拥塞窗口被设为1KB    拥塞窗口经10个RTT依次变化为2、4（未超过ssthresh值之前以指数级增长，后面超过ssthresh之后以数量级增长）、5、6、7、8、9、10、11、12，最终达到12KB    而流量控制的角度出发，接受窗口恒为10KB    发送方的发送窗口=min(拥塞窗口，接收窗口)    故最后答案是10KB    \n"
          }
        ]
      },
      {
        "id": 39,
        "select": true,
        "detail": "  下列关于 UDP 协议的叙述中，正确的是     。    I．提供无连接服务 II．提供复用/分用服务 III．通过差错校验，保障可靠数据传输 ",
        "answers": {
          "RightAnswer": "B",
          "A": "仅 I",
          "B": "仅 I、II",
          "C": "仅 II、III",
          "D": "I、II、III"
        },
        "review": []
      },
      {
        "id": 40,
        "select": true,
        "detail": "使用浏览器访问某大学 Web 网站主页时，不可能使用到的协议是     。",
        "answers": {
          "RightAnswer": "D",
          "A": "PPP",
          "B": "ARP",
          "C": "UDP",
          "D": "SMTP"
        },
        "review": []
      },
      {
        "id": 41,
        "select": false,
        "detail": "  (13 分)二叉树的带权路径长度(WPL)是二叉树中所有叶结点的带权路径长度之和。给定一棵二叉树T，采用二叉链表存储，结点结构为：                                               @https://uploadfiles.nowcoder.com/images/20200927/305420_1601206202754_8106F2E7EC7C2AF822C7ED56A2F28CF4@    其中叶结点的weight域保存该结点的非负权值。设root为指向T 的根结点的指针，请设计求T的WPL 的算法，要求：     1） 给出算法的基本设计思想；    2） 使用C 或C++语言，给出二叉树结点的数据类型定义；    3)   根据设计思想，采用C 或C++语言描述算法，关键之处给出注释。 ",
        "answers": {
          "detail": "\n"
        },
        "review": [
          {
            "detail": "\nint wpl(tree *root,int n)\n{\n    if(root==null)return 0;\n    if(root->left==null&&root->right==null)return root->weight*n;\n    return wpl(root->left,n+1)+wpl(root->right,n+1);\n}\nint main_wpl(tree *root)\n{\n    return wpl(root,0);\n} \n"
          },
          {
            "detail": "\n                                                                    利用层次遍历，设置一个level表示层次，两个工作指针p,q分别用于指向当前访问节点和每层次最后一个节点就可以计算出wpl了。\n                                                            "
          }
        ]
      },
      {
        "id": 42,
        "select": false,
        "detail": " (10 分)某网络中的路由器运行 OSPF 路由协议，题 42 表是路由器 R1 维护的主要链路状态信息(LSI)，题 42 图是根据题 42 表及 R1 的接口名构造出来的网络拓扑。                                                                                     题 42 表  R1 所维护的 LSI  @https://uploadfiles.nowcoder.com/images/20200927/305420_1601206397465_08A31DD92D5147366710E1B59F980989@      @https://uploadfiles.nowcoder.com/images/20200927/305420_1601206431298_05D94C0E332291EA05DF831A6A08A932@                                                                                  题 42 图 R1 构造的网络拓扑  请回答下列问题。  1）本题中的网络可抽象为数据结构中的哪种逻辑结构？  2）针对题 42 表中的内容，设计合理的链式存储结构，以保存题 42 表中的链路状态信 息(LSI)。要求给出链式存储结构的数据类型定义，并画出对应题 42 表的链式存储结构示意图(示意图中可仅以 ID 标识结点)。  3）按照迪杰斯特拉(Dijikstra)算法的策略，依次给出 R1 到达题 42 图中子网 192.1.x.x 的最短路径及费用。",
        "answers": {
          "detail": "\n"
        },
        "review": []
      },
      {
        "id": 43,
        "select": false,
        "detail": "    （9 分）请根据题 42 描述的网络，继续回答下列问题。      1）假设路由表结构如下表所示，请给出题42图中R1的路由表，要求包括到达题42图中子网192.1.x.x 的路由，且路由表中的路由项尽可能少。                                                   @https://uploadfiles.nowcoder.com/images/20200927/305420_1601207819968_0E3E00EC05BDD309C54ABFEF58C2BC74@ 2）当主机192.1.1.130向主机192.1.7.211 发送一个TTL=64的IP 分组时，R1 通过哪个接口转发该IP分组？主机192.1.7.211收到的IP分组TTL 是多少？     3）若R1增加一条Metric为10的链路连接Internet，则题42表中R1的LSI 需要增加哪些信息？ ",
        "answers": {
          "detail": "\n"
        },
        "review": []
      },
      {
        "id": 44,
        "select": false,
        "detail": "  （12 分）某程序中有如下循环代码段@https://uploadfiles.nowcoder.com/images/20200927/305420_1601207488317_4585CF51B5FD17EB9BFD3D5326F2BCF2@”for(int i = 0; i < N; i++) sum+=A[i];”。假设编译时变量sum 和i 分别分配在寄存器R1 和R2 中。常量N 在寄存器R6 中，数组A 的首地址在寄存器R3 中。程序段P 起始地址为0804 8100H，对应的汇编代码和机器代码如下表所示。   @https://uploadfiles.nowcoder.com/images/20200927/305420_1601206880786_F717BDCBD17BE50CD89115E14F6263F0@            执行上述代码的计算机M采用32位定长指令字，其中分支指令bne 采用如下格式：                                   @https://uploadfiles.nowcoder.com/images/20200927/305420_1601206947898_91376478D0E0845006C51B72D711AFB4@            OP 为操作码@https://uploadfiles.nowcoder.com/images/20200927/305420_1601207534315_E03547C50180A7F8308B1F18B7EEF7F9@Rs和Rd 为寄存器编号；OFFSET 为偏移量，用补码表示。请回答下列问题，并说明理由。    1）M 的存储器编址单位是什么？    2） 已知sll 指令实现左移功能，数组A 中每个元素占多少位？    3） 题44 表中bne 指令的OFFSET 字段的值是多少？已知bne 指令采用相对寻址方式，当前PC 内容为bne 指令地址，通过分析题44 表中指令地址和bne 指令内容，推断出bne 指令的转移目标地址计算公式。    4） 若M 采用如下“按序发射、按序完成”的 5 级指令流水线：IF（取值）、ID（译码及取数）、EXE（执行）、MEM（访存）、WB（写回寄存器），且硬件不采取任何转发措施，分支指令的执行均引起3 个时钟周期的阻塞，则P 中哪些指令的执行会由于数据相关而发生流水线阻塞？哪条指令的执行会发生控制冒险？为什么指令1 的执行不会因为与指令5 的数据相关而发生阻塞？ ",
        "answers": {
          "detail": "\n"
        },
        "review": []
      },
      {
        "id": 45,
        "select": false,
        "detail": "  假设对于 44 题中的计算机 M 和程序 P 的机器代码，M 采用页式虚拟存储管理；P开始执行时，(R1)=(R2)=0，(R6)=1000，其机器代码已调入主存但不在 Cache 中；数组 A 未调入主存，且所有数组元素在同一页，并存储在磁盘同一个扇区。请回答下列问题并说明理由。            1）P 执行结束时，R2 的内容是多少？            2）M 的指令 Cache 和数据 Cache 分离。若指令 Cache 共有 16 行，Cache 和主存交换的块大小为 32 字节，则其数据区的容量是多少？若仅考虑程序段 P 的执行，则指令 Cache 的命中率为多少？            3）P 在执行过程中，哪条指令的执行可能发生溢出异常？哪条指令的执行可能产生缺页异常？对于数组 A 的访问，需要读磁盘和 TLB 至少各多少次？ ",
        "answers": {
          "detail": "\n"
        },
        "review": [
          {
            "detail": "\nhttps://kaoyan.koolearn.com/20210720/1457182.html\n"
          }
        ]
      },
      {
        "id": 46,
        "select": false,
        "detail": "  文件 F 由 200 条记录组成，记录从 1 开始编号。用户打开文件后，欲将内存中的一条记录插入到文件 F 中，作为其第 30 条记录。请回答下列问题，并说明理由。            1）若文件系统采用连续分配方式，每个磁盘块存放一条记录，文件 F 存储区域前后均有足够的空闲磁盘空间，则完成上述插入操作最少需要访问多少次磁盘块？F 的文件控制块内容会发生哪些改变？            2）若文件系统采用链接分配方式，每个磁盘块存放一条记录和一个链接指针，则完成上述插入操作需要访问多少次磁盘块？若每个存储块大小为 1KB，其中 4 个字节存放链接指针，则该文件系统支持的文件最大长度是多少？ ",
        "answers": {
          "detail": "\n"
        },
        "review": [
          {
            "detail": "\n                                                                    我觉得(1)答案有问题, 给的是59次, 但是没有考虑, 写控制块还有1次.\n"
          }
        ]
      },
      {
        "id": 47,
        "select": false,
        "detail": "  系统中有多个生产者进程和多个消费者进程，共享一个能存放 1000 件产品的环形缓冲区（初始为空）。当缓冲区未满时，生产者进程可以放入其生产的一件产品，否则等待；当缓冲区未空时，消费者进程可以从缓冲区取走一件产品，否则等待。要求一个消费者进程从缓冲区连续取出 10 件产品后，其他消费者进程才可以取产品。请使用信号量 P，V(wait()，signal())操作实现进程间的互斥与同步，要求写出完整的过程，并说明所用信号量的含义和初值。 ",
        "answers": {
          "detail": "\n"
        },
        "review": []
      }
    ]
  },
  {
    "title": 2013,
    "testDetail": [
      {
        "id": 1,
        "select": true,
        "detail": "  已知两个长度分别为m和n的升序链表，若将它们合并为一个长度为m+n的降序链表，则最坏情况下的时间复杂度是    ",
        "answers": {
          "RightAnswer": "D",
          "A": "O（n）",
          "B": "O（m×n）",
          "C": "O（min（m,n））",
          "D": "O（max（m，n））"
        },
        "review": [
          {
            "detail": "\n  两个有序链表合并为逆序链表,可大致分析其实现的流程及方式    先需将长度为m的list1与长度为n的list2分别逆序,这里可将逆序后的其中一个作为排序比较最终输出的链表.    也可以新初始化一个list3存放两个有序链表的值,再分别对两个有序链表进行逐一比较,最终确定顺序.    由此,可推断该步骤执行时间量级应为O(x),其中最坏情况时,x = max(m,n),也即时间复杂度为O(max(m,n))    最好情况时,x = min(m,n),也即时间复杂度为O(min(m,n)) \n"
          }
        ]
      },
      {
        "id": 2,
        "select": true,
        "detail": "一个栈的入栈序列为1,2,3,.....n“,其岀栈序列是P1,P2,P3,P4...Pn,。若P2=3,则P3可能取值的个数是",
        "answers": {
          "RightAnswer": "C",
          "A": "n-3",
          "B": "n-2",
          "C": "n-l",
          "D": "无法确定"
        },
        "review": [
          {
            "detail": "\n 一个栈的入栈序列为1,2,3,.....n“,其岀栈序列是P1,P2,P3,P4...Pn,。若P2=3,P3可能取值的个数   根据栈先进后出,后进先出的特性,若P2=3,意味着出栈的第二位即为3.   那么整个栈可以3为节点,分为两个序列,{1,2}和{4,...n}    P1可能为1,2,也可能为4,     P3也可能为1,2,这里要注意1,2虽在3之前,但也能在P3出栈    而P3唯一取不到的值即已确定出栈的3,因此可取值的个数为n-1 \n"
          },
          {
            "detail": "\n   P3 = 1 ： 入入出入出出        P3 = 2 :    入入入入出出出    P3 = 4 :    入入出入出入出    P3 = 5 :    入入出入出入入出    P3 = 6 :    入入出入出入入入出    。。。 \n"
          }
        ]
      },
      {
        "id": 3,
        "select": true,
        "detail": "若将关键字1,2,3,4,5,6,7依次插入到初始为空的平衡二叉树T中，则T中平衡因子为0的分支结点的个数是",
        "answers": {
          "RightAnswer": "D",
          "A": "0",
          "B": "1",
          "C": "2",
          "D": "3"
        },
        "review": [
          {
            "detail": "\n  首先必须清楚的先决条件是平衡因子的定义,某结点的左子树与右子树的高度(深度)差即为该结点的平衡因子（BF,Balance Factor）。平衡二叉树上所有结点的平衡因子只可能是 -1，0 或 1。将关键字1,2,3,4,5,6,7依次插入到初始为空的平衡二叉树T中,可得到以下平衡二叉树                  ⑤              ②          ⑥        ①    ④            ⑦            ③     该题目问平衡因子为0的分支结点个数,即为问该树中同时含有左右孩子的树为几个,由图可知,结点为⑤,②,⑥   若问平衡因子为-1的分支结点个数,即为问该树中仅有右孩子(0-1)的树为几个,由图可知,结点为⑦   若问平衡因子为1的分支结点个数,即为问该树中仅有左孩子(1-0)的树为几个,由图可知,结点为③ \n"
          }
        ]
      },
      {
        "id": 4,
        "select": true,
        "detail": "已知三叉树T中的6个叶结点的权分别是2,3,4,5,6，7，T的带权（外部）路径长度最小是",
        "answers": {
          "RightAnswer": "B",
          "A": "27",
          "B": "46",
          "C": "54",
          "D": "56"
        },
        "review": [
          {
            "detail": "\n  由题,三叉树T中的6个叶结点的权分别是2,3,4,5,6,7,构建最小带权生成树                                              13                              9        (6)        (7)                   5        (5)       (4)    (2)         (3)    第一层: 6,7    第二层: 5,4    第三层: 2,3   最小的带权路径长度为(2+3)*3 + (4+5)*2+(6+7)*1 = 46  \n"
          }
        ]
      },
      {
        "id": 5,
        "select": true,
        "detail": "若X是后序线索二叉树中的叶结点，且X存在左兄弟结点Y，则X的右线索指向的是（）",
        "answers": {
          "RightAnswer": "A",
          "A": "X的父结点",
          "B": "以Y为根的子树的最左下结点",
          "C": "X的左兄弟结点Y",
          "D": "以Y为根的子树的最右下结点"
        },
        "review": [
          {
            "detail": "\n                                                                    实际问的是后序遍历下一个节点是哪个节点\n                                                            "
          },
          {
            "detail": "\n  根据后续线索二叉树的定义,X结点为叶子结点且有左兄弟,    那么该结点为右孩子,通过后续遍历线索的方式可知,X结点的后继为其父结点,    也即X的右线索指向的是X的父结点 \n"
          }
        ]
      },
      {
        "id": 6,
        "select": true,
        "detail": "  在任意一颗非空二叉树排序树中T1中，删除某结点v之后形成二叉排序树T2，再将v插入T2形成二叉排序树T3.下列关于T1与T3的叙述中，正确的是    ①若v是T1的叶结点，则T1与T3不同    ②若v是T1的叶结点，则T1与T3相同    ③若v不是T1的叶结点，则T1与T3不同    ④若v不是T1的叶结点，则T1与T3相同 ",
        "answers": {
          "RightAnswer": "C",
          "A": "仅①、③",
          "B": "仅①、④",
          "C": "仅②、③",
          "D": "仅②、④"
        },
        "review": [
          {
            "detail": "\n  在一棵二叉排序树中删除一个结点后再将此结点插入到二叉排序树中    若删除的结点是叶子结点,那么在插入结点后,后来的二叉树与删除结点之前相同(二叉树结构不变,切不发生重新排序)    若删除的结点不是叶结点,而是某个分支结点或是叶结点,则二叉树重新排序,结构改变,    此时若再插入这个结点后,后来的二叉树可能发生变化,不完全相同 \n"
          }
        ]
      },
      {
        "id": 7,
        "select": true,
        "detail": "  设图的邻接矩阵A如下所示。各顶点的度依次是   @https://uploadfiles.nowcoder.com/images/20200927/305420_1601191495642_8E650021948DB807A0C2ADCE4AB2598E@    ",
        "answers": {
          "RightAnswer": "C",
          "A": "1,2,1,2",
          "B": "2,2,1,1",
          "C": "3,4,2,3",
          "D": "4,4,2,2"
        },
        "review": [
          {
            "detail": "\n  各顶点的度为：入度 + 出度    D1 = 第一行1的数量 + 第一列1的数量 = 3   D2 = 第二行1的数量 + 第二列1的数量 = 4   D3 = 第三行1的数量 + 第三列1的数量 = 2   D4 = 第四行1的数量 + 第四列1的数量 = 3    \n"
          },
          {
            "detail": "\n  将a = [[0 1 0 1                0 0 1 1                0 1 0 0                1 0 0 0 ]]   邻接矩阵是为图服务的，记录了图间定顶点间的关系。   邻接矩阵横向为该顶点的出度，纵向为该节点的入度，度=横向+纵向    由此,则可以计算,D(0) = 1 + 0 = 1    D(1) = 1 + 1  = 2    D(2) = 1 + 0 = 1    D(3) = 1 + 1  = 2 \n"
          }
        ]
      },
      {
        "id": 8,
        "select": true,
        "detail": "  若对如下无向图进行遍历，则下列选项中，不是广度优先遍历序列的是   @https://uploadfiles.nowcoder.com/images/20200927/305420_1601193074776_F466234A6FFC5C6638871849CB040892@ ",
        "answers": {
          "RightAnswer": "D",
          "A": "h,c,a,b,d,e,g,f",
          "B": "e,a,f,g,b,h,c,d",
          "C": "d,b,c,a,h,e,f,g",
          "D": "a,b,c,d,h,e,f,g"
        },
        "review": []
      },
      {
        "id": 9,
        "select": true,
        "detail": "  下列AOE网表示一项包含8个活动的工程。通过同时加快若干活动的进度可以缩短整 个工程的工期。下列选项中，加快其进度就可以缩短工程工期的是   @https://uploadfiles.nowcoder.com/images/20200927/305420_1601193538166_3D9BEC27167AAA32053B099BF825DEA1@ ",
        "answers": {
          "RightAnswer": "C",
          "A": "c和e",
          "B": "d和c",
          "C": "f和d",
          "D": "f和h"
        },
        "review": [
          {
            "detail": "\n  三条关键路径1.    1--->3---->5---->6                对应的活动时间为：  b,f,h                          2.    1---->3---->2---->4---->6     对应的活动时间为：  b,d,c,g                         3.     1---->3---->2---->5---->6     对应的活动时间为： b,d,e,h         根据AOE网的定义可知，关键路径上的活动时间同时减少，可以缩短工期    所以选f和d    \n"
          }
        ]
      },
      {
        "id": 10,
        "select": true,
        "detail": "在一棵高度为2的5阶B树中，所含关键字的个数最少是",
        "answers": {
          "RightAnswer": "A",
          "A": "5",
          "B": "7",
          "C": "8",
          "D": "14"
        },
        "review": [
          {
            "detail": "\n  8个       \n"
          }
        ]
      },
      {
        "id": 11,
        "select": true,
        "detail": "  对给定的关键字序列110,119,007,911,114,120,122进行基数排序，则第2趟分配收集后得到的关键字序列是       ",
        "answers": {
          "RightAnswer": "C",
          "A": "007,110,119,114,911,120,122",
          "B": "007,110,119,114,911,122,120",
          "C": "007,110,911,114,119,120,122",
          "D": "110,120,911,122,114 ,007,119"
        },
        "review": []
      },
      {
        "id": 12,
        "select": true,
        "detail": "某计算机主频为1.2 GHz,其指令分为4类，它们在基准程序中所占比例及CPI如下表 所示。  @https://uploadfiles.nowcoder.com/images/20200927/305420_1601194416246_132271096CFABEE01561FAAAA1E8A725@    该机的MIPS数是 ",
        "answers": {
          "RightAnswer": "C",
          "A": "100",
          "B": "200",
          "C": "400",
          "D": "600"
        },
        "review": []
      },
      {
        "id": 13,
        "select": true,
        "detail": "  某数采用IEEE 754单精度浮点数格式表示为C640 0000H,则该数的值是    ",
        "answers": {
          "RightAnswer": "A",
          "A": "-1.5x2",
          "B": "-1.5x2",
          "C": "-0.5x2",
          "D": "-0.5x2"
        },
        "review": []
      },
      {
        "id": 14,
        "select": true,
        "detail": "  某字长为8位的计算机中，已知整型变量x、y的机器数分别为[x]补=1 1110100，[y]补=1 0110000。若整型变量z=2×x+y/2，则z的机器数为    ",
        "answers": {
          "RightAnswer": "A",
          "A": "1 1000000",
          "B": "0 0100100",
          "C": "1 0101010",
          "D": "溢出"
        },
        "review": []
      },
      {
        "id": 15,
        "select": true,
        "detail": "  用海明码对长度为8位的数据进行检/纠错时，若能纠正一位错，则校验位数至少为   ",
        "answers": {
          "RightAnswer": "C",
          "A": "2",
          "B": "3",
          "C": "4",
          "D": "5"
        },
        "review": []
      },
      {
        "id": 16,
        "select": true,
        "detail": " 某计算机主存地址空间大小为256 MB,按字节编址。虚拟地址空间大小为4 GB,采用 页式存储管理，页面大小为4 KB,TLB（快表）采用全相联映射，有4个页表项，内容如下 表所示。   @https://uploadfiles.nowcoder.com/images/20200927/305420_1601195933691_DDCE08CC3B91E5D469440EA9AE60EC42@    则对虚拟地址03FF F180H进行虚实地址变换的结果是       ",
        "answers": {
          "RightAnswer": "A",
          "A": "015 3180H",
          "B": "003 5180H",
          "C": "TLB缺失",
          "D": "缺页"
        },
        "review": []
      },
      {
        "id": 17,
        "select": true,
        "detail": "     假设变址寄存器R的内容为1000H，指令中的形式地址为2000H；地址1000H中的内容为2000H，地址2000H中的内容为3000H，地址3000H中的内容为4000H，则变址寻址方式下访问到的操作数是    ",
        "answers": {
          "RightAnswer": "D",
          "A": "1000H",
          "B": "2000H",
          "C": "3000H",
          "D": "4000H"
        },
        "review": []
      },
      {
        "id": 18,
        "select": true,
        "detail": "下列选项中，用于设备和设备控制器（I/O接口）之间互连的接口标准是",
        "answers": {
          "RightAnswer": "B",
          "A": "PCI",
          "B": "USB",
          "C": "AGP",
          "D": "PCI-Express"
        },
        "review": []
      },
      {
        "id": 19,
        "select": true,
        "detail": "  下列选项中，用于提高RAID可靠性的措施有   ①磁盘镜像    ②条带化 ③奇偶校验 ④增加Cache机制       ",
        "answers": {
          "RightAnswer": "B",
          "A": "仅①、②",
          "B": "仅①、③",
          "C": "仅①、③、④",
          "D": "仅②、③和④"
        },
        "review": []
      },
      {
        "id": 20,
        "select": true,
        "detail": "  某磁盘的转速为10 000转/分，平均寻道时间是6 ms,磁盘传输速率是20 MB/s,磁盘控 制器延迟为0.2 ms,读取一个4 KB的扇区所需的平均时间约为    ",
        "answers": {
          "RightAnswer": "B",
          "A": "9 ms",
          "B": "9.4 ms",
          "C": "12 ms",
          "D": "12.4 ms"
        },
        "review": [
          {
            "detail": "\n                                                                    根据公式：平均磁盘访问时间 = 平均寻道时间 + 平均旋转延时 + 传输时间 + 控制器延时， 平均寻道时间：6ms 平均旋转延迟：3ms    等于旋转一周时间的一半，即：10000转/分 => 1min/10000转 = 6ms/转 => 3ms/转 传输时间：0.2ms    4KB/20MB/s = 2*10-7s = 0.2ms 控制器延迟：0.2ms 故读取一个4KB的扇区所需时间为：6ms+3ms+0.2ms+0.2ms = 9.4ms\n                                                            "
          }
        ]
      },
      {
        "id": 21,
        "select": true,
        "detail": "下列关于中断I/O方式和DMA方式比较的叙述中，错误的是",
        "answers": {
          "RightAnswer": "D",
          "A": "中断I/O方式请求的是CPU处理时间，DMA方式请求的是总线使用权",
          "B": "中断响应发生在一条指令执行结束后,DMA响应发生在一个总线事务完成后",
          "C": "中断I/O方式下数据传送通过软件完成,DMA方式下数据传送由硬件完成",
          "D": "中断I/O方式适用于所有外部设备,DMA方式仅适用于快速外部设备"
        },
        "review": []
      },
      {
        "id": 22,
        "select": true,
        "detail": "  用户在删除某文件的过程中，操作系统不可能执行的操作是    ",
        "answers": {
          "RightAnswer": "A",
          "A": "删除此文件所在的目录",
          "B": "删除与此文件关联的目录项",
          "C": "删除与此文件对应的文件控制块",
          "D": "释放与此文件关联的内存缓冲区"
        },
        "review": []
      },
      {
        "id": 23,
        "select": true,
        "detail": "  为支持CD-ROM中视频文件的快速随机播放，播放性能最好的文件数据块组织方式是    ",
        "answers": {
          "RightAnswer": "A",
          "A": "连续结构",
          "B": "链式结构",
          "C": "直接索引结构",
          "D": "多级索引结构"
        },
        "review": []
      },
      {
        "id": 24,
        "select": true,
        "detail": "用户程序发出磁盘I/O请求后，系统的处理流程是:用户程序-＞系统调用处理程序一设 备驱动程序-中断处理程序。其中，计算数据所在磁盘的柱面号、磁头号、扇区号的程 序是",
        "answers": {
          "RightAnswer": "D",
          "A": "用户程序",
          "B": "系统调用处理程序",
          "C": "设备驱动程序",
          "D": "中断处理程序"
        },
        "review": [
          {
            "detail": "\n  答案应该是设备驱动程序    计算磁盘号、磁头号和扇区号的工作是由设备驱动程序完成的。题中的功能因设备硬件的 不同而不同， 因此应由厂家提供的设备驱动程序实现。 \n"
          }
        ]
      },
      {
        "id": 25,
        "select": true,
        "detail": "  若某文件系统索引结点(inode)中有直接地址项和间接地址项，则下列选项中，与单个 文件长度无关的因素是    ",
        "answers": {
          "RightAnswer": "A",
          "A": "索引结点的总数",
          "B": "间接地址索引的级数",
          "C": "地址项的个数",
          "D": "文件块大小"
        },
        "review": []
      },
      {
        "id": 26,
        "select": true,
        "detail": "  设系统缓冲区和用户工作区均采用单缓冲，从外设读入1个数据块到系统缓冲区的时 间为100,从系统缓冲区读入1个数据块到用户工作区的时间为5,对用户工作区中的1 个数据块进行分析的时间为90(如下图所示)。进程从外设读入并分析2个数据块的 最短时间是   @https://uploadfiles.nowcoder.com/images/20200927/305420_1601197561334_4B61FB0BEB0140E840F3483B3380AD1D@          ",
        "answers": {
          "RightAnswer": "C",
          "A": "200",
          "B": "295",
          "C": "300",
          "D": "390"
        },
        "review": []
      },
      {
        "id": 27,
        "select": true,
        "detail": "  下列选项中，会导致用户进程从用户态切换到内核态的操作是    ①整数除以零  ②sin（）函数调用  ③read系统调用    ",
        "answers": {
          "RightAnswer": "B",
          "A": "仅①、②",
          "B": "仅①、③",
          "C": "仅②、③",
          "D": "①、②和③"
        },
        "review": [
          {
            "detail": "\n                                                                    函数调用并不会切换到内核态，而除零操作引发中断，中断和系统调用都会切换到内核态进行相应处理。\n                                                            "
          }
        ]
      },
      {
        "id": 28,
        "select": true,
        "detail": "  计算机开机后，操作系统最终被加载到 ",
        "answers": {
          "RightAnswer": "D",
          "A": "BIOS",
          "B": "ROM",
          "C": "EPROM",
          "D": "RAM"
        },
        "review": [
          {
            "detail": "\n                                                                    内存中的系统区，这段区域是RAM（运行内存）\n                                                            "
          }
        ]
      },
      {
        "id": 29,
        "select": true,
        "detail": "  若用户进程访问内存时产生缺页，则下列选项中，操作系统可能执行的操作是    ①处理越界错    ②置换页    ③分配内存    ",
        "answers": {
          "RightAnswer": "B",
          "A": "仅①、②",
          "B": "仅②、③",
          "C": "仅①、③",
          "D": "①、②和③"
        },
        "review": []
      },
      {
        "id": 30,
        "select": true,
        "detail": "  某系统正在执行三个进程P1、P2和P3,各进程的计算(CPU)时间和I/O时间比例如下 表所示。   @https://uploadfiles.nowcoder.com/images/20200927/305420_1601198467165_82934C6DCC65D784523C058E4DA6A3ED@       为提高系统资源利用率,合理的进程优先级设置应为 ",
        "answers": {
          "RightAnswer": "B",
          "A": "Pl > P2 > P3",
          "B": "P3 > P2 > Pl",
          "C": "P2 > Pl = P3",
          "D": "Pl > P2 = P3"
        },
        "review": []
      },
      {
        "id": 31,
        "select": true,
        "detail": "  下列关于银行家算法的叙述中，正确的是    ",
        "answers": {
          "RightAnswer": "B",
          "A": "银行家算法可以预防死锁",
          "B": "当系统处于安全状态时，系统中一定无死锁进程",
          "C": "当系统处于不安全状态时,系统中一定会出现死锁进程",
          "D": "银行家算法破坏了死锁必要条件中的“请求和保持”条件"
        },
        "review": [
          {
            "detail": "\n  B    银行家算法 属于 避免死锁    使不进入不安全状态     一次分配所有资源 不存在请求和保持 \n"
          },
          {
            "detail": "\n                                                                    C\n                                                            "
          }
        ]
      },
      {
        "id": 32,
        "select": true,
        "detail": "  在OSI参考模型中，下列功能需由应用层的相邻层实现的是    ",
        "answers": {
          "RightAnswer": "B",
          "A": "对话管理",
          "B": "数据格式转换",
          "C": "路由选择",
          "D": "可靠数据传输"
        },
        "review": []
      },
      {
        "id": 33,
        "select": true,
        "detail": "  若下图为10BaseT网卡接收到的信号波形，则该网卡收到的比特串是   @https://uploadfiles.nowcoder.com/images/20200927/305420_1601199740274_6E0A733B121CDBFED1D198F9289158B6@       ",
        "answers": {
          "RightAnswer": "A",
          "A": "0011 0110",
          "B": "1010 1101 ",
          "C": "0101 0010",
          "D": "1100 0101"
        },
        "review": []
      },
      {
        "id": 34,
        "select": true,
        "detail": "  主机甲通过1个路由器（存储转发方式）与主机乙互联，两段链路的数据传输速率均为10Mbps，主机甲分别采用报文交换和分组大小为10kb的分组交换向主机乙发送1个大小为8Mb（1M=106）的报文。若忽略链路传播延迟、分组头开销和分组拆装时间，则两种交换方式完成该报文传输所需的总时间分别为 ",
        "answers": {
          "RightAnswer": "D",
          "A": "800ms、1600ms",
          "B": "801ms、1600ms",
          "C": "1600ms、800ms",
          "D": "1600ms、801ms"
        },
        "review": [
          {
            "detail": "\n   不进行分组时，   发送一个报文的时延是8Mb/10Mb/s=800ms，在接收端接收此报文的时延也是800ms，共计1600ms。   进行分组后，   发送一个报文的时延是10kb/10Mb/s=1ms，接收一个报文的时延也是1ms，但是在发送第二个报文时，第一个报文已经开始接收。共计有800个分组，总时间为801ms。          好了我自己没看懂哈哈         \n"
          }
        ]
      },
      {
        "id": 35,
        "select": true,
        "detail": "  下列介质访问控制方法中，可能发生冲突的是 ",
        "answers": {
          "RightAnswer": "B",
          "A": "CDMA",
          "B": "CSMA",
          "C": "TDMA",
          "D": "FDMA"
        },
        "review": []
      },
      {
        "id": 36,
        "select": true,
        "detail": "  HDLC协议对01111100 01111110组帧后对应的比特串为    ",
        "answers": {
          "RightAnswer": "B",
          "A": "01111100 00111110 10   ",
          "B": "01111100 01111101 01111110",
          "C": "01111100 01111101 0",
          "D": "01111100 01111110 01111101"
        },
        "review": [
          {
            "detail": "\n                                                                    为啥选b，答案错了？\n                                                            "
          },
          {
            "detail": "\n  在王道做完13年真题无聊来这写一下    不做不知道，一做吓一跳。这选项答案排版完全错了。。 \n"
          }
        ]
      },
      {
        "id": 37,
        "select": true,
        "detail": "  对于100 Mbps的以太网交换机，当输出端口无排队，以直通交换（cut-through switching） 方式转发一个以太网帧（不包括前导码）时，引入的转发延迟至少是    ",
        "answers": {
          "RightAnswer": "A",
          "A": "0μs",
          "B": "0.48μs",
          "C": "5.12μs",
          "D": "121.44μs"
        },
        "review": [
          {
            "detail": "\n                                                                    有个问题, 我没理解, 我感觉交换机送上链路难道不需要时间么? 就算直接转发, 也需要传输不是么?\n"
          },
          {
            "detail": "\n                                                                    直通交换方式是指以太网交换机可以在各端口间交换数据。它在输入端口检测到一个数据包时，检查该包的包头，获取包的目的地址，启动内部的动态查找表转换成相应的输出端口，在输入与输出交叉处接通，把数据包直通到相应的端口，实现交换功能。通常情况下，直通交换方式只检查数据包的包头即前14个字节，由于不需要考虑前导码，只需要检测目的地址的6B，所以最短的传输延迟是0.48μs。\n                                                            "
          },
          {
            "detail": "\n                                                                    谢谢这位博主 https://blog.csdn.net/u011240016/article/details/53173072\n"
          }
        ]
      },
      {
        "id": 38,
        "select": true,
        "detail": "  主机甲与主机乙之间已建立一个TCP连接，双方持续有数据传输，且数据无差错与丢 失。若甲收到1个来自乙的TCP段，该段的序号为1913、确认序号为2046、有效载荷为 100字节,则甲立即发送给乙的TCP段的序号和确认序号分别是    ",
        "answers": {
          "RightAnswer": "B",
          "A": "2046,2012",
          "B": "2046,2013",
          "C": "2047,2012",
          "D": "2047.2013"
        },
        "review": []
      },
      {
        "id": 39,
        "select": true,
        "detail": "下列关于SMTP协议的叙述中，正确的是",
        "answers": {
          "RightAnswer": "A",
          "A": "•只支持传输7比特ASCD码内容",
          "B": "支持在邮件服务器之间发送邮件",
          "C": "仅I、ii和m    b.仅I、口和iv",
          "D": "仅I、皿和N    D.仅口』和w"
        },
        "review": []
      },
      {
        "id": 40,
        "select": true,
        "detail": "  某CPU主频为1.03GHz，采用4级指令流水线，每个流水段的执行需要1个时钟周期。假定CPU执行了100条指令，在其执行过程中，没有发生任何流水线阻塞，此时流水线的吞吐率为 ",
        "answers": {
          "RightAnswer": "C",
          "A": "0.25×10",
          "B": "0.97×10",
          "C": "1.0×10",
          "D": "1.03×10"
        },
        "review": []
      },
      {
        "id": 41,
        "select": false,
        "detail": "  已知一个整数序列A = ( a0，a1，...an-1),其中0≤ai＜n（0≤i＜n）。若存在ap1=ap2=···=apm=x，且m>n/2（0＜pk＜n，1≤k≤m），则称x为A的主元素。例如A=（0,5,5,3,5,7,5,5），则5为主元素；又如A = ( 0,5,5,3,5,1,5 ,7 )，则A中没有主元素。 假设A中的几个元素保存在一个一维数组中，请设计一个尽可能高效的算法，找出A的主元素。若存在主元素，则输出该元素；否则输出-1。要求：    (1) 给出算法的基本设计思想    (2) 根据设计思想，釆用C或C++或Java语言描述算法，关键之处给出注释。    (3) 说明你所设计算法的时间复杂度和空间复杂度。    ",
        "answers": {
          "detail": "\n"
        },
        "review": [
          {
            "detail": "\nint main_elem(int A[],int n)\n{\n    if(n==0)return -1;\n    if(n==1)return A[0];\n    int i=0,count=1,temp=A[0];\n    for(i=1;i<n;i++)\n    {\n         if(A[i]==temp)count++;\n         else count--;\n          if(count==0)\n          {\n              temp=A[i];\n              count=1;\n          }\n    }\n    count=0;\n    for(i=0;i<n;i++)\n    {\n        if(A[i]==temp)count++;\n        if(count>n/2)return temp;\n    }\n    return -1;\n} \n"
          },
          {
            "detail": "\n       @https://uploadfiles.nowcoder.com/images/20190919/56_1568900435177_29C080A5413E925FE3B3CCB4048AB99B@          \n"
          }
        ]
      },
      {
        "id": 42,
        "select": false,
        "detail": "  设包含4个数据元素的集合S = {\" do\",‘‘for\", \"repeat\", \"while\"},各元素的査找概率依次为:p1 = 0.35 ,p2 = 0.15,p3 = 0.15,p4 = 0.35。将S保存在一个长度为4 的顺序表中，采用折半査找法，査找成功时的平均查找长度为2. 2。请回答：    (1) 若采用顺序存储结构保存S,且要求平均査找长度更短，则元素应如何排列？应使用何种查找方法？査找成功时的平均査找长度是多少？    (2) 若釆用链式存储结构保存S,且要求平均査找长度更短，则元素应如何排列？应使用何种查找方法？查找成功时的平均查找长度是多少？          ",
        "answers": {
          "detail": "\n"
        },
        "review": [
          {
            "detail": "\n                                                                    第一问可以采取折半查找的方法吗，采用for，do，while，repeat排列\n                                                            "
          },
          {
            "detail": "\n  (1)采用顺序存储结构，数据元素按其查找概率降序排列。    采用顺序查找方法。    查找成功时的平均查找长度=0.35x1+0.35x2+0.15x3+0.15x4=2.1。    (2)    答案一：    采用链式存储结构，数据元素按其查找概率降序排列，构成单链表。      采用顺序查找方法。      查找成功时的平均查找长度=0.35x1+0.35x2+0.15x3+0.15x4=2.1。   答案二：    采用二叉链表存储结构，构造二叉排序树，    元素存储方式    根结点for，左子树do，右子树根结点while（while左子树repeat） （a)    根结点while，左子树根结点do（do右子树for），右子树while       （b）    采用二叉排序树的查找方法。    查找成功时的平均查找长度=0.15x1+0.35x2+0.35x2+0.15x3=2.0。 \n"
          }
        ]
      },
      {
        "id": 43,
        "select": false,
        "detail": "  某32位计算机，CPU主频为800 MHz, Cache命中时的CPI为4, Cache块大小为32字节；主存采用8体交叉存储方式，每个体的存储字长为32位、存储周期为40 ns；存储器总线宽度为32位，总线时钟频率为200 MHz,支持突发传送总线事务。每次读突发传送总线事务的过程包括：送首地址和命令、存储器准备数据、传送数据。每次突发传送32字节，传送地址或32位数据均需要一个总线时钟周期。请回答下列问题，要求给出理由或计算过程。    (1) CPU和总线的时钟周期各为多少？总线的带宽(即最大数据传输率)为多少？    (2) Cache缺失时，需要用几个读突发传送总线事务来完成一个主存块的读取？    (3) 存储器总线完成一次读突发传送总线事务所需的时间是多少？    (4) 若程序BP执行过程中，共执行了100条指令，平均每条指令需进行1.2次访存，Cache缺失率为5%，不考虑替换等开销，则BP的CPU执行时间是多少？    ",
        "answers": {
          "detail": "\n"
        },
        "review": [
          {
            "detail": "\n                                                                    （1）CPU的时钟周期为：1/800 MHz=1.25 ns。 总线的时钟周期为：1/200 MHz=5ns. 总线带宽为：4BX200 MHz=800 MB/s或4 B/5 ns=800 MB/s。 （2）Cache块大小是32 B，总线宽度为32B，因此Cache缺失时需要一个读突发传送总线事务读取一个主存块。 （3）一次读突发传送总线事务包括一次地址传送和32 B数据传送：用1个总线时钟周期传输地址；由题干给出，存储周期为40ns，则我们启动第一个存储体花费的时间40ns，突发传输总共要读取8个字（32B/(32位/8bit)），那么总共花费的时间是40+(8-1)*5 ns，还要花1个总线周期把最后读出来的传过去，读突发传送总线事务时间：5ns +40 ns+(8-1)*5 ns+5 ns=85 ns. 【低位交叉的存储器，连续读取n个字所需要的时间是：t1 = T + (n-1)*t2 （其中T表示存储周期，t2代表总线传输周期）】 4）BP的CPU执行时间包括Cache命中时的指令执行时间和Cache缺失时带来的额外开销。命中时的指令执行时间：100×4× 1.25 ns=500 ns。指令执行过程中Cache缺失时的额外开销：1.2× 100× 5%×85 ns=510 ns.(85ns是上一题算出来的cache缺失耗费的时间) BP的CPU执行时间：500 ns+510 ns=1 010 ns. \n"
          }
        ]
      },
      {
        "id": 44,
        "select": false,
        "detail": "  某计算机釆用16位定长指令字格式，其CPU中有一个标志寄存器，其中包含进位/借位标志CF、零标志ZF和符号标志NF。假定为该机设计了条件转移指令，其格式如下：   @https://uploadfiles.nowcoder.com/images/20200927/305420_1601204341391_973AA3F29430261A85944D321021A0C1@    其中,00000为操作码OP；C、Z和N分别为CF、ZF和NF的对应检测位，某检测位为1 时表示需检测对应标志，需检测的标志位中只要有一个为1就转移，否则不转移，例如， 若C = l,Z = 0,N=l,则需检测CF和NF的值，当CF= 1或NF=1时发生转移;OFFSET 是相对偏移量，用补码表示。转移执行时，转移目标地址为(PC)+2+2xOFFSET；顺序执行时，下条指令地址为(PC)+2。请回答下列问题。       (1) 该计算机存储器按字节编址还是按字编址？该条件转移指令向后(反向)最多可跳 转多少条指令？    (2) 某条件转移指令的地址为200CH,指令内容如下图所示，若该指令执行时CF = 0, ZF = 0,NF=1,则该指令执行后PC的值是多少？若该指令执行时CF=1,ZF = 0, NF = 0,则该指令执行后PC的值又是多少？请给岀计算过程。   @https://uploadfiles.nowcoder.com/images/20200927/305420_1601204462753_6B94A554E3CFCD6D72DAB6AFFA47D652@       (3) 实现“无符号数比较小于等于时转移”功能的指令中，C、Z和N应各是什么？    (4) 以下是该指令对应的数据通路示意图，要求给出图中部件①〜③的名称或功能        @https://uploadfiles.nowcoder.com/images/20200927/305420_1601204491368_2925AB4FE9998AA705DA01CCB7F38B3D@    ",
        "answers": {
          "detail": "\n"
        },
        "review": []
      },
      {
        "id": 45,
        "select": false,
        "detail": "  某博物馆最多可容纳500人同时参观,有一个出入口，该出入口一次仅允许一个 人通过。参观者的活动描述如下：    cobegin    参观者进程i:    {    ...    进门；    ...    参观；    ...    出门；    }    coend    请添加必要的信号量和P、V(或wait()、signal())操作，以实现上述过程中的互斥与同步。要求写出完整的过程，说明信号量的含义并赋初值。    ",
        "answers": {
          "detail": "\n"
        },
        "review": []
      },
      {
        "id": 46,
        "select": false,
        "detail": "    某计算机主存按字节编址，逻辑地址和物理地址都是32位，页表项大小为4字 节。请回答下列问题。      （1）若使用一级页表的分页存储管理方式，逻辑地址结构为：                 @https://uploadfiles.nowcoder.com/images/20200927/305420_1601204660595_F8F6484052B02D580C956547A375D27D@    则页的大小是多少字节？页表最大占用多少字节？                  （2）若使用二级页表的分页存储管理方式，逻辑地址结构为：   @https://uploadfiles.nowcoder.com/images/20200927/305420_1601204704749_E82D499B1A5D97979846207C5DF8C746@       设逻辑地址为LA,请分别给出其对应的页目录号和页表索引的表达式。    （3）采用（1）中的分页存储管理方式，一个代码段起始逻辑地址为0000 8000H,其长度为8 KB,被装载到从物理地址0090 0000H开始的连续主存空间中。页表从主存0020 0000H开始的物理地址处连续存放，如下图所示（地址大小自下向上递增）。请计算岀该代码段对应的两个页表项的物理地址、这两个页表项中的页框号以及代码页面2的起始物理地址   @https://uploadfiles.nowcoder.com/images/20200927/305420_1601204876142_081E250F02A2A660FD5BBFC0508DF7F9@    ",
        "answers": {
          "detail": "\n"
        },
        "review": []
      },
      {
        "id": 47,
        "select": false,
        "detail": "    假设Internet的两个自治系统构成的网络如图所示，自治系统AS1由路由器R1连接两个子网构成；自治系统AS2由路由器R2、R3互联并连接3个子网构成。 各子网地址、R2的接口名、R1与R3的部分接口IP地址如图所示。     @https://uploadfiles.nowcoder.com/images/20200927/305420_1601205087168_AE5B0AA4D8BF1BEEEC3E0C00191EB0D6?x-oss-process=image/resize,p_94@            请回答下列问题。       (1) 假设路由表结构如下表所示。请利用路由聚合技术，给出R2的路由表，要求包括到达图中所有子网的路由，且路由表中的路由项尽可能少。   @https://uploadfiles.nowcoder.com/images/20200927/305420_1601205138672_3ED714E0114473E0E40D4CBD6BD081E0@    (2) 若R2收到一个目的IP地址为194. 17.20.200的IP分组，R2会通过哪个接口转发该IP分组？    (3) R1与R2之间利用哪个路由协议交换路由信息？该路由协议的报文被封装到哪个协议的分组中进行传输？       ",
        "answers": {
          "detail": "\n"
        },
        "review": [
          {
            "detail": "\n  （1）对于R2，从接口S0出去可以连到两个子网153.14.5.0/25和153.14.5.128/25，5的二进制为00000101，128的二进制为10000000，所以可以聚合为153.14.5.0/24；从接口E0出去可以连到194.17.20.128/25；从接口S1出去可以连到两个子网194.17.20.0/25和194.17.21.0/24，20的二进制为00010100，21的二进制为00010101，所以可以聚合为194.17.20.0/23。所以R2的路由表为            目的网络            下一跳            接口              153.14.5.0/24            153.14.3.2            S0              194.17.20.128/25               E0              194.17.20.0/23            194.17.24.2            S1         （2）根据最长前缀匹配原则，200的二进制为11001000，128的二进制为10000000，所以目的IP地址和194.17.20.128/25有25位是匹配的，也是最长的，所以应该从E0接口转发该分组。   （3）R1和R2属于不同的自治系统，应该用BGP协议交换路由信息，报文封装到TCP分组中传送。  \n"
          }
        ]
      }
    ]
  }
]